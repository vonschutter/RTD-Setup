#!/bin/bash
if [[ -z "$BASH_VERSINFO" ]]; then
	echo "SHELL ENV ERROR: You must use a BASH Shell to load this library. Exiting..."
	exit 255
fi
export RTD_VERSION="2.03"
: << 'Library_Documentation'
::              R T D   F u n c t i o n   L i b r a r y
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::// Linux //:::::::
::  Author(s):    SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
::  Version:    2.01
::
::
::  Purpose:    To collect and enable the use of code snippets in other scripts.
::          To document these thoroughly so that they may be useful for learning BASH.
::  Usage:      call this file using the "source" statement in bash.
::
::  This script is shared in the hopes that
::  someone will find it useful.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


             .--.           .---.        .-.
         .---|--|   .-.     | A |  .---. |~|    .--.
      .--|===|Ch|---|_|--.__| S |--|:::| |~|-==-|==|---.
      |%%|NT2|oc|===| |~~|%%| C |--|   |_|~|CATS|  |___|-.
      |  |   |ah|===| |==|  | I |  |:::|=| |    |GB|---|=|
      |  |   |ol|   |_|__|  | I |__|   | | |    |  |___| |
      |~~|===|--|===|~|~~|%%|~~~|--|:::|=|~|----|==|---|=|
      ^--^---'--^---^-^--^--^---'--^---^-^-^-==-^--^---^-'
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---  To see options to use this library type "bash _rtd_library --help"
---  To see useful documentation on each function in this library in a Terminal or remote ssh: "bash _rtd_library --devhelp"
---  To see useful documentation on each function in this library in GTK (local desktop): "bash _rtd_library --devhelp-gtk"


	Functions defined in this library:

	Function Name:                                    Description:
      ----------------------------------------------------------------------------------------------------------------
1     add_gnome3_favorite_app                            ;  Adds a new favorite app to the gnome favorites bar
2     backup_running_vm                                  ;  Backs up all running virtual machines on the local computer
3     check_dependencies                                 ;  Checks that software requirements are met so scripts do not fail
4     create_iso_image                                   ;  Creates an OS iso image
5     system::create_iso_image_debian                    ;  Creates a Debian iso image
6     create_physical_media_from_iso                     ;  Create physical media thumb drive from an ISO file
7     dependency::command_exists                         ;  Check if a command exists and attempt to install it if it does not (find matching package)
8     dependency::desktop                                ;  Check if you are running a given desktop (kde, gnome, xfce)
9     dependency::file                                   ;  Find and source an external script of a any name provided
10    dependency::os_linux                               ;  Verify if we are running bash in a linux session
11    dependency::search_local                           ;  Internal function to search defined paths for a given files name...
12    dependency::virtualization                         ;  Check that Virtualization is supported and handle deviations
13    dialog::check_menu_availability                    ;  Checks if it is possible to display graphical menus in a terminal
14    dialog::copy_file_progress                         ;  Display a progress box in terminal while copying files from one place to another
15    dialog::display_cmd_output                         ;  Display a command output in a dialog box
16    dialog::display_error                              ;  Display a supplied string as an ERROR box for a terminal user
17    dialog::display_notice                             ;  Display a supplied string as an OK box for a terminal user
18    dialog::display_result                             ;  Displays command results in a pretty terminal box
19    dialog::display_summary_message                    ;  Display all text in _summary_message with automatic/manual width
20    display_software_installation_choices_gtk          ;  Show software installation options defined in recipe file (external)
21    ensure_admin                                       ;  Elevates privileges to admin root for the whole script asks for password
22    err_no_menu_system_found                           ;  Function to handle what to do if it is not possible to currently display menus in a terminal
23    eval_params                                        ;  Function to evaluate parameters passed to a script (internal, not for use in other scripts)
24    generate_report_disk_space_used_by_directory       ;  Generate a disk usage report
25    github::clone_repo_user                            ;  Clone all repositories for a given user at github.com
26    github::list_all_user_repositories                 ;  List all repositories for a given user
27    InstallSoftwareFromRepo                            ;  Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Debian etc.
28    is_software_package_available                      ;  Checks to see if a software package is available in a repository
29    is_software_package_installed                      ;  Checks to see if a software package already is installed
30    kvm::make_vm_template_now_from_debian_org          ;  Generate a Debian virtual machine template directly from debian.org
31    kvm::make_vm_template_now_from_microsoft           ;  Make a virtual machine running Windows
32    kvm::make_vm_template_now_from_redhat_com          ;  Generate a RedHat (or compatible) vm template to be cloned later
33    kvm::make_vm_template_now_from_ubuntu_com          ;  Immediately create a virtual machine from ubuntu.com
34    list_loaded_internal_functions                     ;  List all internal library functions loaded... for debugging/support purposes.
35    list_loaded_software_functions                     ;  List all software (_rtd_recipes) functions loaded... for debugging/support purposes.
36    make_kvm_virtual_machine_now_from_fedora_org       ;  Generate a Fedora virtual machine template directly from Fedora.org
37    make_kvm_virtual_machine_now_from_iso              ;  Make a virtual machine from a generated ISO image
38    make_kvm_virtual_machine_now_from_opensuse_org     ;  Generate an OpenSUSE virtual machine template directly from opensuse.org
39    oem::check_boot_splash_screen_enable               ;  Check if the boot splash screen should be enabled
40    oem::deploy_themes                                 ;  Deploy themes to the system supplied by OEM (see RTD-Setup/themes)
41    oem::register_all_tools                            ;  Register all OEM scripts so that they are accessible by terminal
42    oem::register_wallpapers_for_gnome                 ;  Register wallpapers for Gnome (so they show up in the appearance tool)
43    oem::rtd_reset_default_environment_config          ;  Reset the default environment configuration
44    oem::rtd_tools_make_launchers                      ;  Creates a default set of pre-defined launchers
45    pause_a_given_time                                 ;  Pause while showing a count down in seconds
46    rtd_oem_kde_set_wallpaper                          ;  Sets wallpaper in the plasma workspace
47    rtd_oem_pause                                      ;  Pause function
48    rtd_oem_release_upgrade                            ;  Attempt to perform a release upgrade for supported systems
49    rtd_oem_remove_non_western_latin_fonts             ;  Remove all non-latin fonts from a distribution. for the western world these are not needed and slow the system
50    rtd_oem_setup_brand_splash_screen                  ;  Brands splash screens on a bootable distribution install media
51    rtd_oem_turn_on_gui_network_management             ;  Set network managers to manage network interfaces if not set
52    rtd_oem_ubuntu_auto_install_iso_builder            ;  Creates automatic install media for Ubuntu
53    rtd_ppa_checker                                    ;  Checks PPA archives on supported distributions
54    rtd_server_setup_choices_productivity              ;  Builtin Server terminal productivity software install options
55    rtd_server_setup_choices_services                  ;  Builtin Server software options
56    rtd_setup_choices_server                           ;  Software installation choices for servers (over remote ssh)
57    rtd_update_system                                  ;  Performs a software update/refresh on supported distributions
58    security::check_if_password_pOwned                 ;  Allows user to check if an intended password is already in well known dictionaries
59    security::enable_firewall                          ;  Will turn on UFW and add the Allow SSH rule
60    security::scan_for_malware                         ;  Scans the system for malware
61    set_colors                                         ;  Set colors for prompting on screen in human usable variables
62    set_gnome_ui_common_tweaks_for_user                ;  Set common UI usability tweaks
63    set_gnome_ui_corporate_crisp_tweaks_for_user       ;  Set corporate/business friendly UI tweaks
64    set_gnome_ui_mac_tweaks_for_user                   ;  Set MAC UI usability tweaks
65    set_gnome_ui_moca_tweaks_for_user                  ;  Set eye strain friendly flat theme UI tweaks
66    set_gnome_ui_tweak_no_media_error                  ;  Function to handle missing themes for gnome
67    set_gnome_ui_win10_tweaks_for_user                 ;  Set Windows 10 UI usability tweaks
68    set_install_command                                ;  Determines what install command should be used to install packages from repositories
69    software::add_gnome_extensions                     ;  Installs gnome extensions from the gnome extensions website
70    software::add_native_package                       ;  Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Debian etc.
71    software::add_software_task                        ;  Wrapper function to execute a command and display pretty terminal OK or FAIL
72    software::check_native_package_dependency          ;  Checks to see if a software package already is installed
73    software::display_bundle_install_choices_gtk       ;  Show a menu of all installable software bundles defined in _rtd_recipes
74    software::display_bundle_removal_choices_gtk       ;  Show a menu of installed software bundles that may be removed
75    software::ensure_flatpak_package_managment         ;  Ensure that the flatpak software management is available
76    software::ensure_restricted_codecs                 ;  Ensure that restricted codecs are installed
77    software::ensure_snap_package_managment            ;  Ensure that the snap software management system is installed
78    software::ensure_software_store_available          ;  Ensure that the appropriate software store is available with Flatpak & Snap support
79    software::from_flathub.org                         ;  Install software from flathub.org
80    software::from_snapcraft.io                        ;  Install software from snapcraft.io automatically adjusting for classic or restricted access.
81    software::is_native_package_available              ;  Checks to see if a software package is available in a repository
82    software::is_native_package_installed              ;  Checks to see if a software package already is installed
83    software::list_bundles                             ;  Lists software bundles defined in _rtd_recipes
84    SoftwareManagementAvailabilityCHK                  ;  Checks to see that the software managment system is not busy
85    software::native_management_availability_check     ;  Checks to see that the native software managment system is not busy
86    software::package_kit::add_package                 ;  Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Debian etc.
87    software::package_kit::remove_package              ;  Removes a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Debian etc.
88    software::remove_native_software_package           ;  Removes a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Debian etc.
89    software::update_all_ui                            ;  Updates all software on the system using the native package manager, snap and flatpak
90    software::update_system_txt                        ;  Updates all software on the system using the native package manager, snap and flatpak with no UI
91    software::vendor_download_and_install              ;  Downloads and installs a package from the internet
92    system::add_or_remove_login_script                 ;  Add or remove a login script
93    system::change_disk_pass                           ;  Allows user to change password of the system partition encrypted disk
94    system::check_file_limits                          ;  check and display the current usage of file descriptors against the set limits
95    system::check_required_variables                   ;  Check that all required variables are set
96    system::cleanup_and_finish                         ;  Cleans and clears variables and temp files used by the media creations functions
97    system_config::tune_system_power_profile           ;  Tune the system power profile based on detected Laptop or PC or VM
98    system::create_physical_media_from_ubuntu_iso      ;  Create physical media thumb drive from an Ubuntu ISO file
99    system::create_swapfile                            ;  Create a new swapfile
100   system::display_spinner                            ;  Display a spinner in the terminal
101   system::distribution_type                          ;  Determines the Linux distribution type of the system on which it is run
102   system::download_and_manipulate_iso_debian         ;  Download and modify a debian iso to automatically install OEM addons
103   system::ensure_admin                               ;  Elevates privileges to admin root for the whole script asks for password
104   system::find_download_ubuntu_iso                   ;  Find and download an Ubuntu ISO file
105   system::find_vm_bridge                             ;  Echo back the name of the bridge device and if one is not found then echo default (nat)
106   system::generate_autoyast_file                     ;  Generate an autoyast file for SUSE
107   system::generate_cloudconfig                       ;  Function to generate a cloud config file for use in deploying servers
108   system::generate_ks_cfg_file                       ;  Creates a kickstart file for fedora
109   system::get_vm_config                              ;  Get the configuration for a virtual machine
110   system::get_Windows_Product_Key                    ;  Retrieves a Microsoft Windows product key if it is stored in BIOS (common for OEM)
111   system::io_on_notify_wait                          ;  Wait for a disk change and then execute a command
112   system::log_item                                   ;  Log an item to the log file preferring '$_LOGFILE' if it is defined
113   system::make_preseed_cfg                           ;  Generate a debian + derivatives preseed file for fully automated installs
114   system::make_system_recovery_partition             ;  Build a system recovery partition
115   system::oem_autounlock_disk                        ;  To DO (Incomplete) to setup automatic unlock of system disk... maybe using TPM
116   system::prepare_environment_for_iso_creation       ;  Prepare the environment for ISO creation
117   system::preseed_to_ubuntu_ks_cfg                   ;  TO DO (incomplete)
118   system::process_vm_opt_args                        ;  Process optional arguments for virtual machine creation
119   system::read_config                                ;  Read the configuration for a virtual machine
120   system::remove_old_kernel                          ;  Removes all old linux kernels
121   system::restart_sound                              ;  Restart sound service in user session on system...
122   system::rtd_oem_check_inet_access                  ;  Verifies that the internet is accessible
123   system::rtd_oem_find_live_release                  ;  locate and download live media for debian and ubuntu
124   system::rtd_oem_reseal                             ;  Reseals the system for delivery to a new user user will be asked for password and locale etc.
125   system::run_command_in_gnome_user_session          ;  Running with elevated privileges
126   system::set_oem_elevated_privilege_gui             ;  Set the system to auto elevate privileges for the OEM
127   system::toggle_oem_auto_elevated_privilege         ;  Toggle the system to auto elevate privileges for the OEM
128   system::toggle_oem_auto_login                      ;  Toggle the system to auto login for the OEM
129   system::update_config                              ;  Update the configuration for a virtual machine
130   system::wait_for_internet_availability             ;  Checks that the internet is reachable and waits until it is...
131   template::autounattend_xml                         ;  Template for an autounattend.xml file
132   template::AutoYast_xml                             ;  Template for an AutoYast.xml file
133   template::cloud_config                             ;  Template for a cloud config file
134   template::kickstart_cfg                            ;  Template for a kickstart file
135   template::minecraft_server_launcher                ;  Template for a minecraft server launcher
136   template::preseed_cfg::auto_disk_layout            ;  Template for a preseed file auto disk layout section
137   template::preseed_cfg::early_command               ;  Template for a preseed file early command section	
138   template::preseed_cfg::expert_recipe               ;  Template for a preseed file expert recipe section
139   template::preseed_cfg::late_command                ;  Template for a preseed file late command section
140   template::preseed_cfg::main                        ;  Template for a preseed file main section
141   template::rtd_me_sh_cmd                            ;  Template for a rtd_me.sh command
142   term::animate_while_command                        ;  Display terminal output during a silent task execution
143   term::start_animation                              ;  Start simple animation to let user know a silent action is currently executing
144   term::stop_animation                               ;  Stop simple animation to let user know a silent action is done executing
145   test_iso_boot_media                                ;  Test bootable media using QEMU
146   tool::compress_all_items_here                      ;  Compress all items in the current folder
147   tool::compress_provided_items                      ;  Compress provided items
148   tool::recompress_all_items_in_folder               ;  Recompress all items in a folder a desired format
149   tool::recompress_provided_items                    ;  Recompress provided items to another format
150   tool::up_2_date                                    ;  Older universal software update function
151   write_error                                        ;  Prints an error message to terminal in RED
152   write_host                                         ;  Prints a message to the terminal w. a choice of color
153   write_information                                  ;  Prints a message to the terminal in BLUE
154   write_status                                       ;  Prints a message to the terminal in GREEN
155   write_warning                                      ;  Prints a message to the terminal in YELLOW
156   yad::display_cmd_output                            ;  Display a command output in a progress box
157   yad::display_progressbar_pulsating                 ;  Display a pulsating progress bar
158   zenity::display_file                               ;  Display the contents of a file in a box
159   zenity::display_info                               ;  Displays any string passed in a GUI information box
160   zenity::display_url                                ;  Display the contents of a URL passed to the function in a box



Use Google Coding standards:
In general any function that is not both obvious and short must be commented. Any function in a library must be commented regardless of
length or complexity. It should be possible for someone else to learn how to use your program or to use a function in your library
by reading the comments (and self-help, if provided) without reading the code.

All function comments should describe the intended API behavior using:

1	Description of the function.
2	Globals: List of global variables used and modified.
3	Arguments: Arguments taken.
4	Outputs: Output to STDOUT or STDERR.
5	Returns: Returned values other than the default exit status of the last command run.

Advice: As a "best practice" working with this file, given the size and complexities, it is better to write a new function in an external script and
use the "source" statement to include this library in said script, so that all the other functions here are available to use in the new
function.

Library_Documentation








################################################################################################
#     |>>>                                                      |>>>
#     |                     |>>>          |>>>                  |
#     *                     |             |                     *
#    / \                    *             *                    / \
#   /___\                 _/ \           / \_                 /___\
#   [   ]                |/   \_________/   \|                [   ]
#   [ I ]                /     \       /     \                [ I ]
#   [   ]_ _ _          /       \     /       \          _ _ _[   ]
#   [   ] U U |        {#########}   {#########}        | U U [   ]
#   [   ]====/          \=======/     \=======/          \====[   ]
#   [   ]    |           |   I |_ _ _ _| I   |           |    [   ]
#   [___]    |_ _ _ _ _ _|     | U U U |     |_ _ _ _ _ _|    [___]
#   \===/  I | U U U U U |     |=======|     | U U U U U | I  \===/
#    \=/     |===========| I   | + W + |   I |===========|     \=/
#     |  I   |           |     |_______|     |           |   I  |
#     |      |           |     |||||||||     |           |      |
#     |      |           |   I ||vvvvv|| I   |           |      |
# _-_-|______|-----------|_____||     ||_____|-----------|______|-_-_
#    /________\         /______||     ||______\         /________\
#   |__________|-------|________\_____/________|-------|__________|
#
################################################################################################
#
# 888      d8b 888                                                 
# 888      Y8P 888                                                 
# 888          888                                                 
# 888      888 88888b.  888d888 8888b.  888d888 888  888           
# 888      888 888 "88b 888P"      "88b 888P"   888  888           
# 888      888 888  888 888    .d888888 888     888  888           
# 888      888 888 d88P 888    888  888 888     Y88b 888           
# 88888888 888 88888P"  888    "Y888888 888      "Y88888           
#                                                    888           
#                                               Y8b d88P           
#                                                "Y88P"            
#  .d8888b.           888    888    d8b                            
# d88P  Y88b          888    888    Y8P                            
# Y88b.               888    888                                   
#  "Y888b.    .d88b.  888888 888888 888 88888b.   .d88b.  .d8888b  
#     "Y88b. d8P  Y8b 888    888    888 888 "88b d88P"88b 88K      
#       "888 88888888 888    888    888 888  888 888  888 "Y8888b. 
# Y88b  d88P Y8b.     Y88b.  Y88b.  888 888  888 Y88b 888      X88 
#  "Y8888P"   "Y8888   "Y888  "Y888 888 888  888  "Y88888  88888P' 
#                                                     888          
#                                                Y8b d88P          
#                                                 "Y88P" 
################################################################################################


# Define the name of the library files required for this script
# For flexibility we use variables with default values that can be overridden by the script that 
# sources this library by simply setting them in the parent environment.
: ${_branding_info:="_branding.info"}
: ${_locations_info:="_locations.info"}
: ${_rtd_recipies_info:="_rtd_recipies.info"}

# Online source for scripts and configuration
_src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"

# load branding information:
_OEM_dependencies="_branding.info _locations.info _rtd_recipies.info"


# All library functions are listed below in a few sections:
# - Standard Interactions
# - System Management
# - Software Management
# - Security
# - Virtual Machine Management
# - Internal Configuration Repository
# - Script Internal Functions














################################################################################################
#
# 	. -------------------------------------------------------------------.
# 	| [Esc] [F1][F2][F3][F4][F5][F6][F7][F8][F9][F0][F10][F11][F12] o o o|
# 	|                                                                    |
# 	| [`][1][2][3][4][5][6][7][8][9][0][-][=][_<_] [I][H][U] [N][/][*][-]|
# 	| [|-][Q][W][E][R][T][Y][U][I][O][P][{][}] | | [D][E][D] [7][8][9]|+||
# 	| [CAP][A][S][D][F][G][H][J][K][L][;]['][#]|_|           [4][5][6]|_||
# 	| [^][\][Z][X][C][V][B][N][M][,][.][/] [__^__]    [^]    [1][2][3]| ||
# 	| [c]   [a][________________________][a]   [c] [<][V][>] [ 0  ][.]|_||
# 	`--------------------------------------------------------------------'
#
#
#  .d8888b.  888                           888                      888                          
# d88P  Y88b 888                           888                      888                          
# Y88b.      888                           888                      888                          
#  "Y888b.   888888  8888b.  88888b.   .d88888  8888b.  888d888 .d88888                          
#     "Y88b. 888        "88b 888 "88b d88" 888     "88b 888P"  d88" 888                          
#       "888 888    .d888888 888  888 888  888 .d888888 888    888  888                          
# Y88b  d88P Y88b.  888  888 888  888 Y88b 888 888  888 888    Y88b 888                          
#  "Y8888P"   "Y888 "Y888888 888  888  "Y88888 "Y888888 888     "Y88888                          
#                                                                                              
#                                                                                              
#                                                                                              
# 8888888          888                                     888    d8b                            
#   888            888                                     888    Y8P                            
#   888            888                                     888                                   
#   888   88888b.  888888 .d88b.  888d888 8888b.   .d8888b 888888 888  .d88b.  88888b.  .d8888b  
#   888   888 "88b 888   d8P  Y8b 888P"      "88b d88P"    888    888 d88""88b 888 "88b 88K      
#   888   888  888 888   88888888 888    .d888888 888      888    888 888  888 888  888 "Y8888b. 
#   888   888  888 Y88b. Y8b.     888    888  888 Y88b.    Y88b.  888 Y88..88P 888  888      X88 
# 8888888 888  888  "Y888 "Y8888  888    "Y888888  "Y8888P  "Y888 888  "Y88P"  888  888  88888P' 
#
################################################################################################





dialog::display_cmd_output () {
	# Description: Function to display a command output in a dialog box. 
	# 
	# Globals: dialog 
	# Arguments: ["String to execute"]
	# Outputs: Message in dialog box
	# Returns: 0 or ESC
	# Usage:
	#
	#
	# dialog::display_cmd_output apt -y upgrade
	#
	# End of Documentation
	_cmd="$*"


	${_cmd} | ${RTD_GUI:-dialog} --backtitle "\Zb$PUBLICATION             $VERSION\ZB"  --progressbox "RUNNING: ${_cmd}" 25 120


}





dialog::copy_file_progress() {
# Description: Function to display a file copy dialog. 
# This is a simple way to show a progress bar while copying a set of files from one destination
# in a nice way. To use this function simply call it passing source and destination.
# 
# Globals: dialog 
# Arguments: ["String to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# dialog::copy_file_progress source destination
#
# Example:
# dialog::copy_file_progress "/path/to/source" "/path/to/destination"
#
# This function takes two arguments: the source directory containing the files to be copied,
# and the destination directory where the files will be copied to. It creates a progress bar
# dialog using the 'dialog' command and updates it as each file is copied. The progress bar
# shows the percentage of files copied and the name of the current file being copied.
# The function returns 0 if the copying process completes successfully, or ESC if the user
# cancels the operation.
#
# Note: The 'dialog' command must be installed for this function to work.
#
# End of Documentation
# Source
	_dirs=(${1}/* )

	# Destination directory
	_dest="${2}"

	[ ! -d "${_dest}" ] && mkdir -p "${_dest}"

	dialog --title "Copying files" --gauge "Copying file..." 10 75 < <(
	# Get total number of files in array
	n=${#_dirs[*]}; 
	i=0

	for f in "${_dirs[@]}" ; do
		# calculate progress
		_pct=$(( 100*(++i)/n ))

		# update dialog box 
		cat <<EOF
XXX
${_pct}
Copying file "${f}"...
XXX
EOF
		# copy file $f to $_dest 
		/bin/cp "${f}" "${_dest}" &>/dev/null
	done
	)

	unset _dirs
	unset _dest
	unset _pct

}








dialog::copy_with_progress() {
	local iso_file="$1"
	local destination="$2"
	local mount_point="$3"

	# Get the size of the ISO file
	local iso_size=$(stat -c%s "$iso_file")

	# Create a named pipe for progress updates
	local pipe=$(mktemp -u)
	mkfifo "$pipe"

	# Start dialog progress bar
	dialog --title "Copying ISO" --gauge "Copying $iso_file to $mount_point/$rtd_ventoy_dir" 10 70 0 < "$pipe" &

	# Copy the file and update progress
	(pv -n "$iso_file" > "$destination" 2>&1 | while read -r progress; do
		echo $((progress * 100 / iso_size))
	done > "$pipe")

	# Clean up
	rm "$pipe"
}






dialog::display_notice () {
	# Description: Function to display an information notice. The purpose of this function
	# is simply to make it easy and convenient to display a message to an end user in a terminal
	# in a nice way. To use this function, simply call it passing whatever string you want displayed
	# using dialog.
	# Globals: "${RTD_GUI}" (will default to dialog), "${PUBLICATION}" (optional)
	# Arguments: ["String to display"]
	# Outputs: Message in dialog box
	# Returns: 0 or ESC
	# Usage:

	#
	# dialog::display_notice "The message that you want to display"
	#
	# End of Documentation

	system::log_item "checking for dialog..."
	if ! hash "${RTD_GUI:-dialog}" &>/dev/null ; then
		system::log_item "${RTD_GUI:-dialog} not found..."
		check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1
	else
		system::log_item "${RTD_GUI:-dialog} found..."
	fi
	system::log_item "Notice: ${*}"

	dialog --backtitle "${PUBLICATION:-"Notice"}" --colors --no-collapse --title "Notice" --msgbox "\n ${*} \n" 15 78
	clear
	return 0
}




dialog::display_error()
{
	# Description: Function to display an error notice. The purpose of this function
	# is simply to make it easy and convenient to display an ERROR message to an end user in a terminal
	# in a nice way. To use this function, simply call it passing whatever string you want displayed
	# using dialog.
	# Globals: "${RTD_GUI}" (will default to dialog), "${PUBLICATION}" (optional)
	# Arguments: ["String to display"]
	# Outputs: Message in dialog box
	# Returns: 0 or ESC
	# Usage:
	#
	# dialog::display_error "The message that you want to display"
	#
	# End of Documentation

	system::log_item "checking for dialog..."
	if ! hash "${RTD_GUI:-dialog}" &>/dev/null ; then
		system::log_item "${RTD_GUI:-dialog} not found..."
		check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1
	else
		system::log_item "${RTD_GUI:-dialog} found..."
	fi
	system::log_item "Notice: ${*}"

	dialog --backtitle "${PUBLICATION:-"ERROR"}" --colors --no-collapse --title "ERROR" --msgbox "\n ${*} \n" 15 78
	clear
	return 0
}





dialog::display_summary_message() {
	# Description: Function to read a variable "result" and display its contents. The purpose of this function
	# is simply to make it easy and convenient to display a message to an end user in a terminal
	# in a nice way. To use this function, simply call it after populating the variable result.
	# 
	# Globals: ${result}, ${BRANDING}
	# 
	# Arguments: ["Title to display"]
	# 
	# Outputs: Message in dialog box
	# 
	# Returns: 0 or ESC
	# 
	# Usage:
	# 
	# result=$( command with output)
	# dialog::display_result "title of the message"
	# 
	# End of Documentation

	if ! hash dialog &>/dev/null ; then	
		system::log_item "dialog not found..."
		check_dependencies dialog &>/dev/null || return 1
	else
		system::log_item "dialog found..."
	fi

	system::log_item "Displaying summary message TITLE: $1 and the message: ${_summary_message}"
	if echo "${FUNCNAME[1]}" | grep "make_kvm_virtual_machine" ; then 
		dialog --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "\n ${_summary_message} \n" 0 0
	else 
		dialog --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "${_summary_message}" "${HEIGHT:-"20"}" "${WIDTH:-"80"}"
	fi
	clear

	return 0
}




dialog::display_result() {
	# Description: Function to read a variable "result" and display its contents. The purpose of this function
	# is simply to make it easy and convenient to display a message to an end user in a terminal
	# in a nice way. To use this function, simply call it after populating the variable result.
	# Globals: ${result}, ${BRANDING}
	# Arguments: ["Title to display"]
	# Outputs: Message in dialog box
	# Returns: 0 or ESC
	# Usage:
	#
	# result=$( command with output)
	# dialog::display_result "title of the message"
	#
	# End of Documentation
	system::log_item "checking for dialog..."
	if ! hash "${RTD_GUI:-dialog}" &>/dev/null ; then
		system::log_item "${RTD_GUI:-dialog} not found..."
		check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1
	else
		system::log_item "${RTD_GUI:-dialog} found..."
	fi

	system::log_item "Displaying result: $1 "
	${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "$result" "${HEIGHT:-"20"}" "${WIDTH:-"80"}"
	clear
}






yad::display_cmd_output() {
	# Description: Function to display a command output in a yad box. 
	# 
	# Globals: yad 
	# Arguments: ["String to execute"]
	# Outputs: Message in dialog box
	# Returns: 0 or ESC
	# Usage:
	#
	# This function takes a command as an argument and executes it. The output of the command is displayed in a yad yad box.
	# Any error messages are also displayed in the yad box.
	# The function returns 0 if the command execution is successful or if the yad box is closed with the "Close" button.
	# If the yad box is closed with the "ESC" key, the function returns "ESC".
	#
	# Example usage:
	# yad::display_cmd_output "apt -y upgrade"
	#
	# End of Documentation
	# Command to execute
	local cmd=$@

	system::log_item "checking for diayadog..."
	if ! hash "yad" &>/dev/null ; then
		system::log_item "yad not found..."
		check_dependencies "yad" &>/dev/null || return 1
	else
		system::log_item "yad found..."
	fi

	# Execute the command and pipe its output to yad
	( 
		# Ensure any error messages are sent to standard output so yad can display them
		exec 2>&1 
		
		# Execute the command
		echo "Executing: $cmd"
		$cmd
		
		echo "Command completed. You can close this window."
	) | yad --text-info --width=700 --height=400 --title "Command Output"
}




yad::display_progressbar_pulsating() {
	# Description: Function to display a command output in a progress box. 
	# 
	# Globals: yad 
	# Arguments: ["String to execute"]
	# Outputs: Message in yad box
	# Returns: 0 or ESC
	# Usage:
	#
	# This function takes a command as an argument and executes it. The command output is displayed in a progress box using the 'yad' command.
	# The progress box shows a pulsating animate system::prepare_environment_for_iso_creationion and automatically closes when the command execution is complete.
	#
	# Example usage:
	# yad::display_cmd_output "apt -y upgrade"
	#
	# End of Documentation
	_cmd="$*"

	system::log_item "checking for yad..."
	if ! hash "yad" &>/dev/null ; then
		system::log_item "yad not found..."
		check_dependencies "yad" &>/dev/null || return 1
	else
		system::log_item "yad found..."
	fi

	${_cmd} | yad --title="$PUBLICATION $VERSION" --progress --pulsate --auto-close --auto-kill --text="RUNNING: ${_cmd}" --width=300 --height=100

}





zenity::display_info() {
	# Description: Function to display an information notice.
	# The purpose of this function is to make it easy and convenient to display a message to an end user in a GUI in a nice way.
	# To use this function, simply call it passing whatever string you want displayed.
	#
	# Globals: "$_TITLE" (optional), "$selection" (optional)
	# Arguments: ["String to display"]
	# Outputs: Message in zenity info box
	# Returns: None
	# Usage: zenity::display_info "The message that you want to display"
	#
	# End of Documentation

	_text="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --info --text --title="${_TITLE:="Notice"}: $selection" --text="$_text" --ellipsize --height=600 --width=800 2>/dev/null
}






zenity::display_url() {
# Description: to display the content of a URL in a GUI using zenity.
# This function makes it easy and convenient to display web content to an end user in a nice way.
# To use this function, simply call it passing the URL as an argument.
#
# Globals: $_TITLE (optional)
# Arguments: ["URL"]
# Outputs: Formatted HTML message in a zenity window
# Returns: None
# Usage:
#
# zenity::display_url "https://www.someplace.com/index.html"
#
# End of Documentation

	_url="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --text-info --html --title="${_TITLE:="$_url"}:" --url="$_url" --width=800 --height=600 &>/dev/null
}




zenity::display_file() {
# Description: Function to display the content of a text file. The purpose of this function
# is simply to make it easy and convenient to display text content to an end user in a GUI
# in a nice way. To use this function simply call it passing whatever file path you need.
#
# Globals: $_TITLE (optional)
# Arguments: ["/path/to/file.txt"]
# Outputs: Message in zenity window
# Returns:
# Usage:
#
#   zenity::display_file  "/path/to/file.txt"
#
# End of Documentation

	_filename="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --text-info --title="${_TITLE:="$_filename"}:" --filename="$_filename" --width=800 --height=600 &>/dev/null

}



term::animate_while_command() {
# Description:
# A simple function to display and animation during a silent acton.
# This is useful for uning anoter functiona that may take some time. 
# Note that this works best if the function doe not print to terminal.
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::animate_while_command ; EXPRESSION of COMMAND or FUNCTION 
# 
#
# End of documentation

	
        if [[ -z ${1} ]] ; then
		write_error "Specifying a command to wait for is required! "
		return 1
	else
		term::start_animation "${@}" ; "${@}" &>/dev/null; term::stop_animation 
	fi

}




################################################################################################
#              ________________________________________________
#             /                                                \
#            |    _________________________________________     |
#            |   |                                         |    |
#            |   |  user@host:\> _                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |_________________________________________|    |
#            |                                                  |
#             \_________________________________________________/
#                    \___________________________________/
#                 ___________________________________________
#              _-'    .-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.  --- `-_
#           _-'.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--.  .-.-.`-_
#        _-'.-.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-`__`. .-.-.-.`-_
#     _-'.-.-.-.-. .-----.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-----. .-.-.-.-.`-_
#  _-'.-.-.-.-.-. .---.-. .-------------------------. .-.---. .---.-.-.-.`-_
# :-------------------------------------------------------------------------:
# `---._.-------------------------------------------------------------._.---'
# ----------------------------------------------------------------
################################################################################################
#
#  .d8888b.                    888                                                                  
# d88P  Y88b                   888                                                                  
# Y88b.                        888                                                                  
#  "Y888b.   888  888 .d8888b  888888 .d88b.  88888b.d88b.                                          
#     "Y88b. 888  888 88K      888   d8P  Y8b 888 "888 "88b                                         
#       "888 888  888 "Y8888b. 888   88888888 888  888  888                                         
# Y88b  d88P Y88b 888      X88 Y88b. Y8b.     888  888  888                                         
#  "Y8888P"   "Y88888  88888P'  "Y888 "Y8888  888  888  888                                         
#                 888                                                                               
#            Y8b d88P                                                                               
#             "Y88P"                                                                                
# 888b     d888                                                                              888    
# 8888b   d8888                                                                              888    
# 88888b.d88888                                                                              888    
# 888Y88888P888  8888b.  88888b.   8888b.   .d88b.   .d88b.  88888b.d88b.   .d88b.  88888b.  888888 
# 888 Y888P 888     "88b 888 "88b     "88b d88P"88b d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888    
# 888  Y8P  888 .d888888 888  888 .d888888 888  888 88888888 888  888  888 88888888 888  888 888    
# 888   "   888 888  888 888  888 888  888 Y88b 888 Y8b.     888  888  888 Y8b.     888  888 Y88b.  
# 888       888 "Y888888 888  888 "Y888888  "Y88888  "Y8888  888  888  888  "Y8888  888  888  "Y888 
#                                               888                                                 
#                                          Y8b d88P                                                 
#                                           "Y88P"              
################################################################################################







system::preseed_to_ubuntu_ks_cfg ()
{
# Description: generates a preseed section [Ubuntu only] (ks.cfg)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: instruction for Ubuntu's convoluted support for both preseed and kickstart files.
# Usage: rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "directory"
# End of documentation
	system::log_item "Saving preeseed file as $1/ks.cfg for legacy Ubuntu installs..."
	cat $1/preseed.cfg >$1/ks.cfg
}


system::make_preseed_cfg()
{
# Description: Function to write out a debina preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Globals:
# Arguments: [-p <path> ] [-r server|desktop|minecraft ] [-t gnome-desktop|kde-desktop|xfce-desktop|mate-desktop|cinnamon-desktop ]
# Outputs: /path/to/preseed.cfg
# Returns:
# Usage: system::make_preseed_cfg -r "${_role}" -p "$( mktemp -d)" -t ${_task}
# Example:
# 
# system::make_preseed_cfg -r "${_role}" -p "$( mktemp -d)" -t ${_task}
#
# To install a basic server: 
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t ssh-server
#
# To install a basic ansible server:
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t ansible-server
#
# To autoinstall a basic minecraft server:
# system::make_preseed_cfg -r "minecraft-server" -p "$( mktemp -d)" -t ssh-server
# 
# To autoinstall a basic desktop with gnome:
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t gnome-desktop
# 
# End of documentation

	system::log_item "Called by: ${FUNCNAME[1]}"


	# Read requested configuration options
	kvm::util::read_common_options "$@"
	kvm::util::read_distro_options "$@"

	system::log_item "Distribution: Role: ${_role} | Desktop: ${_UserDesktopEnvironmentSelection:-"Not selected"} | Server: ${_UserServerEnvironemtSelection:-"Not selected"} | Ask: ${_ask} | Save to: ${_saveto}"
	system::log_item "Transferring standard selections _role to the preseed file multiselect option..."
	case "${_role}" in
		workstation | desktop )
			_task="${_UserDesktopEnvironmentSelection:="gnome-desktop"}"
			system::log_item "Setting multiselect _task to: ${_task} because the primary purpose is to be a VDI or Desktop"
		;;
		server )
			_task="${_UserServerEnvironemtSelection:="ssh-server"}"
			system::log_item "Setting multiselect _task to: ${_task} because the primary purpose is to be a server"
		;;
		* )
			write_error "Unable to set _task for PREESEED file: (${_task})"
			return 1
		;;
	esac

	export PRESEED_FILE="${_saveto}/preseed.cfg"	# The name of the preseed file to be created
	export TASK_FILE="${_saveto}/task.sh"		# The name of the task file to be created (if needed)

	touch "${PRESEED_FILE}" 2>&1 | tee -a "${_LOGFILE}"
	touch "${TASK_FILE}"    2>&1 | tee -a "${_LOGFILE}"

        # system::get_vm_config will load the preferences from the config file if it exists
        # otherwise it will use the defaults set in the function.
        # it will return predefined variables that can be used in the preseed file.
	if [[ "$_ask" == "YES" || "$_ask" == "Yes" || "$_ask" == "yes" ]]; then
		system::log_item "Prompting for configuration options..."
		if system::get_vm_config --ask || dialog::yesno "Cancelled or something went wrong... continue with defaults?"; then
			exit_status=$?
			
			case $exit_status in
			0 )
				system::log_item "Save choices and continue..."
			;;
			1 )
				system::log_item "[Cancel] pressed; not updating or changing any configuration items..."
			;;
			255 )
				system::log_item "[ESC] pressed, exiting the dialog immediately..."; return 1
			;;
			* )
				system::log_item "[ERROR] Dialog closed or unexpected error."; rtd_oem_pause 1 "Dialog closed or unexpected error."
			;;
			esac
		fi
	else
		system::log_item "Using default configuration options..."
		if ! system::get_vm_config; then
			system::log_item "Failed to get configuration options from saved preferences..."
		fi
	fi


	# If the user has requested to copy their SSH key to the host, then do so:
	if [[ "${Preference_CopySSHKey}" == "yes" || "${Preference_CopySSHKey}" == "YES" ]] ; then
		Preference_ssh_pub_key="$(cat /home/$SUDO_USER/.ssh/*.pub | head -1)"
	fi

	system::log_item "Adding late commands to the preseed file..."
	if echo "${FUNCNAME[1]}" | grep -i ubuntu ; then
		system::log_item "Ubuntu requested, using ubiquity/success_command"
		_d_i_post_statment_ubunto_or_deb="ubiquity ubiquity/success_command string" 
	else
		system::log_item "Debian requested, using d-i preseed/late_command"
		_d_i_post_statment_ubunto_or_deb="d-i preseed/late_command string" 
	fi

	touch "${PRESEED_FILE}"
	template::preseed_cfg::early_command ${PRESEED_FILE}
	template::preseed_cfg::main ${PRESEED_FILE}
	template::preseed_cfg::auto_disk_layout ${PRESEED_FILE}
	template::preseed_cfg::late_command ${PRESEED_FILE}

	system::preseed_to_ubuntu_ks_cfg "${_saveto}"
	system::log_item "Preseed file created: ${PRESEED_FILE}"

	if [[ "$_LOGLEVEL" == "debug" ]]; then 
		system::log_item "Containging DATA:
		$(cat ${PRESEED_FILE})"
	fi
}








system::generate_cloudconfig() {
	# Description:
	# Function to generate a cloud config file for use in deploying servers
	#
	# Globals:
	# Arguments: 
	# Outputs: 
	# Returns:
	# Usage: gen_cloudconfig 
	#
	#
	# With the introduction of the DigitalOcean metadata service, it is possible to start configuring your 
	# servers before you even log in. In short, the metadata service is an HTTP location that your server 
	# can access during the boot process.
	#
	# The metadata location will contain basic data about the server’s configuration and environment, 
	# such as network addresses, hostname, etc. During the initial setup, these values can be pulled 
	# down by a program called cloud-init to help configure essential services.
	#
	# The most powerful feature is that you can pass a script to the metadata service when you create a 
	# server using a field called user-data. This will be run during the initial boot process and is very 
	# flexible, allowing you to accomplish whatever you can script.
	#
	# The most common type of script to pass in is called a cloud-config script. This is a 
	# YAML formatted file that provides simple, readable methods of setting up common configuration 
	# items by declaration. It also has the ability to run arbitrary commands for other tasks.
	#
	# In this guide, we will get familiar with the DigitalOcean metadata service and cloud-config 
	# files by trying out a simple example. We will be recreating some of the steps outlined 
	# in the initial server setup for Ubuntu 14.04 guide in order to demonstrate.
	#
	# End of Documentation

	# get default VM configurations options from the system::get_vm_config
	system::get_vm_config

	# Directory for cloud config files, if not set, create a temporary directory and use that.
	local CloudConfigDir="${CloudConfigDir:=$( mktemp -d /tmp/CloudConfig.XXXXXX )}"
	local _git_src_url="${GIT_RTD_SRC_URL:="https://github.com/${GIT_Profile:=vonschutter}/${_TLA^^}-Setup.git"}"

	touch ${CloudConfigDir}/meta-data
	touch ${CloudConfigDir}/user-data

	# Parse the command line options overwriting the defaults or saved preferences
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--CloudConfigDir | cloudconfigdir )
			# where to save cloud config files to incerted into the VM
			local CloudConfigDir="$2"
			shift # Remove argument name from processing
			;;
		--flavor | --Flavor | --FLAVOR | --flavour | --Flavour | --FLAVOUR )
			# The role of the VM, e.g. ubuntu-desktop, ubuntu-server, kubuntu-desktop, etc.
			local Preference_Role="$2"
			case ${Preference_Role} in 
			ubuntu-desktop | ubuntu-server | kubuntu-desktop | ssh-server | ansible-server | minecraft-server | ubuntu-server-minimal )
				system::log_item "Requested Role: ${Preference_Role}"
				;;
			* )
				system::log_item "ERROR: Unknown ubuntu flavor: ${Preference_Role}"
				dialog::display_error "ERROR: Unknown role: ${Preference_Role}\n
				Usage: $(FUNCNAME[0]) [--CloudConfigDir <directory>] [--vmname <hostname> ] [--flavor <ubuntu-flavor>]\n
				Where <role> is the type of VM to create, e.g. :
				ubuntu-desktop, 
				ubuntu-server, 
				kubuntu-desktop, 
				ssh-server,
				ansible-server,
				minecraft-server
				
				GOT (${Preference_Role})"
				return 1
				;;
			esac
			shift # Remove argument name from processing
			;;
		--vmname | --VMName | --vm_name | --VmName )
			# The hostname of the VM to be created
			local vm_name="$2"
			[[ "$vm_name" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,253}[a-zA-Z0-9])?$ ]] && [[ ${#vm_name} -le 255 ]] && system::log_item "$vm_name: Valid hostname" || system::log_item "$vm_name: Invalid hostname"
			shift # Remove argument name from processing
			;;
		*)
			system::log_item "INFO: No known long parameters provided. Parameter: $1"
			;;
		esac
		shift # Remove argument value from processing
	done


	# If the user has requested to copy their SSH key to the host, capture it and store in a 
	# var for use in the config file:
	if [[ "${Preference_CopySSHKey}" == "yes" || "${Preference_CopySSHKey}" == "YES" ]] ; then
		local Preference_ssh_pub_key="$(cat /home/$SUDO_USER/.ssh/*.pub | head -1)"
	fi

	# Write out the user-data file
	system::log_item "Writing out the user-data file..."
	template::cloud_config --write "${CloudConfigDir}/user-data" || { system::log_item "Failed to write out the user-data file." ; return 1; }

	# Log configuration data for troupleshooting puropses
	system::log_item "Configuration data supplied:
	$(cat ${CloudConfigDir}/user-data)"

	write_information "Generating Ubuntu autoinstall instruction media: ${CloudConfigDir}/CIDATA.iso"
	software::check_native_package_dependency genisoimage

	# Generate the CIDATA.iso file
	write_information "Generating: ${CloudConfigDir}/CIDATA.iso"
	if genisoimage -output ${CloudConfigDir}/CIDATA.iso -volid cidata -joliet -rock -full-iso9660-filenames ${CloudConfigDir}/*  &>>${_LOGFILE} ; then
		{ system::log_item "Generated: ${CloudConfigDir}/CIDATA.iso" success ; }
	else
		{ system::log_item "Failed to generate: ${CloudConfigDir}/CIDATA.iso" ; return 200; }
	fi

	# Secure the cloud config directory
	write_information "Securing the cloud config directory..."
	if chown $(stat -c "%U:%G" /var/lib/libvirt/qemu/) "${CloudConfigDir}" ; then
		if chmod $(stat -c "%a" /var/lib/libvirt/qemu/) "${CloudConfigDir}" ; then
			write_information "Changed ownership and permissions of ${CloudConfigDir} successfully"
		else
			write_information "Failed to change permissions of ${CloudConfigDir} to $(stat -c "%a" /var/lib/libvirt/qemu/) "
		fi
	else
		write_error "Failed to change ownership of ${CloudConfigDir} to $(stat -c "%U:%G" /var/lib/libvirt/qemu/)"
	fi
	return 0
}



system::generate_ks_cfg_file() {
	# Description: Function to generate an installation configuration file for Fedora/Red Hat.
	# Globals: 
	# Arguments: [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]
	# Outputs: One kick start configuration file.
	# Returns: 0/1
	# Usage: system::generate_ks_cfg_file [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]
	# End of documentation

	system::log_item "Called by: ${FUNCNAME[1]}"
	# Get vm config standard options
	system::get_vm_config

	while [[ $# -gt 0 ]]; do
		case "$1" in
		--filename | --file )
			local _ks_file="$2"
			write_host --cyan  "📜 Directed to create kickstart instructions file: ${_ks_file}"
			shift
		;;
		--desktop_environment | --DE )
			if [[ $2 == "@deepin-desktop-environment" || $2 == "@sway-desktop-environment" || $2 == "@basic-desktop-environment" || $2 == "@(i3-desktop-environment" || $2 == "@developer-workstation-environment" || $2 == "@budgie-desktop-environment" || $2 == "@sugar-desktop-environment" || $2 == "@mate-desktop-environment" || $2 == "@kde-desktop-environment" || $2 == "@xfce-desktop-environment" || $2 == "@lxde-desktop-environment" || $2 == "@lxqt-desktop-environment" || $2 == "@cinnamon-desktop-environment" || $2 == "@mate-desktop-environment" || $2 == "@workstation-product-environment" ]] ; then
				local _UserDesktopEnvironmentSelection="${2}"
				write_host --cyan  "🖥️ Selecting desktop environment: ${_UserDesktopEnvironmentSelection}"
			else
				write_error "⛔ Unknown Desktop Environment: $2 ==> Use deepin-desktop-environment, sway-desktop-environment, basic-desktop-environment, i3-desktop-environment, developer-workstation-environment, budgie-desktop-environment, sugar-desktop-environment, mate-desktop-environment, kde-desktop-environment, xfce-desktop-environment, lxde-desktop-environment, lxqt-desktop-environment, cinnamon-desktop-environment, mate-desktop-environment, workstation-product-environment"
				return 1
			fi
			shift
		;;
		--server_role | --ServerRole | --SR )
			if [[ $2 == "@minimal-environment" || $2 == "@web-server-environment" || $2 == "@freeipa-server" || $2 == "@network-server" || $2 == "@cloud-server-environment" || $2 == "@infrastructure-server-environment" ]] ; then
				local _UserServerEnvironemtSelection="${2}"
				write_status "🎭 Selecting server role: ${2}"
			else
				write_error "⛔ Unknown server role selection: ${2} ==> Use web-server-environment, freeipa-server, network-server, cloud-server-environment, infrastructure-server-environment"
				return 1
			fi
			shift
		;;
		--role | --Role )
			if [[ $2 == "workstation" || $2 == "server" ]] ; then
				local _role="${2}"
				write_status "🎭 Selecting role: ${2}"
			else
				write_error "⛔ Unknown role selection: ${2} ==> Use workstation or server"
				return 1
			fi
			shift
		;;
		--source | --URL | --url )
			local _repo_url="${2}"
			write_status "🌐 Using URL: ${_repo_url}"
			shift
		;;
		--timezone | --TZ )
			local Preference_InitialTimeZone="${2}"
			write_status "🕰️ Using Timezone: ${Preference_InitialTimeZone}"
			shift
		;;
		--disk_encryption | --DC )
			Preference_DiskEncryption="$2"
			write_status "🔐 Disk encryption is requested and enabled."
			shift
		;;
		--disk_password | --DP )
			Preference_Disk_Password="$2"
			write_status "🔐 Disk encryption password is set."
			shift
		;;
		--initial_user | --IU )
			Preference_InitialUser="$2"
			write_status "👤 Initial user is set to: ${Preference_InitialUser}"
			shift
		;;
		--initial_user_password | --IUP )
			Preference_InitialUserPassword="$2"
			write_status "🔐 Initial user password is set."
			shift
		;;
		--help | -h )
			write_information "Usage: system::generate_ks_cfg_file [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]"
			return 0
		;;
		*)
			write_error "Unknown parameter: $1"
		;;
		esac
		shift 
	done

	if [[ ${Preference_DiskEncryption} == "YES" || ${Preference_DiskEncryption} == "yes" || ${Preference_DiskEncryption} == "Yes" ]]; then
		# set disk encryption password string, if password not set and Preference_DiskEncryption not set use default
		system::log_item "🔐 Disk encryption is requested and enabled."
		Preference_DiskEncryption_RH="--encrypted --passphrase ${Preference_Disk_Password:-"letmein1234"}"
	else
		system::log_item "🔐 Disk encryption is not requested and not enabled."
	fi

	[[ -v _repo_url && -v _role && -v _ks_file   ]] || ( echo missing mandatory parameters! ; return 1 )

	# Generate the kickstart file
	template::kickstart_cfg ${_ks_file}
}



system::generate_autoyast_file() {
# Description:
# This function dynamically generates an AutoYaST XML file for automated SUSE Linux installations.
# It allows customization of the installation process, including desktop environment, server role, 
# disk encryption, initial user setup, and more based on provided arguments.
#
# Globals:
#   None explicitly declared within the function, but it expects certain environment variables
#   to be set (e.g., _autoyast_filename, _UserDesktopEnvironmentSelection, etc.) based on the arguments passed.
#
# Arguments:
#   --filename <file path>                : Specifies the path and filename where the AutoYaST XML file will be saved.
#   --desktop_environment <DE name>       : Selects the desktop environment to install (kde, gnome, xfce, lxde, mate, cinnamon, enlightenment, lxqt).
#   --server_role <role name>             : Specifies the server role (lamp, dns, dhcp_dns_server, file_server, print_server, mail_server, monitoring, desktop).
#   --disk_encryption <YES|NO>            : Enables or disables disk encryption.
#   --disk_password <password>            : Sets the disk encryption password (ignored if disk encryption is NO).
#   --initial_user <username>             : Sets the username for the initial user account.
#   --initial_user_password <password>    : Sets the password for the initial user account.
#   --help | -h                           : Displays usage information for the function.
#
# Outputs:
#   The function generates an AutoYaST XML file at the specified location. It also outputs status messages,
#   error messages, and usage information to the console based on the operations performed and arguments provided.
#
# Returns:
#   0 : Successfully generated the AutoYaST XML file.
#   1 : Encountered an error due to incorrect or missing arguments.
#
# Usage:
#   To generate an AutoYaST file with specific configurations, call the function with the desired options. For example:
#   system::generate_autoyast_file --filename "/path/to/autoyast.xml" --desktop_environment "kde" --server_role "lamp" \
#   --disk_encryption "YES" --disk_password "securepassword" --initial_user "admin" --initial_user_password "adminpassword"
#
#   Providing the --help or -h argument displays usage information:
#   system::generate_autoyast_file --help
#
# Supported Desktop Environments:
#   | basic_desktop        | A very basic desktop (previously part of x11 pattern) | pattern
#   | budgie               | Budgie Desktop Environment                            | pattern
#   | budgie_applets       | Applets for Budgie Desktop Environment                | pattern
#   | cinnamon             | Cinnamon Desktop Environment                          | pattern
#   | deepin               | Deepin Desktop Environment                            | pattern
#   | gnome                | GNOME Desktop Environment (Wayland)                   | pattern
#   | gnome_basic          | GNOME Desktop Environment (Basic)                     | pattern
#   | gnome_x11            | GNOME Desktop Environment (X11)                       | pattern
#   | kde                  | KDE Applications and Plasma 5 Desktop                 | pattern
#   | kde_plasma           | KDE Plasma 5 Desktop Base                             | pattern
#   | lxde                 | LXDE Desktop Environment                              | pattern
#   | lxqt                 | LXQt Desktop Environment                              | pattern
#   | mate                 | MATE Desktop Environment                              | pattern
#   | xfce                 | XFCE Desktop Environment                              | pattern
#   | yast2_desktop        | YaST Desktop Utilities                                | pattern
#
# Supported Server Roles:
#   | dhcp_dns_server      | DHCP and DNS Server                                   | pattern
#   | directory_server     | Directory Server (LDAP)                               | pattern
#   | file_server          | File Server                                           | pattern
#   | gateway_server       | Internet Gateway                                      | pattern
#   | kvm_server           | KVM Host Server                                       | pattern
#   | lamp_server          | Web and LAMP Server                                   | pattern
#   | mail_server          | Mail and News Server                                  | pattern
#   | oracle_server        | Oracle Server Base                                    | pattern
#   | print_server         | Print Server                                          | pattern
#   | sap-bone             | SAP BusinessOne Server Base                           | pattern
#   | sap-hana             | SAP HANA Server Base                                  | pattern
#   | sap-nw               | SAP NetWeaver Server Base                             | pattern
#   | sap_server           | SAP Application Server Base                           | pattern
#   | xen_server           | Xen Virtual Machine Host Server                       | pattern
#   | yast2_server         | YaST Server Utilities                                 | pattern
#
# End of documentation

	# Get vm config standard options
	system::log_item "Called by: ${FUNCNAME[1]} with options $*"
	system::get_vm_config || system::log_item "Failed to get configuration options from saved preferences..."
	
	# Read input and set specific options for SUSE... (roles, desktops, etc.)
	kvm::util::read_distro_options --distribution suse ${*} 

	# Localized variables based on User preferences, but with suse speciffic defaults:
	# We cannot have empty tags in XML or validation will fail: so echo stored values with relevant tags.
	if [[ ${Preference_DiskEncryption} == "YES" || ${Preference_DiskEncryption} == "yes" || ${Preference_DiskEncryption} == "Yes" ]]; then
		Preference_DiskEncryption_SUSE="<encryption_password>${Preference_Disk_Password}</encryption_password>"
	else
		#Preference_DiskEncryption_SUSE="<encryption_password></encryption_password>"
		system::log_item "Disk encryption is not enabled."
	fi

	# Ensure that a filename is provided for the AutoYaST XML file, otherwise create a temporary file
	# and store the path in the _autoyast_filename variable. This can be read by other functions if needed.
	if [[ -z ${_autoyast_filename} ]] ; then
		_autoyast_filename="$(mktemp /tmp/autoyast.XXXXXX)"
	fi

	write_host --cyan "Creating AUTOYAST Instructions (XML): ${_autoyast_filename}"

	# Populate AutoYaST Template and write the autoyast file
	template::AutoYast_xml ${_autoyast_filename}
	system::log_item "AutoYaST file created: ${_autoyast_filename}
	With the contents:
	
	$(cat ${_autoyast_filename})
	"
	return 0
}



system::get_vm_config() {
	# Description: This function gets a value from a configuration file.
	# Parameters:
	#   - config_file: The path to the configuration file.
	#   - key: The key to get the value for.
	# Returns: The value for the key.
	#
	# Example:
	#	system::get_vm_config
	#	system::get_vm_config --ask
	#
	#
	# End of documentation
	local _config_file=${_OEM_USER_VM_PREFERENCES:-"/home/${SUDO_USER}/.config/${_TLA,,}/build_defaults.inf"}
	if [[ "$1" == "--ask" ]] ; then 
		local _ask="YES"
	else 
		local _ask="NO"
	fi

	system::log_item "Loading Global Config if available otherwise use defaults..."
	Preference_DiskEncryption="${_ENCRYPT_DISK:-"YES"}"
	Preference_Disk_Password="${_TEMP_DISK_PASSWORD:-"letmein1234"}"
	Preference_InitialUser="${_OEM_USER:-"tangarora"}"
	Preference_InitialUserFullName="${_OEM_USER_FULLNAME:-"RTD User"}"
	Preference_InitialUserGroup="${_OEM_USER_GROUP:-"sudo"}"
	Preference_InitialUserPassword="${_OEM_USER_PASSWORD:-"letmein1234"}"
	Preference_InitialKeyboardLayout="${_OEM_USER_KEYBOARD_LAYOUT:-"us"}"
	Preference_InitialLanguage="${_OEM_USER_LANGUAGE:-"en_US"}"
	Preference_InitialLanguageEncoding="${_OEM_USER_LANGUAGE:-"UTF8"}"
	Preference_InitialTimeZone="${_OEM_USER_TIMEZONE:-"Etc/UTC"}"
	Preference_Wireless_ID="${_OEM_WIRELESS_ID:-"loader"}"
	Preference_Wireless_Password="${_OEM_WIRELESS_PASSWORD:-"letmein1234"}"
	Preference_Role="${_role:-"default"}"
	Preference_CopySSHKey="${_OEM_COPY_SSH_KEY:-"NO"}"

	system::log_item "Load saved preferences from the config file everriding the _branding global config or defaults for preseed file..."
	[[ -f "${_config_file}" ]] && system::read_config "${_config_file}" || system::log_item "Failed to load config file: ${_config_file}"
        
        # If OS Role is set (by function for auto install), then override the config file with the role:
        [[ -n $_role ]] && Preference_Role="${_role}" 

        # If the user has requested to be asked for the preseed file, then ask them:
	if [[ "$_ask" == "YES" ]] ; then

		system::log_item "'ask' is requested, requesting user input for the preseed file:"
		preseed_choices=$(dialog --backtitle "$BRANDING" --title "RTD Preseed Creator" --mixedform "Enter your preferences in to the form below. Please note that the password fields do not show anything but will capture what you type in" 22 80 0 \
		"DiskEncryption (YES/NO):" 	        1 1 "${Preference_DiskEncryption}" 1 40 40 0 0 \
		"Disk Unlock Password (temp):"          2 1 "${Preference_Disk_Password}" 2 40 40 0 0 \
		"Admin User Name:"                      3 1 "${Preference_InitialUser}" 3 40 40 0 0 \
		"Admin User Full Name:"                 4 1 "${Preference_InitialUserFullName}" 4 40 40 0 0 \
		"Admin User Initial UserGroup:"         5 1 "${Preference_InitialUserGroup}" 5 40 40 0 0 \
		"Admin User Password (8 30 char):"      6 1 "${Preference_InitialUserPassword}" 6 40 128 0 0 \
		"Preferred Keyboard Layout:"            7 1 "${Preference_InitialKeyboardLayout}" 7 40 40 0 0 \
		"Preferred Language"                    8 1 "${Preference_InitialLanguage}" 8 40 40 0 0 \
		"Preferred Encoding"                    9 1 "${Preference_InitialLanguageEncoding}" 9 40 40 0 0 \
		"Initial Time Zone:"                   10 1 "${Preference_InitialTimeZone}" 10 40 40 0 0 \
		"Wireless Network SSID:"               11 1 "${Preference_Wireless_ID}" 11 40 40 0 0 \
		"Wireless Network Password:"           12 1 "${Preference_Wireless_Password}" 12 40 40 0 0 \
		"Role (Default, KVM, Minecraft):"      13 1 "${Preference_Role}" 13 40 40 0 0 \
		"Copy you ssh public key to host?"     14 1 "${Preference_CopySSHKey}" 14 40 40 0 0 \
		3>&1 1>&2 2>&3)
		exit_status=$?

		clear

		case $exit_status in
			0 )   
				system::log_item "Save coices and continue..." 
			;;
			1 )   
				system::log_item "[Cancel] pressed; not updating or changing any configuration items..."
				return 1 
			;;
			255 ) 
				system::log_item "[ESC] pressed, exiting the dialog immediatley..." 
				return 1 
			;;
			* )   
				system::log_item "[ERROR] Dialog closed or unexpected error." 
				rtd_oem_pause 1 "Dialog closed or unexpected error." 
			;;
		esac
		
		# Convert the dialog output to an array and asign the variables:
		IFS=$'\n' read -r -d '' -a input_array <<< "$preseed_choices"
		Preference_DiskEncryption=${input_array[0]}
		Preference_Disk_Password=${input_array[1]}
		Preference_InitialUser=${input_array[2]}
		Preference_InitialUserFullName=${input_array[3]}
		Preference_InitialUserGroup=${input_array[4]}
		Preference_InitialUserPassword=${input_array[5]}
		Preference_InitialKeyboardLayout=${input_array[6]}
		Preference_InitialLanguage=${input_array[7]}
		Preference_InitialLanguageEncoding=${input_array[8]}
		Preference_InitialTimeZone=${input_array[9]}
		Preference_Wireless_ID=${input_array[10]}
		Preference_Wireless_Password=${input_array[11]}
		Preference_Role=${input_array[12]}
		Preference_CopySSHKey=${input_array[13]}

		# Encrypt the user/admin password before saving & for use in the preseed file
		# If the password is already encrypted, then skip this step:
		if [[ ${#Preference_InitialUserPassword} -ge 30 ]] ; then
			system::log_item "Password appears to be encrypted already so skipping encryption..."
		else
			system::log_item "Password appears to be clear text, encrypting password..."
			Preference_InitialUserPassword=$(printf "%s" "$Preference_InitialUserPassword" | mkpasswd -s -m sha-512)
			if system::update_config "$_config_file" "Preference_InitialUserPassword" "${Preference_InitialUserPassword}" ; then
				system::log_item "Stored encrypted password in user preferences: $_config_file"
			else 
				system::log_item "[ERROR] Failed to store encrypted password in user preferences: $_config_file"
			fi
		fi

		system::log_item "Save as defaults and continue..."
		write_information "Saving preferences to: $_config_file"
		
		system::update_config "$_config_file" \
		"Preference_DiskEncryption" "${Preference_DiskEncryption}" \
		"Preference_Disk_Password" "${Preference_Disk_Password}" \
		"Preference_InitialUser" "${Preference_InitialUser}" \
		"Preference_InitialUserFullName" "${Preference_InitialUserFullName}" \
		"Preference_InitialUserGroup" "${Preference_InitialUserGroup}" \
		"Preference_InitialKeyboardLayout" "${Preference_InitialKeyboardLayout}" \
		"Preference_InitialLanguage" "${Preference_InitialLanguage}" \
		"Preference_InitialLanguageEncoding" "${Preference_InitialLanguageEncoding}" \
		"Preference_InitialTimeZone" "${Preference_InitialTimeZone}" \
		"Preference_Wireless_ID" "${Preference_Wireless_ID}" \
		"Preference_Wireless_Password" "${Preference_Wireless_Password}" \
		"Preference_Role" "${Preference_Role}" \
		"Preference_CopySSHKey" "${Preference_CopySSHKey}" 
		
		return $?
	else
		write_information "Prompting for VM settings is not requested: ${_role} ${_task} automatically using defaults or parameter instructions..."
		return 0
	fi

}




dependency::command_exists() {
# Description: Function to check if a command exists.
# The purpose of this function is to check if a command exists in the system.
# To use this function, simply call it passing the command name as an argument.

# Globals: None
# Arguments: ["Command name"]
# Outputs: None
# Returns: 0 if the command exists, 1 if it does not
# Usage:    
# dependency::command_exists "command"
#    
# End of Documentation

# List of required command(s) from input:
	required_commands=($@)

	# Function to check if a command is available
	command_exists() {
		command -v "$1" >/dev/null 2>&1
	}

	# Check each command and collect the missing ones
	missing_commands=()
	for cmd in ${required_commands[*]}; do
		if ! command_exists $cmd ; then
		missing_commands+=("$cmd")
		fi
	done

	if [ ${#missing_commands[@]} -eq 0 ]; then
		return 0
	else
		local response_file="/tmp/missing_commands_response"
		
		if [[ -f "$response_file" ]]; then
			response=$(cat "$response_file")
		else
			read -p "${#missing_commands[@]} command(s) are missing: ${missing_commands[*]}. Do you want to install them? [y/N]: " response
			echo "$response" > "$response_file"
		fi

		if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
			# Ensure the user has sudo privileges before installation
			system::install_missing_commands "${missing_commands[*]}"
			local install_status=$?
			rm -f "$response_file"  # Clean up the response file
			return $install_status
		else
			write_error "Required command(s) not found: ${missing_commands[*]}"
			rm -f "$response_file"  # Clean up the response file
			return 1
		fi
	fi
}




system::install_missing_commands() {

	if [ "$#" -eq 0 ]; then
		write_error "No command specified to find and install."
		return 1
	fi

	local distro
	local cmd
	distro=$(system::distribution_type)

	for cmd in ${*}; do
		case "$distro" in
		debian)
			# Debian and Ubuntu
			write_information "Check if the command ($cmd) exists"
			if ! command -v "$cmd" &> /dev/null; then
				# Attempt to execute the command to trigger 'command-not-found'
				# and capture its output
				local install_info
				install_info=$( apt-cache search --names-only "$cmd" | awk '{print $1}'| head -n1 )
				write_information "Extract the package suggestion ($install_info)"
				# Extract the package suggestion
				local pkg
				pkg="$install_info"
				if [ -n "$pkg" ]; then
					write_status "Installing '$cmd' using package '$pkg'..."
					software::add_native_package "$pkg"
				else
					write_error "Package for command '$cmd' not found. Trying snap..."
					install_info=$(snap find "$cmd" 2>&1)
					pkg=$(echo "$install_info" |head -n2 |tail -1 | cut -f1 -d' ')
					if [ -n "$pkg" ]; then
						write_status "Installing '$cmd' using snap package '$pkg'..."
						software::from_snapcraft.io "$pkg"
					fi
				fi
			fi
			;;
		redhat)
			# Fedora and RHEL
			local pkg
			pkg=$(dnf provides */$cmd | grep ' : ' | head -n1 | cut -d' ' -f1)
			if [[ -n "$pkg" ]]; then
				dnf install -y "$pkg"
			fi
			;;
		suse)
			# openSUSE / SUSE
			for cmd in "${missing_commands[@]}"; do
				cnf_output=$(cnf "$cmd" 2>&1)
				if [[ $cnf_output == *"can be found in following package"* ]]; then
					# Extracting package name
					pkg=$(echo "$cnf_output" | grep "^\s*\*" | awk '{print $2}')
					if [[ -n "$pkg" ]]; then
						zypper install -y "$pkg"
					else
						write_error "Package for command '$cmd' not found."
					fi
				else
					write_error "Command '$cmd' not found in cnf database."
				fi
			done
		;;
		*)
			write_error "Unsupported distribution: $distro"
			exit 1
			;;
		esac
	done
}



dependency::desktop() {
	# Description: This function simplifies identifying the currently running desktop.
	#
	# The main problem with checking the DESKTOP_SESSION is that it is set by the display
	# manager rather than the desktop session and is subject to inconsistencies.
	# For lightdm on Debian, the values come from the names of files under /usr/share/xsessions/.
	# DESKTOP_SESSION reflects the desktop environment if a specific selection is made at log in,
	# however the lightdm-xsession is always used the default session.
	#
	# GDMSESSION is another option, but seems to have a similar predicament
	# (it is often the same value as DESKTOP_SESSION).
	#
	# XDG_CURRENT_DESKTOP looks like a good choice, however it is currently not in the XDG
	# standard and thus not always implemented. See here for a discussion of this. This
	# answer shows its values for different distros/desktops.
	#
	# The reasonable fallback for XDG_CURRENT_DESKTOP not existing would be to try
	# XDG_DATA_DIRS. Provided the data files for the desktop environment are installed
	# in a directory bearing its name, this approach should work. This will hopefully
	# be the case for all distros/desktops!
	#
	# Globals:    None
	# Arguments:  None
	# Outputs:    Standard error 1/0
	# Returns:    0 = desktop is what you are searching for. 1 = is not what you are searching for.
	# Usage:      dependency::desktop gnome|kde|xfce|mate
	# 
	# This function checks if there is a running desktop session that matches the specified desktop environment.
	# It attempts to find the currently running desktop environment reliably by checking various environment variables
	# and processes. If the specified desktop environment is found, it returns 0; otherwise, it returns 1.
	#
	# Example usage:
	#   dependency::desktop gnome   # Check if there is a running GNOME desktop session
	#   dependency::desktop kde     # Check if there is a running KDE desktop session
	#   dependency::desktop xfce    # Check if there is a running Xfce desktop session
	#   dependency::desktop mate    # Check if there is a running MATE desktop session
	#
	# End of documentation
	local _sought="${1,,}"
	system::log_item "checking if there is a running $_sought desktop session..."
	local _desktop

	# Try to find the currently running desktop environment reliably...
	if [[ "$XDG_CURRENT_DESKTOP" == "" ]] ; then
		system::log_item "XDG_CURRENT_DESKTOP appears to be unset, attempting to search processes for desktop match... "
	elif  pgrep -f "plasmashell" ; then
		local _desktop="kde"
	elif  pgrep -f "gnome-shell"; then
		local _desktop="gnome"
	elif  pgrep -f "mate"; then
		local _desktop="mate"
	elif  pgrep -f "xfce"; then
		local _desktop="xfce"
	else
		local _desktop="$XDG_CURRENT_DESKTOP"
	fi

	# Check what we found...
	system::log_item "Found: _desktop=$_desktop"
	local _desktop="${_desktop,,}"
	if [[ "$_desktop" == *"$_sought"* ]]; then
		return 0
	else
		return 1
	fi
}



dependency::os_linux () {
	# Description: This function simplifies checking if the currently OS is Linux or not. 
	#  
	# Globals:	None
	# Arguments:	None
	# Outputs:	Standard error 1/0
	# Returns:	0 = Running in Linux. 1 = is not running in Linux.
	# Usage: 	dependency::os_linux
	# End of documentation

       	if echo "$OSTYPE" |grep -q "linux" ; then
		return 0
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported ..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported ... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported... " ; return 1
	else
		echo "I have no Idea what this OS is" ; return 1
	fi
}



system::check_file_limits() {
	# Description:
	#
	# This function is designed to check and display the current usage of file
	# descriptors against the set limits in a Linux system. It provides a clear
	# overview of open files and system limits, aiding in resource monitoring and
	# troubleshooting.
	#
	# The function performs the following actions:
	# - Retrieves the count of currently open files using `lsof`.
	# - Fetches the user-specific soft and hard limits for open files (`nofile`).
	# - Obtains the system-wide file handle limit.
	# - Displays the collected information in a user-friendly format.
	#
	# Additionally, it includes a spinner animation to indicate progress while
	# gathering data, enhancing the user experience during potentially longer
	# operations.
	#
	# Usage:
	#   Call `system::check_file_limits` from the terminal or within a script to
	#   execute the function.
	#
	# Notes:
	# - The function uses a temporary file (`/tmp/open_files_count`) to store the
	#   count of open files, which is then read and displayed.
	# - The spinner is implemented as a nested function `system::check_file_limits::spinner`,
	#   which visually indicates ongoing processing.
	# - The `printf` command is used with formatting to align and present the data
	#   clearly, including the use of thousand separators for better readability.
	# - The function checks if current usage exceeds any of the defined limits and
	#   displays appropriate warnings or critical alerts.
	#
	# Dependencies:
	# - Requires `lsof`, `sysctl`, `awk`, and standard bash utilities.
	#
	# Limitations:
	# - The spinner animation relies on the terminal's ability to interpret control
	#   characters for cursor movement. May not work correctly in all terminal
	#   environments.
	# - Number formatting is locale-dependent and assumes `en_US.UTF-8` is available
	#   and correctly configured on the system.
	#
	# End of documentation

    # Get the number of currently open files in the background
	lsof | wc -l > /tmp/open_files_count &
	local lsof_pid=$!

	system::check_file_limits::spinner() {
		local pid=$1
		local delay=0.1
		local spinstr='|/-\\'
		echo -n " Working... "
		while kill -0 "$pid" 2>/dev/null; do
			local temp=${spinstr#?}
			printf "[%c]" "$spinstr"
			local spinstr=$temp${spinstr%"$temp"}
			sleep $delay
			printf "\b\b\b"
		done
		echo -ne "\r               \r"
	}
	# Start the spinner
	system::check_file_limits::spinner "$lsof_pid"

	# Read the open files count
	local open_files=$(cat /tmp/open_files_count)

	# Rest of your function...
	local user_soft_limit=$(ulimit -Sn)
	local user_hard_limit=$(ulimit -Hn)
	local system_limit=$(sysctl -n fs.file-max)
	local allocated_file_handles=$(awk '{print $1}' /proc/sys/fs/file-nr)

	# Print the results
	write_information "
	💻 File Descriptors Usage and Limits:
	$(tput bold; tput setaf 1)-------------------------------------------------------- $(tput sgr0)
	$(printf "%-43s \e[36m%'10d\e[0m\n" "Open Files:" $open_files )
	$(printf "%-43s \e[36m%'10d\e[0m\n" "User Soft Limit:" $user_soft_limit )
	$(printf "%-43s \e[36m%'10d\e[0m\n" "User Hard Limit:" $user_hard_limit )
	$(printf "%-43s \e[36m%'10d\e[0m\n" "System-Wide File Handles Limit:" $system_limit )
	$(printf "%-43s \e[36m%'10d\e[0m\n" "Allocated File Handles (System-Wide):" $allocated_file_handles )

	$(tput bold; tput setaf 1)-------------------------------------------------------- $(tput sgr0)
	"
	# Additional information based on limits...
	if [ "$open_files" -gt "$user_soft_limit" ]; then
		echo "Warning: You are exceeding your soft limit of open files."
	fi

	if [ "$open_files" -gt "$user_hard_limit" ]; then
		echo "Critical: You are exceeding your hard limit of open files."
	fi

	if [ "$allocated_file_handles" -gt "$system_limit" ]; then
		echo "Critical: The system is exceeding its overall file handles limit."
	fi
}



system::distribution_type() {
	# Description:
	#
	# This function determines the Linux distribution type of the system on which it is run. It identifies the 
	# distribution by checking for the presence of specific files and functions unique to each distribution's 
	# initialization system. The function aims to support a variety of Linux distributions, including Fedora,
	#  RHEL, CentOS, SUSE, Debian, Ubuntu, Gentoo, Mandriva, and Slackware.
	#
	# Parameters: none
	#
	# Returns:
	#
	# Prints the type of the Linux distribution to standard output. The possible return values are:
	#
	#     "fedora": For Fedora Linux.
	#     "redhat": For Fedora, RHEL, CentOS, and other Red Hat derivatives.
	#     "suse": For SUSE Linux distributions.
	#     "debian": For Debian, Ubuntu, and derivatives.
	#     "gentoo": For Gentoo Linux.
	#     "mandriva": For Mandriva Linux.
	#     "slackware": For Slackware Linux.
	#     "unknown": If the distribution cannot be determined.
	#
	# Usage:
	#
	# To use this function, simply call it within a bash script or from the command line in a script 
	# environment where the function has been defined. Example usage:
	#
	# distribution=$(system::distribution_type)
	# echo "Detected distribution: $distribution"
	#
	#
	# Notes:
	#
	#     The order of checks matters, as some distributions may share certain files or functions. The function 
	#     is structured to minimize false positives. For Mandriva and Slackware, the function currently 
	#     checks for the presence of /etc/mandriva-release and /etc/slackware-version, 
	#     respectively, but acknowledges that a better method of identification might be needed.
	#     This function does not have external dependencies beyond the bash shell and standard Linux filesystem 
	#     and command-line tools.
	#
	# Example:
	#
	# Here's how you might call this function within a script to execute different commands based on the detected distribution:
	#
	# bash
	#
	# case $(system::distribution_type) in
	#     redhat)
	#         echo "This is a Red Hat derivative."
	#         ;;
	#     debian)
	#         echo "This is a Debian derivative."
	#         ;;
	#     *)
	#         echo "Distribution not specifically handled."
	#         ;;
	# esac
	#
	# End of documentation

	local dtype
	dtype="unknown"

	{
	# First test specifically for Fedora
	if [ -r /etc/fedora-release ]; then
	dtype="fedora"

	# Then test against Fedora / RHEL / CentOS / generic Redhat derivative
	elif [ -r /etc/rc.d/init.d/functions ]; then
	source /etc/rc.d/init.d/functions
	[ "zz$(type -t passed 2>/dev/null)" == "zzfunction" ] && dtype="redhat"

	# Then test against SUSE (must be after Redhat,
	elif [ -r /etc/rc.status ]; then
	source /etc/rc.status
	[ "zz$(type -t rc_reset 2>/dev/null)" == "zzfunction" ] && dtype="suse"

	# Then test against Debian, Ubuntu and friends
	elif [ -r /lib/lsb/init-functions ]; then
	source /lib/lsb/init-functions
	[ "zz$(type -t log_begin_msg 2>/dev/null)" == "zzfunction" ] && dtype="debian"

	# Then test against Gentoo
	elif [ -r /etc/init.d/functions.sh ]; then
	source /etc/init.d/functions.sh
	[ "zz$(type -t ebegin 2>/dev/null)" == "zzfunction" ] && dtype="gentoo"

	# For Mandriva we currently just test if /etc/mandriva-release exists
	elif [ -s /etc/mandriva-release ]; then
	dtype="mandriva"

	# For Slackware we currently just test if /etc/slackware-version exists
	elif [ -s /etc/slackware-version ]; then
	dtype="slackware"

	fi
	} &>/dev/null
	echo $dtype

}



dependency::file () {
	# Description: Function to check for a bash library or script file and source it.
	#
	# This function searches a predetermined set of paths for a given file and sources it if found.
	# It first searches for the file locally in a set of predefined paths. If the file is found, it is sourced.
	# If the file is not found locally, the function attempts to download it from a specified URL and source it.
	# If the download is successful, the file is sourced. If the download fails, the function logs an error and exits.
	#
	# Globals:
	#   _GIT_PROFILE: The GitHub profile to use for downloading the file (default: vonschutter)
	# Arguments:
	#   Filename: The name of the file to search for and source
	# Outputs:
	#   None
	# Returns:
	#   Standard error level
	# Usage:
	#   dependency::file <filename>
	#   Example: dependency::file _config.ini
	#
	# Dependencies:
	#   This function depends on the following functions:
	#   - system::log_item: A function to log messages
	#
	# End of documentation


	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"
	
	dependency::search_local () {
		# Description: Internal function!
		# It may not be useful to call this directly. This function searches 
		# a predetermined set of paths for a given file, and source it if found.
		# it is part of the function dependency::file -- use this instead.
		# End of Documentation

		system::log_item "Requested dependency file: ${1} ..."
		local script_path="$(readlink -f "$0")"
		local script_dir="$(dirname "$script_path")"
		local paths=(
			"$(dirname "$(find /opt/rtd -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			"$(dirname "$(find /home/${SUDO_USER}/GIT -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			"$(dirname "$(find /home/${SUDO_USER}/bin -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			"${script_dir}/${1}"
			"./${1}"
			)

		for path in "${paths[@]}"; do 
			system::log_item "Searching for ${path} ..."
			if [[ -e "${path}" ]]; then
				system::log_item "Found ${path}"
				source "${path}"
				return 0
			fi
		done

		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		system::log_item "$(date) failure to find $1 on the local computer, now searching online..."
		local tmpdir=$(mktemp -d)
		if curl -sL "$_src_url" -o "${tmpdir}/${1}" ; then 
			system::log_item "Using: ${_src_url} directly from URL..."
			source "${tmpdir}/${1}"
		elif wget "${_src_url}" -O "${tmpdir}/${1}" &>/dev/null ; then
			source "${tmpdir}/${1}"
			system::log_item "Using: ${_src_url} downloaded..."
		else 
			system::log_item "Failed to find  ${1} "
			exit 1
		fi
		rm -rf "${tmpdir}"
	fi 
}



oem::deploy_themes() {
	# Description: Function to download and deploy themes from Github.
	#              The github location is defined in the _locations file for consistency.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns: Standard error level.
	# Usage: simply call function in a script, or override the default location in _locations:
	#        oem::deploy_themes https://www.github.com/myuser/myrepo.git
	# End of documentation

	local GIT_Theme_URL="${1:-"$GIT_Theme_URL"}"
	local _THEME_DIR="${_THEME_DIR:-"/opt/${_TLA:-rtd}/themes"}"

	if ! mkdir -p "${_THEME_DIR}"; then
		write_error "Failed to create directory ${_THEME_DIR}"
		return 1
	fi

	if [[ -z "${GIT_Theme_URL}" ]]; then
		write_error "No theme URL found! It needs to be set in the _locations file or passed as an argument."
		return 1
	fi
	
	if git clone --depth=1 "${GIT_Theme_URL}" "${_THEME_DIR}"; then
		write_status "Cloned ${GIT_Theme_URL} successfully."
	else
		write_error "An error occurred while cloning ${GIT_Theme_URL}."
		return 1
	fi
}



dependency::virtualization() {
	# Description: Common function to check on the required components for making virtual machines. 
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns: nothing
	# Usage: simply call function in a script
	# End of documentation

	OS_NAME=$(hostnamectl | awk '/Operating System/ {print $3}')
	write_status "${FUNCNAME[0]}: Checking for virtualization software..."

	local _probable_dependencies
	case $OS_NAME in
		openSUSE|Tumbleweed)
			if ! command -v qemu-system-x86_64 >/dev/null 2>&1; then
				write_status "KVM or QEMU not found. Installing virtualization software for $OS_NAME..."
				zypper install -y --recommends -t pattern "kvm_server" "kvm_tools" | tee -a "${_LOGFILE}"
				sudo systemctl enable --now libvirtd
			else
				write_status "KVM and QEMU are available..."
			fi
		;;
		Fedora | RHEL | CentOS)
			if ! command -v qemu-system-x86_64 >/dev/null 2>&1; then
				write_status "KVM or QEMU not found. Installing virtualization software for $OS_NAME..."
				software::add_native_package "@virtualization"
				sudo systemctl enable --now libvirtd
			else
				write_status "KVM and QEMU are available..."
			fi
		;;
		Debian | Ubuntu | TUXEDO | *)
			if ! command -v qemu-system-x86_64 >/dev/null 2>&1; then
				write_status "KVM or QEMU not found. Installing virtualization software for $OS_NAME..."
				local count=1
				for dependency in qemu-kvm libvirt-daemon  bridge-utils virtinst libvirt-daemon-system libosinfo-bin ; do
					write_status "${count} - Verifying dependency (${dependency})..."
					software::add_native_package "$dependency" 
					count=$((count + 1))
				done
				sudo systemctl enable --now libvirtd
			else
				write_status "KVM and QEMU are available..."
			fi

		;;
	esac
	wait # Wait for all background processes to finish
}



system::check_required_variables() {
	# Description: Function to check for the presence and non-emptiness of a list of variables.
	# This function checks for the presence and non-emptiness of a list of variables. 
	# It is designed to validate that certain required variables are both defined (set) 
	# and have a non-empty value. This is particularly useful in scripts where specific 
	# variables are essential for correct execution.
	#
	# Arguments:
	#     $@: A list of variable names (as strings) to be checked. Each argument should 
	#     be the name of a variable to check.
	#
	# Outputs:
	#     If any variables are found to be unset, it prints a message listing these variables.
	#     If any variables are found to be set but empty, it prints a message listing these variables.
	#
	# Return Values:
	#     Returns 0 (success) if all variables are set and non-empty.
	#     Returns 1 (failure) if any variable is either unset or set but empty.
	#
	# Usage:
	# To use this function, pass the names of the variables you want to check as arguments. For example:
	#
	# system::check_required_variables "VAR1" "VAR2" "VAR3"
	#
	# Example:
	# VAR1="data"
	# VAR2=""
	# VAR3=
	#
	# if system::check_required_variables "VAR1" "VAR2" "VAR3"; then
	#     echo "All required variables are set and non-empty."
	# else
	#     echo "Some required variables are either unset or empty."
	# fi
	#
	# Notes:
	#     This function is useful in scenarios where the correct configuration of the environment or 
	#     script depends on certain variables. It helps in early detection of misconfigurations 
	#     or missing data, allowing for more robust and error-resistant scripts. The function 
	#     does not modify any of the variables it checks; it only reports on their status.
	# End of documentation

	local unset_vars=()
	local empty_vars=()

	for var in "$@"; do
		if [ -z "${!var+x}" ]; then
			unset_vars+=("$var")
		elif [ -z "${!var}" ]; then
			empty_vars+=("$var")
		fi
	done

	if [ ${#unset_vars[@]} -ne 0 ]; then
		write_error "The following requred variables are unset: ${unset_vars[*]}"
	fi

	if [ ${#empty_vars[@]} -ne 0 ]; then
		write_error  "The following required variables are set but empty: ${empty_vars[*]}"
	fi

	if [ ${#unset_vars[@]} -ne 0 ] || [ ${#empty_vars[@]} -ne 0 ]; then
		return 1
	fi
}




system::find_vm_bridge() {
	# Description:
	# This function searches for the default bridge network device on the system. It is designed to 
	# work in environments where virtual machines (VMs) are managed, typically using bridge networks for 
	# VM connectivity. If no bridge network device is found (prefixed with br or named bridge), the 
	# function defaults to a NAT device named "default".
	#
	# Globals:
	# None. This function does not depend on or modify any global variables.
	#
	# Arguments:
	# None. The function does not take any arguments.
	#
	# Outputs:
	# The function outputs one of the following, depending on the system's network configuration:
	#
	#     The name of the first bridge network device found (e.g., br0, bridge0).
	#     default if no bridge network device is found.
	#
	# Returns:
	#     The name of a bridge network device (e.g., br0, bridge0) if one is found.
	#     default if no bridge network device is found.
	#
	# Usage:
	# To use this function, simply call it within a script. For example:
	#
	# bridge_device=$(system::find_vm_bridge)
	# echo "The default bridge device is: $bridge_device"
	#
	# This will store the name of the default bridge network device (or default if none is found) 
	# in the variable bridge_device and then print it.
	#
	# Additional Notes:
	#
	#     This function is particularly useful in virtualized environments where network bridging is 
	#     a common requirement.It assumes a standard naming convention for bridge devices (starting with br or named bridge).
	#     The function uses grep to filter the network devices and ls to list them from /sys/class/net, 
	#     which is a standard location for network interface information in Linux.
	# End of documentation

	if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi
}




system::restart_sound() {
	# Description: Function to check for PipeWire or Pulse Audio and attempt to restart sound.
	#
	# This function checks if the system has PipeWire or Pulse Audio installed. If PipeWire is 
	# installed, it restarts the pipewire.service. If Pulse Audio is installed, it kills the pulseaudio 
	# process and reloads the ALSA sound driver. If neither PipeWire nor Pulse Audio is found, 
	# it displays an error message.
	#
	# Globals: None
	# Arguments: None
	# Outputs: None
	# Returns: Standard error level.
	# Usage: Simply call this function in a script.
	# End of documentation

	if hash pw-cli ; then 
		systemctl --user restart pipewire.service
	elif hash pactl ; then
		pulseaudio -k && sudo alsa force-reload
	else 
		write_error "Pulse Audio or PipeWire sound software was not found..." 
	fi
}



system::remove_old_kernel() {
	# Description: Function to remove all old linux kernels.
	#
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns: Standard error level.
	# Usage: simply call function in a script
	# End of documentation

        if echo "$OSTYPE" |grep -q "linux" &>/dev/null ; then
                # these tests focus on the latest versions of the distros evaluated...
		ensure_admin
                if hash apt-get &>/dev/null ; then
                        dialog::display_notice "🧩 ${FUNCNAME[0]}: An apt based system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                dpkg -l linux-* | awk '/^ii/{print $2}' | grep -E "[0-9]" | sort -t- -k3,4 --version-sort -r | sed -e "1,/$(uname -r | cut -f1,2 -d"-")/d" | grep -v -e "$(uname -r | cut -f1,2 -d"-")" | xargs apt-get -y purge
                                return $?
                        else
                                return 1
                        fi
                elif hash zypper &>/dev/null ; then
                        dialog::display_notice "🧩 ${FUNCNAME[0]}: An Zypper based package management system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                zypper purge-kernels
                                return $?
                        else
                                return 1
                        fi
                elif hash dnf &>/dev/null ; then
                        dialog::display_notice "🧩 ${FUNCNAME[0]}: An DNF based package management system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                dnf remove "$(dnf repoquery --installonly --latest-limit 2 -q)" 
                                return $?
                        else
                                return 1
                        fi
                else
                        dialog::display_notice "${FUNCNAME[0]}: a supported package manager was not found for this action..."
                        return 1
                fi
        elif [[ "$OSTYPE" == "darwin"* ]]; then
                write_error "${FUNCNAME[0]}: Mac OSX is currently not supported!"  ; return 1
        elif [[ "$OSTYPE" == "cygwin" ]]; then
                write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported!"  ; return 1
        elif [[ "$OSTYPE" == "msys" ]]; then
                write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported! "  ; return 1
        elif [[ "$OSTYPE" == "freebsd"* ]]; then
                write_error "${FUNCNAME[0]}: Free BSD is currently unsupported! " ; return 1
        else
                echo "I have no Idea what this system is" ; return 1
        fi

}





system::change_disk_pass() {
	# Description: Function to change the passphrase fo an encrypted storage device.
	# It will offer to change the first encrypted volume found by blockid.
	# It is unclear how this will work if there are multiple encrypted volumes found.
	# The function does not expect an argument. It will prompt for a password.
	#
	# Globals:
	# Arguments: None accepted
	# Outputs: Interactive
	# Returns: default exit status of the last command run.
	# Usage: change_disk_pass
	#
	#
	# End of Documentation

	clear
	write_host --red "Changing the disk encryption password for your hard drive:"
	cryptsetup luksChangeKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)"
	read -p "Press  [ ENTER ] to continue:"
}



system::oem_autounlock_disk() {
	# Setup automatic unlocking of the encrypted system disk.
	# NOTE: This will render the encryption useless since the key to unlock the encrypted
	# volume will be located on an unencrypted location on the same system as the encrypted volume.
	# This is the same as locking your door and leaving the key by the door outside.
	#
	# The intention behind this is to be able to complete all build activites without manual intervention
	# of any kind. The intention is to remove the key file after all administrative tasks are complete.
	#
	# 1. Back up your initramfs disk
	#
	# Globals:
	# Arguments: None accepted
	# Outputs:
	# Returns: default exit status of the last command run.
	# Usage: oem_autounlock_disk
	#
	# End of Documentation

	local _pass="$1"
	local kernel_version=$(uname -r)
	local encrypted_dev
	local uuid

	# 1. Backup initramfs disk
	cp /boot/initrd.img-${kernel_version} /boot/initrd.img-${kernel_version}.bak

	# 2. Update GRUB configuration
	cat > /boot/grub/grub.cfg <<-EOF
	### BEGIN /etc/grub.d/10_linux ###
	menuentry 'Debian GNU/Linux, with Linux ${kernel_version} (crypto safe)' {
		load_video
		insmod gzio
		insmod part_msdos
		insmod ext2
		set root='hd0,msdos1'
		search --no-floppy --fs-uuid --set=root 2a5e9b7f-2128-4a50-83b6-d1c285410145
		echo    'Loading Linux ${kernel_version} ...'
		linux   /vmlinuz-${kernel_version} root=/dev/mapper/dradispro-root ro quiet
		echo    'Loading initial ramdisk ...'
		initrd  /initrd.img-${kernel_version}.safe
	}
	### END /etc/grub.d/10_linux ###
	EOF

	# 3. Create the key file in the unencrypted /boot partition
	dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4
	chmod 0400 /boot/keyfile

	# 4. Add the new file as unlock key to the encrypted volume
	encrypted_dev=$(blkid | grep crypto_LUKS | cut -d : -f 1)
	echo $_pass | cryptsetup -v luksAddKey "$encrypted_dev" /boot/keyfile -

	# 5. Edit /etc/crypttab
	cp /etc/crypttab /etc/crypttab.bak
	chmod 0600 /etc/crypttab
	uuid=$(udevadm info "$encrypted_dev" | grep by-uuid | cut -d : -f 2 | head -1)
	sed -i /"$(cat /etc/crypttab | cut -d " " -f 1)"/d /etc/crypttab
	echo "$(cat /etc/crypttab | cut -d " " -f 1-2)" /"${uuid}":/keyfile luks,keyscript=/lib/cryptsetup/scripts/pa$  >> /etc/crypttab
	chmod 0440 /etc/crypttab

	# 6. Generate new initramfs
	mkinitramfs -o /boot/initrd.img-${kernel_version} ${kernel_version}
}



github::clone_repo_user() {
	# Description:
	# Function to CLONE all github.com repositories for a specified user.
	# simply call the function and pass the username as parameter to clone
	# all github repositories in to the current folder.
	#
	# Globals: None
	# Arguments: User-name
	# Outputs:
	# Returns: a download of all repositories for the given user.
	# Usage: ${FUNCNAME[0]} user-name
	# End of documentation

	if [ $# -eq 0 ]; then
	    echo "Usage: ${FUNCNAME[0]} <user_name> "
	    exit 1;
	fi

	for repo in $(curl -s https://api.github.com/users/${1}/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/');do
	  git clone --depth=1 "https${repo:3}";
	done

}



github::list_all_user_repositories() {
	# Description:
	# Function to LIST all github.com repositories for a specified user.
	# simply call the function and pass the username as parameter to show
	# all github repositories the indicated user.
	#
	# Globals: None
	# Arguments: User-name
	# Outputs:
	# Returns: a LIST of all repositories for the given user.
	# Usage: ${FUNCNAME[0]} user-name
	# End of documentation

	if [ $# -eq 0 ]
	  then
	    echo "Usage: ${FUNCNAME[0]} <user_name> "
	    return 1;
	fi

	for repo in $(curl -s https://api.github.com/users/${1}/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/'); do
		echo "https${repo:3}"
	done

}



oem::register_all_tools() {
	# Description: Function to register all OEM scripts on the current device.
	# It will find all the ${_TLA} powertools locations and make a link for each script to
	# the system /bin directory. This assures that all tools can be easily accessed from any terminal.
	#
	#
	# Globals: ${_MODS_DIR}
	# Arguments: None accepted
	# Outputs:
	# Returns: default exit status of the last command run.
	# Usage: oem::register_all_tools
	# Dependencies: _locations
	#
	# End of Documentation
	_bashrc="/home/${_OEM_USER:-"tangarora"}/.bashrc"

	sed -i s/'# session  optional       pam_xauth.so'/'session  optional       pam_xauth.so'/g /etc/pam.d/sudo
	if ! grep "xhost local:root" "${_bashrc}" ; then echo 'xhost local:root >/dev/null' >> "${_bashrc}" ; fi

	if [[ -n "${_MODS_DIR}" ]] ; then
		for d in ${_MODS_DIR}/*/ ; do
			write_status "Creating links to $d"
			for f in $d/${_TLA,,}* ;
			do
				write_status "Processing: ${f}"
				chmod +x "${f}"
				ln -f -s "${f}" -t /bin/
			done
		done
		write_status "Creating links to ${_OEM_DIR}/core/*.sh"
		chmod +x "${_OEM_DIR}"/core/*.sh
		ln -f -s "${_OEM_DIR}"/core/*.sh -t /bin/
		return
	else
		write_error "Location variables not set!"
		return 1
	fi
}



dialog::check_menu_availability() {
	# Description: First discover what menu system is installed. Some systems use "dialog" and
	# other systems use whiptail for the terminal to show menus and dialogs.
	# If nothing is found, then make sure it is available before continuing.
	#
	# Globals:
	# RTD_GUI respected as default value. If unset it will be set to "dialog" or "whiptail"
	# depending on which is present. IF both are present, the dialog is prefferred.
	#
	# Arguments: 	None accepted
	# Outputs: 	Interactive
	# Returns: 	Default exit status of the last command run.
	# Usage: 	dialog::check_menu_availability
	#
	# End of documentation
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" \
			--title "System Information Menu" \
			--no-button "NO: Use whiptail" \
			--yes-button "YES: Install dialog" \
			--yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " \
			20 90 ); then
			RTD_GUI=dialog
			err_no_menu_system_found
		else
			echo "User selected No, exit status was $?."
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}


oem::rtd_tools_make_launchers() {
	# Description: Function that creates a default set of launchers for the Linux GUI menu system.
	#
	# Globals:
	# The tools (scripts) located in {_OEM_DIR}/*/ are expected as launchers are created for these.
	# ${_MODS_DIR}
	#
	# Arguments: None accepted
	# Outputs: Launcherc created in /usr/share/applications/
	# Returns: Default exit status of the last command run.
	# Usage: oem::rtd_tool_make_launchers
	#
	# End of documentation

	if [[ ! $UID -eq 0 ]]; then
		write_error "This function requires elevated privileges. Please elevate privileges prior to calling this function."
		return 1
	else
		write_information "Creating ${_TLA} launchers..."
		# Add launchers for some OEM apps.
		cat > /usr/share/applications/rtd.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD
		Comment=RTD Simple System Support Tool
		Exec=${_MODS_DIR}/simple-support-tool.mod/rtd-simple-support-tool
		Path=${_MODS_DIR}/simple-support-tool.mod
		Icon=${_MODS_DIR}/simple-support-tool.mod/Media_files/sys2.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-user-bakup.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-Backup
		Comment=RTD User home Backup Tool
		Exec=${_MODS_DIR}/system-user-backup.mod/rtd-oem-backup-linux-config
		Path=${_MODS_DIR}/system-user-backup.mod
		Icon=${_MODS_DIR}/system-user-backup.mod/Media_files/sys0.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-nordvpn.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-NordVPN
		Comment=Nord VPN Termnal GUI
		Exec=${_MODS_DIR}/nordvpn-manager.mod/rtd-nordvpn
		Path=${_MODS_DIR}/nordvpn-manager.mod
		Icon=${_MODS_DIR}/nordvpn-manager.mod/Media_files/sys3.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-minercraft-server.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=Minecraft-Server
		Comment=Automatically download and start a Minecraft Server here now!
		Exec=${_MODS_DIR}/minecraft-server-manager.mod/rtd-minecraft-server
		Path=${_MODS_DIR}/minecraft-server-manager.mod
		Icon=${_MODS_DIR}/minecraft-server-manager.mod/Media_files/sys5.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-switch-desktop.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD UI Look Changer
		Comment=Change the overall look and feel of your desktop (be more like Windows or MAC)
		Exec=${_MODS_DIR}/rtd-desktop-look-switcher.mod/rtd-desktop-look-switcher
		Path=${_MODS_DIR}/rtd-desktop-look-switcher.mod
		Icon=${_MODS_DIR}/rtd-desktop-look-switcher.mod/Media_files/sys7.ico
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-software-bundle-manager.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD Software Bundle Manager
		Comment=Add and remove bundles of software by task to your computer.
		Exec=${_MODS_DIR}/oem-bundle-manager/rtd-oem-bundle-manager
		Path=${_MODS_DIR}/oem-bundle-manager
		Icon=${_MODS_DIR}/oem-bundle-manager/image/software.ico
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-hardware-information.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD Hardware Information Viewer
		Comment=Add and remove bundles of software by task to your computer.
		Exec=${_MODS_DIR}/system-hardware-information/rtd-system-hardware-information
		Path=${_MODS_DIR}/system-hardware-information
		Icon=${_MODS_DIR}/system-hardware-information/image/system-information-icon-3.png
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF
		
		cat > /usr/share/applications/rtd-app-runner.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD OEM Special App Runner
		Comment=Run Specialized OEM Applications safely and reliably.
		Exec=${_MODS_DIR}/oem-app-runner/rtd-oem-app-runner
		Path=${_MODS_DIR}/oem-app-runner
		Icon=${_MODS_DIR}/oem-app-runner/image/App-launcher.jpg
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF
	fi
}



system::get_Windows_Product_Key() {
	# Description: Function to retrieve a Windows product key from the BIOS. This assumes that the OEM
	# has indeed stored the windows key in the BIOS... Doing so is a common practice. It is useful to
	# retrieve the key if it is desired to run Windows in a Virtual Machine and Presumably would prefer to
	# not run the evaluation version of Windows. This function could also be used to take advantage of the
	# ${WinKey} variable and echo it in to the autoinattend.xml file for unattended builds.
	#
	# Globals: RTD_GUI
	# Arguments: None
	# Outputs: A variable named: "${WinKey}" and echoing its contents to standard out.
	# Returns: default exit status of the last command run.
	# Usage: get_Windows_Product_Key
	# End of documentation
	WinKey=$(sudo strings /sys/firmware/acpi/tables/MSDM | tail -1)
	echo "${WinKey}"
}


err_no_menu_system_found() {
	# Description: Function to handle the error condition if a manu system is not found on the system.
	# On occasion it may be neede to display dialog boxes and selection menus even in a terminal.
	# for these cases; dialog, whiptail (newt), or zenity may be needed.
	# This function will attempt to install the desired menu system and if it cannot or the user
	# opts out it will error and exit the script.
	#
	# Globals: RTD_GUI
	# Arguments: None
	# Outputs: Interactive
	# Returns: default exit status of the last command run.
	# Usage:
	# err_no_menu_system_found
	# End of documentation

	write_error " ______________________________________________________________________ \n There is eiter no way to display menus on this system or you have told me \n to install the default  menu system! \n This is required to display the administrative menus... \n \n     ¯\_( ͡👁️ ͜ʖ ͡👁️)_/¯ \n ______________________________________________________________________ \n"
	write_warning "May I attepmpt to install this ability to your system? \a "
	read -p "Add software: (y/n)?" choice
	case "$choice" in
	y|Y )
		: "${RTD_GUI:=$1}"
		for i in dnf yum zypper apt-get; do
			if hash $i 2>/dev/null; then
				$i install $RTD_GUI -y
				if $? eq 0 ;  then
					echo -e $YELLOW"$RTD_GUI installed... exporting..."
					RTD_GUI="dialog --clear"
					export RTD_GUI
					return 0
				fi
			fi
		done
	;;
	n|N ) err_no_menu_system_available ;;
	* ) read -p  "Invalid Selection" && err_no_menu_system_found || exit 1 ;;
	esac
}



oem::rtd_reset_default_environment_config() {
	# Description:
	# Function to reset temporary configurations to their original settings as provided by the distributor. 
	# This is critical for systems initially configured under the RTD OEM load process, which might involve
	# setting less secure or operationally disruptive configurations such as "auto login", "auto sudo", and
	# "auto running scripts". This function reverses these changes to ensure the system adheres to good security
	# practices and is ready for normal operations.
	#
	# Globals:
	#   _OEM_DIR: Specifies the directory used to store backup configurations and caches during the OEM load process.
	#   SUDO_USER: The username of the user who initiated the sudo command. This is used to identify the user's home directory for .bashrc modifications.
	#
	# Arguments: None
	#
	# Outputs:
	#   Prints messages to stdout indicating the actions being taken, including backing up and removing specific
	#   configuration files, and any errors or information relevant to the operation of the function.
	#
	# Returns:
	#   0: If all operations were successful.
	#   1: If an error occurred that prevented the function from completing its task.
	#
	# Usage:
	#   This function should be run with root privileges to ensure it has the necessary permissions to modify system
	#   files and configurations. It does not take any arguments. Before running, ensure that the _OEM_DIR global
	#   variable is set to a valid directory path where backup files can be stored. Here is an example of how to
	#   call this function:
	#
	#   sudo rtd_oem_reset_default_environment_config
	#
	# End of documentation


	# Ensure _OEM_DIR is defined
	if [[ -z "${_OEM_DIR}" ]]; then
		write_error "📁 Error: _OEM_DIR is not set."
		return 1
	fi

	mkdir -p "${_OEM_DIR}/cache/"

	# Backup and remove custom sudoers file
	if [[ -f /etc/sudoers.d/99_sudo_include_file ]]; then
		mv /etc/sudoers.d/99_sudo_include_file "${_OEM_DIR}/cache/"
		write_status "📄 Custom sudoers file has been backed up and removed."
	else
		write_error  "📄 No custom sudoers file found to remove."
	fi

	# Backup the current .bashrc for SUDO_USER
	if [[ -n "${SUDO_USER}" && -f "/home/${SUDO_USER}/.bashrc" ]]; then
		cp "/home/${SUDO_USER}/.bashrc" "${_OEM_DIR}/cache/bashrc"
		write_status "🔑 User .bashrc has been backed up."

		# Remove 'xhost local:root' if it exists in the real .bashrc or its symlink target
		file_path="/home/${SUDO_USER}/.bashrc"
		real_path=$(readlink -f "$file_path")  # -f ensures the real path is returned even if it's not a symlink
		sed -i '/xhost\ local:root/d' "$real_path"
		write_status "📜 Removed 'xhost local:root' from .bashrc."
	else
		write_error  "🚫 Error: SUDO_USER not set or .bashrc not found."
	fi

	if type system::add_or_remove_login_script &>/dev/null ; then
		system::add_or_remove_login_script --remove /etc/xdg/autostart/oem-run.desktop
		write_status "🔑 Login script has been removed."
	else
		write_error  "👺 system::add_or_remove_login_script function not found. Cannot remove login script."
	fi

	if type system::toggle_oem_auto_login &>/dev/null ; then
		system::toggle_oem_auto_login --disable
		write_status "🔑 Auto login has been disabled."
	else
		write_error  "👺 system::toggle_oem_auto_login function not found. Cannot disable auto login."
	fi

	if type system::toggle_oem_auto_elevated_privilege &>/dev/null ; then
		system::toggle_oem_auto_elevated_privilege --disable
		write_status "👑 Auto elevated privilege has been disabled."
	else
		write_error  "👺 system::toggle_oem_auto_elevated_privilege function not found. Cannot disable auto elevated privilege."
	fi

	if type system::set_oem_elevated_privilege_gui &>/dev/null ; then
		system::set_oem_elevated_privilege_gui --disable
		write_status "👑 Elevated privilege GUI has been disabled."
	else
		write_error  "👺 system::set_oem_elevated_privilege_gui function not found. Cannot disable elevated privilege GUI."
	fi
}



system::wait_for_internet_availability() {
	# Description: Function that, when called, will wait for an active internet connection
	# to be available before before continuing. Most softwrare install activities
	# need an active internet connection to be able to install and update software.
	# Naturally, some in house loads use local mirrors, but if you can see the
	# internet, you would have access to your own ropositories as well...
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage: system::wait_for_internet_availability
	# End of documentation

	# Array of IPs for testing internet connectivity (may be set globally)
	local -a test_ips
	if [[ -n "$_OEM_TEST_IPS" ]]; then
		IFS=' ' read -r -a test_ips <<< "$_OEM_TEST_IPS"
	else
		test_ips=("8.8.8.8" "1.1.1.1")
	fi

	local -i max_attempts=10
	local -i attempt=1
	local ip

	write_status "🌐 Checking for internet connectivity..."

	# Do ping test... 
	for ip in "${test_ips[@]}"; do
		# Will partially work only with ping, but try to enusre cmd is available...
		dependency::command_exists curl || _missingcmd="curl"
		dependency::command_exists jq || _missingcmd="jq"
		attempt=1
		while (( attempt <= max_attempts )); do
			if ping -c 1 -W 1 "$ip" &>/dev/null; then
				# Lookup external IP...
				write_status "🌐 Internet ping access confirmed to IP: $ip"
				local response 
				response=$(curl -s https://httpbin.org/ip)
				RTD_INTERNET_IP=$(echo "$response" | jq -r '.origin')
				if [[ -n "$RTD_INTERNET_IP" ]] ; then
					write_status "🌐 Internet access confirmed through IP: $RTD_INTERNET_IP"
					export RTD_INTERNET_IP
				else
					write_status "❗📶 Could not determine external egress IP. Missing: $_missingcmd ?"
				fi
				return 0
			else
				write_status "📶 Attempt $attempt of $max_attempts failed to reach $ip"
				((attempt++))
				sleep 10
			fi
		done
	done

	write_error "❗📶 Unable to confirm internet access after $max_attempts attempts on each tested IP."
	return 1
}



system::io_on_notify_wait() {
	# Description: Function that, when called, will wait for a disk change
	# and then execute the command passed as an argument. This is useful when
	# wanting to keep two location in sync with minimal delay, or to scan
	# for malware as soon as a change has occurred.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage: system::io_on_notify_wait rsync -avt . host:/remote/dir ...
	# End of documentation

	check_dependencies inotify-tools
	EVENTS="CREATE,CLOSE_WRITE,DELETE,MODIFY,MOVED_FROM,MOVED_TO"

	if [ -z "$1" ]; then
		write_error "Usage: $0 rsync -avt . host:/remote/dir ..."
		exit 1;
	fi

	inotifywait -e "$EVENTS" -m -r --format '%:e %f' . | (
		WAITING="";
		while true; do
		LINE="";
		read -t 1 LINE;
		if test -z "$LINE"; then
			if test ! -z "$WAITING"; then
				echo "CHANGE";
				WAITING="";
			fi;
		else
			WAITING=1;
		fi;
		done) | (
		while true; do
		read TMP;
		echo "$@"
		"$@"
		done
	)
}



system::display_spinner() {
	# Description: Simple function to display a spinner in the terminal.
	# Globals:
	# Arguments: start/stop
	# Outputs:
	# Returns:
	# Usage:
	#
	#
	#
	# End of documentation

	function _spinner() {
	# $1 start/stop
	#
	# on start: $2 display message
	# on stop : $2 process exit status
	#           $3 spinner function pid (supplied from stop_spinner)

	local on_success="DONE"
	local on_fail="FAIL"
	local nc="\e[0m"

	case $1 in
		start)
		# calculate the column where spinner and status msg will be displayed
		let column=$(tput cols)-${#2}-46
		# display message and position the cursor in $column column
		# echo -ne ${2}
		printf "%${column}s"

		# start spinner
		i=1
		sp='\|/-'
		delay=${SPINNER_DELAY:-0.15}

		while :
		do
			printf "${RED}\b[${sp:i++%${#sp}:1}]\b\b${ENDCOLOR}"
			sleep $delay
		done
		;;
		stop)
		if [[ -z ${3} ]]; then
			echo "spinner is not running.."
			exit 1
		fi

		kill $3 > /dev/null 2>&1

		# inform the user uppon success or failure
		echo -en "\b["
		if [[ $2 -eq 0 ]]; then
			echo -en "${green}${on_success}${nc}"
		else
			echo -en "${red}${on_fail}${nc}"
		fi
		echo -e "]"
		;;
		*)
		write_error "invalid argument, try {start/stop}"
		exit 1
		;;
	esac
	}

	function start_spinner {
	# $1 : msg to display
	_spinner "start" "${1}" &
	# set global spinner pid
	export _sp_pid=$!
	disown
	}

	function stop_spinner {
	# $1 : command exit status
	_spinner "stop" $1 $_sp_pid
	unset _sp_pid
	}

	if [[ "$1" == "start" ]] ; then
		start_spinner $2
	elif [[ "$1" == "stop" ]] ; then
		stop_spinner $2
	else
		write_error "invalid argument, try {start/stop}"
	fi

}



system::add_or_remove_login_script() {
	# Description: Sets up or removes a .desktop launcher to run a script at login.
	# Arguments:
	#   1. Path to the script to be executed.
	#   2. Optional: Path to the .desktop launcher (default: /etc/xdg/autostart/oem-run.desktop).
	#
	# Usage:
	#   system::add_or_remove_login_script <path>
	#
	# This function is responsible for adding or removing the execution of a script on login.
	# It takes two parameters: the path to the script and an optional file path for the autostart desktop entry.
	# If the script is not found, an error message is displayed and the function returns 1.
	# If the "--remove" option is specified, the function removes the autostart desktop entry file if it exists.
	# If the "--add" option is specified, the function creates or updates the autostart desktop entry file with the script path.
	# If no option is specified, the function checks if the autostart desktop entry file exists.
	# If it exists, the function removes it. If it doesn't exist, the function creates it with the script path.
	# The function returns 0 on success and 1 on failure.
	#
	# Example:
	#   system::add_or_remove_login_script --remove /etc/xdg/autostart/oem-run.desktop
	#   system::add_or_remove_login_script --remove 
	#   system::add_or_remove_login_script --add /path/to/script.sh
	#
	# End of documentation
	local script_path="$2"
	local file_path="${3:-"/etc/xdg/autostart/oem-run.desktop"}"

	if [[ ! -f "${script_path}" ]]; then
			write_error "🚫 Script not found: ${script_path}"
		return 1
	fi

	case "$1" in
		--remove)
			if [[ -e "$file_path" ]]; then
				write_information "🗑️ Removing execution on login of (${file_path})"
				if ! sudo rm "${file_path}"; then
					write_error "🚫 Failed to remove file: ${file_path}"
					return 1
				fi
			else
				write_error "🗑️ File already removed: ${file_path}"
				return 0
			fi
		;;
		--add)
			if hash xterm 2>/dev/null ; then
				write_information "📜 Adding execution on login of (${script_path}) with xterm"
				if ! printf '[Desktop Entry]\nType=Application\nExec=/usr/bin/xterm -fa 'Monospace' -fs 10 -e "sudo -E %s"\nTerminal=false\nHidden=false\nX-GNOME-Autostart-enabled=true\nName=OEM Run\nComment=OEM Setup\n' "$script_path" | sudo tee "$file_path" > /dev/null; then
					write_error "🚫 Failed to create file: ${file_path}"
					return 1
				fi
			else
				write_information "📜 Adding execution on login of (${script_path}) in default term"
				if ! printf '[Desktop Entry]\nType=Application\nExec=sudo -E %s\nTerminal=true\nHidden=false\nX-GNOME-Autostart-enabled=true\nName=OEM Run\nComment=OEM Setup\n' "$script_path" | sudo tee "$file_path" > /dev/null; then
					write_error "🚫 Failed to create file: ${file_path}"
					return 1
				fi
			fi
		;;
		*)
			write_information "📜 Toggeling execution on login of (${script_path})"
			if [[ -e "$file_path" ]]; then
				write_information "🗑️ Removing execution on login of (${file_path})"
				if ! sudo rm "${file_path}"; then
					write_error "Failed to remove file: ${file_path}"
					return 1
				fi
			else
				if hash xterm 2>/dev/null ; then
					write_information "📜 Adding execution on login of (${script_path})"
					if ! printf '[Desktop Entry]\nType=Application\nExec=xterm -e "sudo -E %s"\nTerminal=false\nHidden=false\nX-GNOME-Autostart-enabled=true\nName=OEM Run\nComment=OEM Setup\n' "$script_path" | sudo tee "$file_path" > /dev/null; then
						write_error "🚫 Failed to create file: ${file_path}"
						return 1
					fi
				else
					write_information "📜 Adding execution on login of (${script_path})"
					if ! printf '[Desktop Entry]\nType=Application\nExec=sudo -E %s\nTerminal=true\nHidden=false\nX-GNOME-Autostart-enabled=true\nName=OEM Run\nComment=OEM Setup\n' "$script_path" | sudo tee "$file_path" > /dev/null; then
						write_error "🚫 Failed to create file: ${file_path}"
						return 1
					fi
				fi
			fi
		;;
	esac
}



system::update_config() {
	# Description: This function updates a configuration file with key-value pairs.
	# The `system::update_config` function is designed to update a configuration file 
	# with key-value pairs. It takes as parameters the path to the configuration
	# file and the key-value pairs to be updated or added to the configuration file. 
	# If the key already exists in the configuration file, the value is updated.
	# If the key does not exist in the configuration file, the key-value pair is added.
	# Globals:
	# Arguments: config_file key-value pairs
	# Outputs: The configuration file with the updated key-value pairs.
	# Returns: None
	# Usage: system::update_config /home/user/.config/myapp/config.conf key1 value1 key2 value2
	#
	# Parameters:
	#   - config_file: The path to the configuration file.
	#   - key-value pairs: The key-value pairs to be updated or added to the configuration file.
	# Returns: None
	# 
	# Example: 
	# 
	# system::update_config /home/user/.config/myapp/config.conf key1 value1 key2 value2
	#
	# End of documentation

	local config_file=$1
	shift  # Shift past the first argument (the config file path)
	system::log_item "📔 Updating configuration file with key-value pairs: $*"
	mkdir -p ${config_file%/*}  ; touch $config_file || system::log_item "Failed to create config file: $config_file"
	
	while (( "$#" )); do
		local key=$1
		local value=$2
		shift 2  # Shift past the processed key-value pair

		if grep -q "^$key=" "$config_file"; then
			system::log_item "📔 Update existing entry $key=$value in $config_file"
			sed -i "s|^$key=.*|$key=$value|" "$config_file"
		else
			system::log_item "📔 Add new entry $key=$value to $config_file"
			echo "$key=$value" >> "$config_file"
		fi
	done
}




system::read_config() {
	# Description: This function reads a configuration file with key-value pairs.
	# The configuration file should contain one key-value pair per line, with the
	# key and value separated by an equals sign.
	# Globals:
	# Arguments: config_file (path to configuration file)
	# Outputs:
	# Returns: standard exit code
	# Usage: system::read_config /home/user/.config/myapp/config.conf
	#
	# Parameters:
	#   - config_file: The path to the configuration file.
	#   
	# Returns: None
	# 
	# Example:
	#   system::read_config "/home/user/.config/myapp/config.conf" 
	#
	# End of documentation
        # Specify the path to your configuration file
        local config_file=$1

        system::log_item "📖 Reading configuration file: $config_file"
        # Read each line in the configuration file
        while IFS='=' read -r key value; do
                if [[ $key && $value ]]; then
                        # Use declare to safely assign value to the variable named by 'key'
                        declare -g "$key=$value"
                        system::log_item "📖 Read key-value pair: $key=$value"
                fi
        done < "$config_file"
}



system::toggle_oem_auto_login() {
	# Description: Function to toggle auto login for admin purposes.
	#
	# This function toggles automatic login for various display managers. It is designed to enable or disable 
	# auto-login for administrative purposes, such as performing interactive administrative logins and 
	# running configuration scripts. This function supports a range of popular display managers and 
	# applies SUSE-specific configurations when necessary.
	#
	# Globals:
	# None. The function does not depend on or modify any global variables.
	#
	# Arguments:
	# None. The function does not take any arguments.
	#
	# Outputs:
	# The function outputs status messages, warnings, and error information using the write_status, 
	# write_warning, write_information, and write_error functions. These messages indicate the actions 
	# being taken (e.g., enabling or disabling auto-login) and any issues encountered.
	#
	# Returns:
	# None. The function does not return a value.
	#
	# Usage:
	#
	# Call toggle_oem_auto_login without any arguments to toggle the auto-login feature. For example:
	#
	# toggle_oem_auto_login
	#
	# This will enable auto-login if it is currently disabled, or disable it if it is currently enabled.
	#
	# Function Behavior:
	#
	#     It proceeds to check for the 
	#     presence of configuration files for LightDM, SDDM, GDM3, and GDM. For each display manager found, 
	#     the function toggles the auto-login setting. If auto-login is enabled, it will disable it, and vice versa.
	#     In the case of SUSE, the function modifies the SUSE-specific display manager file in /etc/sysconfig/ 
	#     instead of the individual display manager configuration files.
	#     The function also handles toggling auto-login for terminal environments (TTY) without a graphical user interface.
	#
	# Special Notes:
	#
	#     This function should be used with caution as enabling auto-login can have security implications.
	#     It is particularly useful for scenarios like OEM setup or automatic template generation for KVM.
	#     The function assumes that the current user has the necessary permissions to modify system configuration files.
	#
	# Implementation Details:
	#
	#     The function uses conditional checks to determine the presence of various display manager configuration files.
	#     Backup files with the suffix .rtd-bak are used to preserve the original configuration before making changes.
	#
	# End of documentation

	case $1 in
		--help|-h)
			write_information "usage : sysetm::toggle_oem_auto_login [--enable|--disable]"
			return
			;;
		--enable|-e)
			write_status "🚧 Enabling auto login as requested by - ${FUNCNAME[1]}"
			local _flip=on
			;;
		--disable|-d)
			write_status "🚧 Disabling auto login as requested by ${FUNCNAME[1]}"
			local _flip=off
			;;
		*)	
			write_status "🚧 Toggling auto login..."
			;;
	esac

	# Create a backup directory if it does not exist
	mkdir -p /etc/${_TLA,,}/backup
	local _backup_dir="/etc/${_TLA,,}/backup"
	
	# Toggle auto login for Light DM if present (Old Ubuntu, Mint?, Budgie? etc.)
	if [[ -f /etc/lightdm/lightdm.conf ]]; then
		local _config_file="/etc/lightdm/lightdm.conf"
		case $_flip in 
		off )
			write_status "⛔ LightDM: toggeling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ LightDM: toggeling auto login on... *******"
			cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak
			cat > ${_config_file} <<-OEM_LXDM_LOGIN_OPTION
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up:
			# ${_backup_dir}/${_config_file##*/}.rtd-bak
			# If this file is not there, then it was not there to begin with
			# and you can delete this file.
			[SeatDefaults]
			autologin-user=${_OEM_USER:-"tangarora"}
			autologin-user-timeout=0
			OEM_LXDM_LOGIN_OPTION
			;;
		esac
		local toggle=done
	fi

	# Toggle auto login for SDDM if present (Kubuntu, SUSE, KDE Based DE's)
	if [[ -f /etc/sddm.conf ]]; then
		local _config_file="/etc/sddm.conf"
		case $_flip in 
		off )
			write_status "⛔ SDDM: toggeling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ SDDM: toggeling auto login on... *******"
			cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak
			cat > ${_config_file} <<-OEM_SDDM_LOGIN_OPTION
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up:
			# ${_backup_dir}/${_config_file##*/}.rtd-bak
			# If this file is not there, then it was not there to begin with
			# and you can delete this file.
			[Autologin]
			User=${_OEM_USER:-"tangarora"}
			Session=plasma.desktop
			OEM_SDDM_LOGIN_OPTION
			;;
		esac
		local toggle=done
	fi

	# Toggle auto login for GDM3 if present (Ubuntu, default etc.)
	if [[ -f /etc/gdm3/custom.conf ]]; then
		local _config_file="/etc/gdm3/custom.conf"
		case $_flip in
		off )
			write_status "⛔ GDM3: toggeling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ GDM3: toggeling auto login on... *******"
			cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak
			cat >  ${_config_file} <<-OEM_GDM3_LOGIN_OPTION
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up:
			# ${_backup_dir}/${_config_file##*/}.rtd-bak
			# If this file is not there, then it was not there to begin with
			# and you can delete this file.
			[daemon]
			AutomaticLoginEnable=True
			AutomaticLogin=${_OEM_USER:-"tangarora"}
			OEM_GDM3_LOGIN_OPTION
			;;
		esac
		local toggle=done
	fi

	# Toggle auto login for GDM3 if present (Debian and others...)
	if [[ -f /etc/gdm3/daemon.conf ]]; then
		local _config_file="/etc/gdm3/daemon.conf"
		case $_flip in
		off )
			write_status "⛔ GDM3: toggeling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ GDM3: toggeling auto login on... *******"
			cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak
			cat >  ${_config_file} <<-OEM_GDM3_LOGIN_OPTION
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up:
			# ${_backup_dir}/${_config_file##*/}.rtd-bak
			# If this file is not there, then it was not there to begin with
			# and you can delete this file.
			[daemon]
			AutomaticLoginEnable=True
			AutomaticLogin=${_OEM_USER:-"tangarora"}
			OEM_GDM3_LOGIN_OPTION
			;;
		esac
		local toggle=done
	fi

	# Toggle auto login for GDM per gnome standard (Fedora et. al.)
	if [[ -f /etc/gdm/custom.conf ]]; then
		local _config_file="/etc/gdm/custom.conf"
		case $_flip in
		off )
			write_status "⛔ GDM: toggeling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ GDM: toggeling auto login on... *******"
			cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak
			cat >  ${_config_file} <<-OEM_GDM_LOGIN_OPTION
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up:
			# ${_backup_dir}/${_config_file##*/}.rtd-bak
			# If this file is not there, then it was not there to begin with
			# and you can delete this file.
			# GDM configuration storage

			[daemon]
			WaylandEnable=false
			AutomaticLoginEnable=True
			AutomaticLogin=${_OEM_USER:-"tangarora"}

			[security]

			[xdmcp]

			[chooser]

			[debug]
			OEM_GDM_LOGIN_OPTION
			;;
		esac
		local toggle=done
	fi

	# Special case for SUSE...
	if [[ -e /etc/sysconfig/displaymanager ]] ; then
	local _config_file="/etc/sysconfig/displaymanager"
	
	case $_flip in
		off )
			write_status "⛔ SUSE: toggling auto login off... *******"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ SUSE: toggling auto login on... *******"
			
			if grep -q 'DISPLAYMANAGER_AUTOLOGIN="${_OEM_USER:-"tangarora"}"' ${_config_file} && grep -q 'DISPLAYMANAGER_PASSWORD_LESS_LOGIN="yes"' ${_config_file}; then
				echo "auto login is already enabled"
				# Another quirk of SUSE is that sddm.conf is there but not used, it does prevent autologin from working tough...
				mv /etc/sddm.conf ${_backup_dir}/sddm.conf.rtd-bak
			else
				# Another quirk of SUSE is that sddm.conf is there but not used, it does prevent autologin from working tough...
				mv /etc/sddm.conf ${_backup_dir}/sddm.conf.rtd-bak
				cp ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak || write_error "❗💾 Could not backup: ${_config_file}! "
				sed -i 's/DISPLAYMANAGER_AUTOLOGIN=""/DISPLAYMANAGER_AUTOLOGIN="${_OEM_USER:-"tangarora"}"/' ${_config_file} || write_error "❗📄 Could not write to file: ${_config_file}!"
				sed -i 's/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="no"/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="yes"/' ${_config_file} || write_error "❗📄 Could not write to file: ${_config_file}!"
			fi
			;;
	esac
	
	local toggle=done
	fi



	# Toggle auto login for Terminal target env. (no GUI).
	if [[ ! -f /etc/systemd/system/getty@tty1.service.d/override.conf ]]; then
		local _config_file="/etc/systemd/system/getty@tty1.service.d/override.conf"
		case $_flip in
		off )
			write_status "⛔ TTY: toggeling auto login off... ********"
			if rm ${_config_file} && mv ${_backup_dir}/${_config_file##*/}.rtd-bak ${_config_file} ; then
				write_status "💾 Restored previous configuration..."
			else
				write_error "❗💾 Could not restore old config: ${_config_file}! Perhaps a backup was not done?"
			fi
			;;
		on )
			write_status "✅ TTY: toggeling auto login on... ********"
			mkdir -p ${_config_file%/*}
			mv ${_config_file} ${_backup_dir}/${_config_file##*/}.rtd-bak 
			cat >  ${_config_file} ${_config_file} <<-OEM_TTY_LOGIN_OPTION
			"[Service]"
			"ExecStart="
			"ExecStart=-/sbin/agetty --noissue --autologin ${_OEM_USER:-"tangarora"} %I $TERM"
			"Type=idle"
			OEM_TTY_LOGIN_OPTION
			;;
		esac
	fi

	if [[ -z $toggle ]] ; then
		write_error "❗🚫 No display manager found to toggle auto login!"
		write_error "trying sddm, lightdm, gdm3, gdm, and suse..."
		local _config_file="/etc/sddm.conf"
		cat > ${_config_file} <<-OEM_SDDM_LOGIN_OPTION
		# This configuration file was created by RTD Setup.
		[Autologin]
		User=${_OEM_USER:-"tangarora"}
		Session=plasma.desktop
		OEM_SDDM_LOGIN_OPTION
		unset toggle
		return 0
	fi
}



system::set_oem_elevated_privilege_gui() {
	# Description
	# This function configures the local X environment to allow root to display GUI applications. 
	# It is particularly useful for Debian and other Linux distributions where GUI apps cannot 
	# be run under sudo or in a root environment by default. This function modifies the .bashrc 
	# files for the specified user and root to enable GUI applications to be launched with elevated 
	# privileges. It is compatible with distributions like Slackware and Debian.
	#
	# Globals:
	#
	#     $_OEM_USER: The username for whom the X environment will be configured. 
	#
	# Arguments:
	#
	# None. The function does not take any arguments.
	#
	# Outputs:
	#
	# The function modifies the .bashrc file in the home directory of $_OEM_USER and the root user 
	# to configure the X environment. It outputs information about the changes being made.
	#
	# Returns:
	#
	# None. The function does not return a value.
	#
	# Usage:
	#
	# To use this function, ensure that the $_OEM_USER global variable is set to the appropriate username, 
	# then call the function:
	#
	# _OEM_USER="username"
	# set_oem_elevated_privilege_gui
	#
	# This will append the necessary configurations to the .bashrc files of the specified user and the root user.
	# Function Behavior:
	#
	#     The function appends xhost local:root to the .bashrc file in the home directory of $_OEM_USER. 
	#     This command allows the root user to display GUI applications on the local X server.
	#     It also appends export XAUTHORITY=/home/${_OEM_USER}/.Xauthority to /root/.bashrc. This export 
	#     sets the XAUTHORITY environment variable for the root user, pointing to the .Xauthority file in 
	#     the home directory of $_OEM_USER.
	#
	# End of documentation


	local user_bashrc="/home/${_OEM_USER:-"tangarora"}/.bashrc"
	local root_bashrc="/root/.bashrc"

	case $1 in
	--help|-h)
		write_information "usage : system::set_oem_elevated_privilege_gui [--enable|--disable]"
		return
		;;
	--enable|-e)
		write_status "🚧 Enabling GUI elevated privileges..."

		# Ensure the commands are idempotent: don't add lines if they already exist
		grep -qxF 'xhost local:root' "${user_bashrc}" || echo "xhost local:root" >> "${user_bashrc}"
		grep -qxF "export XAUTHORITY=/home/${_OEM_USER:-"tangarora"}/.Xauthority" "${root_bashrc}" || echo "export XAUTHORITY=/home/${_OEM_USER:-"tangarora"}/.Xauthority" >> "${root_bashrc}"

		write_information "🚧 Editing bashrc: xhost local:root in ${user_bashrc}"
		write_information "🚧 Editing bashrc: export XAUTHORITY=/home/${_OEM_USER:-"tangarora"}/.Xauthority in ${root_bashrc}"
		;;
	--disable|-d)
		write_status "🚧 Disabling GUI elevated privileges..."

		# Use sed to remove the specific lines added during the enable step
		sed -i '/xhost local:root/d' "${user_bashrc}"
		sed -i "/export XAUTHORITY=\/home\/${_OEM_USER:-"tangarora"}\/.Xauthority/d" "${root_bashrc}"

		write_information "🚧 Removed xhost command from ${user_bashrc}"
		write_information "🚧 Removed XAUTHORITY export from ${root_bashrc}"
		;;
	*)
		write_status "👽 Un-known option. Use --enable to enable or --disable to disable GUI elevated privileges."
		;;
	esac
}



system::toggle_oem_auto_elevated_privilege() {
	# Description: Toggles passwordless sudo privileges for a specified user.
	# WARNING: This function modifies sudoers and can pose a security risk.
	# Ensure to disable this with 'rtd_oem_reset_default_environment_config' after use.
	# Globals:
	#   _OEM_USER - The user for whom to toggle passwordless sudo. Defaults to SUDO_USER.
	# Arguments: None
	# Usage:
	#   system::toggle_oem_auto_elevated_privilege [--enable|--disable]

	: ${_OEM_USER:="${SUDO_USER}"}
	local sudoers_file="/etc/sudoers.d/99_sudo_include_file"

	if [[ -z "${_OEM_USER}" ]]; then
		write_error "⛔ Error: User not specified for elevated privileges."
		return 1
	fi

	case ${1} in
	--help|-h)
		write_information "usage : system::toggle_oem_auto_elevated_privilege [--enable|--disable]"
		return
		;;
	--enable|-e)
		write_status "🚧 Enabling passwordless sudo for user: ${_OEM_USER}"
		# Ensure passwordless sudo is not already set for the user
		if ! sudo grep -q "^${_OEM_USER} ALL=(ALL) NOPASSWD:ALL" "${sudoers_file}" 2>/dev/null; then
			# Add passwordless sudo entry
			write_information "🚧 Adding passwordless sudo for user: ${_OEM_USER}"
			echo "${_OEM_USER} ALL=(ALL) NOPASSWD:ALL" | sudo EDITOR='tee -a' visudo -f "${sudoers_file}"
		else
			write_information "✅ Passwordless sudo already enabled for user: ${_OEM_USER}"
		fi
		;;
	--disable|-d)
		write_status "🚧 Disabling passwordless sudo for user: ${_OEM_USER}"
		# Check if passwordless sudo is set for the user and remove it
		if sudo grep -q "^${_OEM_USER} ALL=(ALL) NOPASSWD:ALL" "${sudoers_file}" 2>/dev/null; then
			# Remove passwordless sudo entry
			write_information "🚧 Removing passwordless sudo for user: ${_OEM_USER}"
			sudo sed -i "/^${_OEM_USER} ALL=(ALL) NOPASSWD:ALL/d" "${sudoers_file}"
		else
			write_information "✅ Passwordless sudo already disabled for user: ${_OEM_USER}"
		fi
		;;
	*)
		write_status "👽 Unknown option. Use --enable to enable or --disable to disable passwordless sudo."
		return 1
		;;
	esac

	# Validate sudoers file syntax
	if [[ -f "${sudoers_file}" ]]; then
		write_information "🚧 Validating sudoers file syntax..."
		if ! sudo visudo -cf "${sudoers_file}" &>/dev/null; then
			write_error "⛔ Error: Syntax error in sudoers file."
		else
			write_information "🏆 Sudoers file syntax is valid."
		fi
	else
		write_status "🔍 ${sudoers_file} not present."
	fi

	write_information "🚧 Passwordless sudo configuration updated for ${_OEM_USER}."
}


system::make_system_recovery_partition() {
	# Description: Incomplete function to build an OEM rescue partition...
	# Function to enable system OEM Recovery
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage: NOTE: I have yet to figura out how to do this!

	# End of documentation



	# Find removable devices that are not loops or CD/DVD drives
	readarray -t devlist < <(lsblk -dnlo name,rm | awk '$2 == "1" {print $1}')

	if [[ ${#devlist[@]} -eq 0 ]]; then
		# No removable media found
		DIALOGRC="/root/.dialogrc"
		[[ -e $DIALOGRC ]] && mv "$DIALOGRC" "${DIALOGRC}.bak"
		echo 'screen_color = (CYAN,RED,ON)' > "$DIALOGRC"
		dialog --title "Error!" --backtitle "OS Media Manager" --msgbox "No removable media found!" 14 90
		rm -f "$DIALOGRC"
		[[ -e ${DIALOGRC}.bak ]] && mv "${DIALOGRC}.bak" "$DIALOGRC"
		return 1
	fi

	# If only one removable device is found, use it directly
	if [[ ${#devlist[@]} -eq 1 ]]; then
		local targetDevice="/dev/${devlist[0]}"
	else
		# If multiple devices are found, let the user choose
		local menuOptions=()
		for dev in "${devlist[@]}"; do
		menuOptions+=("$dev" "$(fdisk -l /dev/$dev | head -1)")
		done
		targetDevice=$(dialog --stdout --title "Choose a device" --menu "Select target device:" 0 0 0 "${menuOptions[@]}")
		targetDevice="/dev/$targetDevice"
	fi

	if [[ -z $targetDevice ]]; then
		echo "No device selected or dialog cancelled."
		return 1
	fi

	echo "Using device: $targetDevice for recovery partition."

	mkdir -p /boot/iso
	if dd if="$targetDevice" of=/boot/iso/recovery.iso status=progress; then
		echo "Recovery image created successfully."
	else
		echo "Failed to create recovery image."
		return 1
	fi

	# Append custom GRUB entry
	cat >> /etc/grub.d/40_custom <<-EOF
	menuentry "Reset to Factory Defaults" {
	set isofile="/boot/iso/recovery.iso"
	loopback loop (hd0,1)\$isofile
	linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=\$isofile noprompt noeject
	initrd (loop)/casper/initrd.lz
	}
	EOF

    	echo "GRUB menu entry added. Please update GRUB configuration with 'update-grub'."
}



system::rtd_oem_reseal() {
	# Description: 
	# Function to reseal a newly installed system for delivery to end user.
	# Globals: The distribution must have an OEM reseal function or software available.
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:

	# End of documentation
	if cat /etc/os-release |grep ubuntu ; then
		software::add_native_package "oem-config-gtk"
		oem-config-prepare
		if hash virt-what 2>/dev/null ; then
			system::log_item "💻 This is a virtual machine. Shutting down..."
			apt-get -y install qemu-guest-agent
			apt-get -y install spice-vdagent
			shutdown -h now
		else
			system::log_item "💻 This is a physical machine. Shutting down..."
			shutdown -h now
		fi
	elif cat /etc/os-release |grep kubuntu ; then
		software::add_native_package "oem-config-gtk"
		oem-config-prepare
		if hash virt-what 2>/dev/null ; then
			system::log_item "💻 This is a virtual machine. Shutting down..."
			apt-get -y install qemu-guest-agent
			apt-get -y install spice-vdagent
			shutdown -h now
		else
			system::log_item "💻 This is a physical machine. Shutting down..."
			shutdown -h now
		fi
	elif cat /etc/os-release |grep suse ; then
		system::log_item "👽 I dont know of any OEM configuration for SuSE"
	elif cat /etc/os-release |grep fedora ; then
		system::log_item "🤞 BETA: I dont know of any OEM configuration for Fedora... trying anyhow... "
		tee /usr/local/bin/custom-oem-setup.sh <<-'EOF'
		#!/bin/bash

		# Example task: prompt for creating a new user account
		echo "Creating a new user account..."
		read -p "Enter username: " username
		useradd -m "$username"
		passwd "$username"

		# Disable this service so it doesn't run again
		systemctl disable custom-oem-setup.service
		EOF
		chmod +x /usr/local/bin/custom-oem-setup.sh

		tee /etc/systemd/system/custom-oem-setup.service <<-'EOF'
		[Unit]
		Description=Custom OEM Setup
		After=multi-user.target

		[Service]
		Type=oneshot
		ExecStart=/usr/local/bin/custom-oem-setup.sh

		[Install]
		WantedBy=multi-user.target
		EOF

		sudo systemctl enable custom-oem-setup.service
		shutdown -h now
	else
		system::log_item "🤷‍♀️ I dont know of any OEM configuration for this distribution"
	fi
}



system::rtd_oem_find_live_release() {
	# Description: This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
	# 3 parameters are required for this function to know what to do: distro_version/distro_flavor/live_or_not
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns: Return a URL to the desired release ISO of Ubuntu or Debian.
	# Usage:
	# Example:
	# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env (only Debian)
	# system::rtd_oem_find_live_release 	      10              debian         live           kde
	# system::rtd_oem_find_live_release 	      10              debian         live           cinnamon
	# system::rtd_oem_find_live_release 	      10              debian         net            ssh-server
	# system::rtd_oem_find_live_release 	      19.04.2         ubuntu         live
	# End of documentation
	# local distro_version="${1:-12}"
	# local distro_flavor="${2:-debian}"
	# local live_or_not="${3:-live}"
	# local desktop_env="${4:-standard}"

	while [[ $# -gt 0 ]]; do
		case "$1" in
		--server|-s)
			live_or_not="server"
			system::log_item "🐧 Requested [server]..."
			shift
			;;
		--netinst|-n)
			live_or_not="netinst"
			system::log_item "🐧 Requested [netinst]..."
			shift
			;;
		--mini|-m)
			live_or_not="mini"
			system::log_item "🐧 Requested [mini]..."
			shift
			;;
		--desktop|-d)
			live_or_not="desktop"
			system::log_item "🐧 Requested [desktop]..."
			shift
			;;
		--distribution|-dist)
			distro_flavor="$2"
			system::log_item "🐧 Requested distribution [$2]..."
			shift
			;;
		--version|-v)
			distro_version="$2"
			system::log_item "🐧 Requested version [$2]..."
			shift
			;;
		--help|-h)
			echo "Usage: system::rtd_oem_find_live_release --distribution <debian|ubuntu> --version <version number> --server --desktop "
			return 0
			;;
		*)
			shift
		;;
		esac
	done

	case "$distro_flavor" in
	Ubuntu | ubuntu | ubuntu-desktop | Ubuntu-desktop)
		case "$live_or_not" in
		desktop | live)
			system::log_item "🌐 Providing requested URL: http://releases.ubuntu.com/${distro_version}/$(curl --silent http://releases.ubuntu.com/${distro_version}/SHA256SUMS | grep -o 'ubuntu-.*-desktop-amd64.iso')"
			echo "http://releases.ubuntu.com/${distro_version}/$(curl --silent http://releases.ubuntu.com/${distro_version}/SHA256SUMS | grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | server-desktop )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			system::log_item "🌐 Providing requested URL: http://releases.ubuntu.com/${distro_version}/ubuntu-${distro_version}-live-server-amd64.iso"
			echo "http://releases.ubuntu.com/${distro_version}/ubuntu-${distro_version}-live-server-amd64.iso"

		;;
		* )
			system::log_item "⛔ Encountered an error: The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not"
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				system::log_item "⛔ Encountered an error: The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not "
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
			system::log_item "⛔ Encountered an error: The 2nd parameter netinst  debian is not logical. Please use the kernel params instead."
		;;
		* )
			system::log_item "⛔ Encountered an error: The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not"
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "⛔ ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
	;;
	esac
}



system::cleanup_and_finish() {
	# Description: Function to remove all temporary file locations left over from building
	# the new netinstall ISO etc. and clean  up some variables...
	# go back to initial directory
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# End of documentation

	cd "$current_dir" && echo "returned to $current_dir" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$tmp_download_dir"
	rm -r "$tmp_disc_dir"
	rm -r "$tmp_initrd_dir"
	rm -r "$script_dir/custom"

	if [[  "$1" != "nomessage" ]]; then
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $put_iso_file_here_when_done/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else
		echo "Cleanup..."
	fi

	unset bin_7z
	unset bin_xorriso
	unset bin_cpio
	unset isohdpfx_bin
	unset VOLUME_TITLE
	unset target_iso_file_name
	unset _SOURCE_ISO_URL
	unset ssh_public_key_file
	unset PRESEED_TEMPLATE
	unset CONFIG
	unset PRESEED_FILE
	unset SRVorVDI
	clear
	return
}



generate_report_disk_space_used_by_directory() {
	# Description: Function to generate a report for folders' disk space use.
	# This function requres one argument; what root folder to analyse the directories in.
	# This functio will return a report contained in the variable $return that may then be used.
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# Example:
	# generate_report_disk_space_used_by_directory /home
	#
	# This will generate a report on the disk space per directory in the /home folder.
	#
	# End of documentation

	DIRS=$( ls $1 )
	store=/$tmp/out.ct
	$RTD_GUI --backtitle "$BRANDING" --title "📋 Generating report for: $1" --gauge "Calculating disk space: this may take some time" $HEIGHT $WIDTH < <(
		echo "Storage Utilization Report:" >>$store
		echo "______________________________" >>$store
		n=$(ls $1 | wc -l )
		i=0
		for f in $DIRS
		do
			du -cksh $1/$f 2>/dev/null | grep -v total >>$store
			PCT=$(( 100*(++i)/n ))
			cat <<-EOF
			XXX
			$PCT
			Completed calculation for: "$f"...
			XXX
			EOF
			sleep 1
		done
	)
	total=$(echo ----- >>$store && du -cksh $1 2>/dev/null |grep total >>$store) | $RTD_GUI --backtitle "$BRANDING" --title "Completing report..." --progressbox "Working..." $HEIGHT $WIDTH
	result="$(cat $store )" ; rm $store
}



set_gnome_ui_common_tweaks_for_user() {
	# Description:
	# Configure Gnome for OEM look and feel. This is completely as desired.
	# This function takes no arguments. Simply call it to make the changes.
	# Howerver, this function must be called as the user it should apply to.
	# if it is called in a script with "sudo" priviledges, it will make chages to
	# the look and feel for the "root" user.
	#
	# To run this function as the user who started a script with sudo script content
	# could be echoed out ot a temporary file and executed as follows
	# sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus temporary_script.sh > /dev/null 2>&1
	# or alternatively by calling the function "system::run_command_in_gnome_user_session /path/to/temorary_script.sh".
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	#
	# USAGE:
	#
	# set_gnome_ui_common_tweaks_for_user
	#
	# End of documentation

	write_status "📐 Seting common OEM tweaks..."
	# Terminal and Tilix Dark Theme
		GNOME_TERMINAL_PROFILE=$(gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}')
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency false
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000
		if fc-list | grep -i SauceCodePro ; then 
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'SauceCodePro Nerd Font 12'
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

		else 
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 12'
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
			gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

		fi

	# Better Font Smoothing
		gsettings set org.gnome.settings-daemon.plugins.xsettings antialiasing 'rgba'

	# Usability Improvements
		gsettings set org.gnome.desktop.peripherals.mouse accel-profile 'adaptive'
		gsettings set org.gnome.desktop.sound allow-volume-above-100-percent true
		gsettings set org.gnome.desktop.calendar show-weekdate true
		gsettings set org.gnome.desktop.wm.preferences resize-with-right-button true
		gsettings set org.gnome.desktop.wm.preferences button-layout 'appmenu:minimize,maximize,close'
		gsettings set org.gnome.shell.overrides workspaces-only-on-primary false

	# This indexer is nice, but can be detrimental for laptop users battery life
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery false
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery-first-time false
		gsettings set org.freedesktop.Tracker.Miner.Files throttle 15

	# Configure Dash to Dock
		gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM'
		gsettings set org.gnome.shell.extensions.dash-to-dock apply-custom-theme false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-background-color false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots true
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots-color '#729fcf'
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink true
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true
		gsettings set org.gnome.shell.extensions.dash-to-dock force-straight-corner false
		gsettings set org.gnome.shell.extensions.dash-to-dock icon-size-fixed true
		gsettings set org.gnome.shell.extensions.dash-to-dock intellihide-mode 'ALL_WINDOWS'
		gsettings set org.gnome.shell.extensions.dash-to-dock isolate-workspaces true
		gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true
		gsettings set org.gnome.shell.extensions.dash-to-dock unity-backlit-items false
		gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode 'FIXED'
		gsettings set org.gnome.shell.extensions.dash-to-dock running-indicator-style 'SEGMENTED'
		gsettings set org.gnome.shell.extensions.dash-to-dock background-opacity 0.70000000000000000
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false

	# Configure dash-to-panel
		temporary_script=$(mktemp)
		chmod 777 ${temporary_script}
		cat > ${temporary_script} <<-'EOF_D2P'
		[org/gnome/shell/extensions/dash-to-panel]
		appicon-margin=4
		appicon-padding=4
		available-monitors=[0]
		dot-color-1='#5294e2'
		dot-color-2='#5294e2'
		dot-color-3='#5294e2'
		dot-color-4='#5294e2'
		dot-color-dominant=false
		dot-color-override=true
		dot-color-unfocused-1='#5294e2'
		dot-color-unfocused-2='#5294e2'
		dot-color-unfocused-3='#5294e2'
		dot-color-unfocused-4='#5294e2'
		dot-color-unfocused-different=false
		dot-style-focused='METRO'
		dot-style-unfocused='SEGMENTED'
		focus-highlight-color='#eeeeee'
		focus-highlight-dominant=true
		force-check-update=true
		group-apps=true
		hotkeys-overlay-combo='TEMPORARILY'
		isolate-monitors=false
		isolate-workspaces=false
		panel-element-positions='{"0":[{"element":"showAppsButton","visible":true,"position":"stackedTL"},{"element":"activitiesButton","visible":false,"position":"stackedTL"},{"element":"leftBox","visible":true,"position":"stackedTL"},{"element":"taskbar","visible":true,"position":"stackedTL"},{"element":"centerBox","visible":true,"position":"stackedBR"},{"element":"rightBox","visible":true,"position":"stackedBR"},{"element":"dateMenu","visible":true,"position":"stackedBR"},{"element":"systemMenu","visible":true,"position":"stackedBR"},{"element":"desktopButton","visible":false,"position":"stackedBR"}]}'
		secondarymenu-contains-showdetails=true
		show-appmenu=false
		show-favorites=true
		show-favorites-all-monitors=false
		stockgs-keep-dash=false
		stockgs-keep-top-panel=false
		trans-use-custom-bg=false
		trans-use-custom-opacity=true
		tray-size=0
		EOF_D2P
		dconf load / < ${temporary_script} && rm ${temporary_script}

	# Nautilus (File Manager) Usability
		gsettings set org.gnome.nautilus.icon-view default-zoom-level 'standard'
		gsettings set org.gnome.nautilus.preferences executable-text-activation 'ask'
		gsettings set org.gtk.Settings.FileChooser sort-directories-first true
		gsettings set org.gnome.nautilus.list-view use-tree-view true
		gsettings set org.gnome.nautilus.list-view default-zoom-level 'small'

	# Set the GNOME Shell Apps Dashboard sort app in categories based on the FreeDesktop standard.
		gsettings set org.gnome.desktop.app-folders folder-children "['accessories', 'chrome-apps', 'games', 'graphics', 'internet', 'office', 'programming', 'science', 'sound---video', 'system-tools', 'universal-access', 'wine', 'OEM', '3D-Printing', 'Cloud']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ name "Accessories"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ categories "['Utility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ name "Chrome Apps"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ categories "['chrome-apps']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ name "Games"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ categories "['Game']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ name "Graphics"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ categories "['Graphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ name "Internet"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ categories "['Network', 'WebBrowser', 'Email']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ name "Office"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ categories "['Office']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ name "Programming"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ categories "['Development']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ name "Science"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ categories "['Science']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ name "Sound & Video"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ categories "['AudioVideo', 'Audio', 'Video']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ name "System Tools"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ categories "['System', 'Settings']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ name "Universal Access"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ categories "['Accessibility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ name "Wine"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ categories "['Wine', 'X-Wine', 'Wine-Programs-Accessories']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ name "OEM"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ categories "['OEM']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ name "3D-Printing"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ categories "['3D-Printing', 'CAD', '3D', '3DGraphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ name "Cloud"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ categories "['Cloud-Management', 'Cloud', 'aws', 'azure', 'gcp']"

	# Add Tilix configuration and shell definitions
		mkdir -p ~/.config/rtd
		cat > ~/.config/rtd/gconf-tilix-settings.ini <<-'EOF_TLX'
		[com/gexperts/Tilix]
		quake-specific-monitor=0
		quake-width-percent=90
		terminal-title-style='small'
		theme-variant='dark'
		warn-vte-config-issue=false

		[com/gexperts/Tilix/profiles]
		list=['2b7c4080-0ddd-46c5-8f23-563fd3ba789d', 'd6401d4b-4b26-42ec-918a-2e7dc977118d', '8000e9d6-6f21-4a4e-a122-ac45607b56f5', '5283b4cf-faa5-4aef-afcd-a29fd5e0335a', '75b21a4c-150c-4f7a-a093-9faaa19626e2', '1824e1f9-3b7e-48d2-b06a-709239d1d6d9']

		[com/gexperts/Tilix/profiles/1824e1f9-3b7e-48d2-b06a-709239d1d6d9]
		background-color='#272822'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#F8F8F2'
		highlight-colors-set=false
		palette=['#272822', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F8F8F2', '#75715E', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F9F8F5']
		use-theme-colors=false
		visible-name='Monokai'

		[com/gexperts/Tilix/profiles/2b7c4080-0ddd-46c5-8f23-563fd3ba789d]
		background-color='#000000000000'
		background-transparency-percent=10
		badge-color='#AC7EA8'
		badge-color-set=true
		bold-color-set=false
		cursor-colors-set=false
		default-size-columns=180
		default-size-rows=40
		dim-transparency-percent=0
		font='Ubuntu Mono 10'
		foreground-color='#EFEFEF'
		highlight-colors-set=false
		palette=['#000000', '#AA0000', '#00AA00', '#AA5400', '#0000AA', '#AA00AA', '#00AAAA', '#AAAAAA', '#545454', '#FF5454', '#54FF54', '#FFFF54', '#5454FF', '#FF54FF', '#54FFFF', '#FFFFFF']
		terminal-title='${id}: ${title}${process}'
		use-system-font=false
		use-theme-colors=false
		visible-name='Linux'

		[com/gexperts/Tilix/profiles/5283b4cf-faa5-4aef-afcd-a29fd5e0335a]
		background-color='#FDF6E3'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#657B83'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Sun Microsystems'

		[com/gexperts/Tilix/profiles/75b21a4c-150c-4f7a-a093-9faaa19626e2]
		background-color='#002B36'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#839496'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Solarized'

		[com/gexperts/Tilix/profiles/8000e9d6-6f21-4a4e-a122-ac45607b56f5]
		background-color='#1E1E1E'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#A7A7A7'
		highlight-colors-set=false
		palette=['#1E1E1E', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#A7A7A7', '#5F5A60', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#FFFFFF']
		use-theme-colors=false
		visible-name='Twilight'

		[com/gexperts/Tilix/profiles/d6401d4b-4b26-42ec-918a-2e7dc977118d]
		palette=['#000000', '#CC0000', '#4D9A05', '#C3A000', '#3464A3', '#754F7B', '#05979A', '#D3D6CF', '#545652', '#EF2828', '#89E234', '#FBE84F', '#729ECF', '#AC7EA8', '#34E2E2', '#EDEDEB']
		use-theme-colors=true
		visible-name='Tango'
		EOF_TLX
		dconf load / < ~/.config/rtd/gconf-tilix-settings.ini
}



set_gnome_ui_tweak_no_media_error() {
	# Description:  Function to handle missing media when attempting to set UI look to
	# 		resemble MAC/Windows/etc. for users accustomed to that.
	#
	# Usage:
	# set_gnome_ui_tweak_no_media_error
	# OEM_Hint="My custom mesage" ; set_gnome_ui_tweak_no_media_error
	#
	# Globals: ${OEM_Hint}
	# Arguments: none
	# Outputs:
	# Returns: Standard err for last task
	# End of documentation
	: ${OEM_Hint:="I cannot find the actual theme files needed. Should I attempt to get these?"}

	zenity --question --text "${OEM_Hint}" --width=600
	case "$?" in
		0 ) oem::deploy_themes ; bash ${_THEME_DIR}/plus-themes.se ;;
		1 ) return ;;
		* ) write_error "unknown response received!" ; return 1 ;;
	esac
}



set_gnome_ui_mac_tweaks_for_user() {
	# Description: Function to set UI look to resemble MAC for users accustomed to that.
	#
	# Usage:
	# set_gnome_ui_mac_tweaks_for_user Dark
	# set_gnome_ui_mac_tweaks_for_user Light
	#
	# Globals:
	# Arguments: Dark/Light
	# Outputs:
	# Returns: Standard err for last task
	# End of documentation

	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting MAC like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/WhiteSur-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'WhiteSur-Dark'
			gsettings set org.gnome.desktop.interface icon-theme 'WhiteSur-dark'
			gsettings set org.gnome.shell.extensions.user-theme name "WhiteSur-Dark"

			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name MojaveNight.jpg)

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'dark'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/WhiteSur-Light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'WhiteSur-Light'
			gsettings set org.gnome.desktop.interface icon-theme 'WhiteSur'
			gsettings set org.gnome.shell.extensions.user-theme name "WhiteSur-Light"

			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name MojaveDay.jpg)

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'light'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'
	gsettings set org.gnome.desktop.wm.preferences button-layout 'close,maximize,minimize:appmenu'
	# Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'desktop-icons@csoriano', \
	'ubuntu-appindicators@ubuntu.com', \
	'CoverflowAltTab@palatis.blogspot.com']"


	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}



set_gnome_ui_win10_tweaks_for_user() {
	# Description: Function to set UI look to resemble Windows 10 for users accustomed to that.
	#
	# Globals:
	# Arguments: Dark/Light
	# Outputs:
	# Returns: Standard err for last task
	# Usage:
	# set_gnome_ui_win10_tweaks_for_user Dark
	# set_gnome_ui_win10_tweaks_for_user Light
	#
	# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Windows like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Windows-10-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Dark"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Windows-10-Light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Light'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Light"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background 'false'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

	# Set wallpaper
	gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name Redmond.png)

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}




set_gnome_ui_corporate_crisp_tweaks_for_user() {
	# Description: Function to set UI look to appeal to teh corporate or business user.
	#
	# Globals:
	# Arguments: Dark/Light
	# Outputs:
	# Returns: Standard err for last task
	# Usage:
	# set_gnome_ui_corporate_crisp_tweaks_for_user Dark
	# set_gnome_ui_corporate_crisp_tweaks_for_user Light
	#
	# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Crisp like tweaks..."

	GNOME_TERMINAL_PROFILE="$(gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}')"

	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Arc-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc-Dark"
			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name RTD_Wallpapers_HQ_Public_Domain_019.jpg)
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Arc ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc"
			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name RTD_Wallpapers_HQ_Public_Domain_020.jpg)
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	if [[ -d /usr/share/icons/Arc-icon-theme ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Arc-icon-theme'
	else
			set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}


set_gnome_ui_moca_tweaks_for_user() {
	# Description: Function to set UI look to be friendly on the eyes, limiting eye strain.
	#
	# Globals:
	# Arguments: none
	# Outputs:
	# Returns: Standard err for last task
	# Usage:
	# set_gnome_ui_moca_tweaks_for_user
	#
	# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Eye strain saving tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`

	if [[ -d /usr/share/themes/vimix-dark-doder ]] ; then
		gsettings set org.gnome.desktop.interface gtk-theme 'vimix-dark-doder'
		gsettings set org.gnome.shell.extensions.user-theme name "vimix-dark-doder"
		gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name Chocolate_brown_wallpaper.jpg)
	else
		set_gnome_ui_tweak_no_media_error
	fi

	if [[ -d /usr/share/icons/Flatery-Black-Dark ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Flatery-Black-Dark'
	else
		set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'

	# Configure terminal look...
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ bold-is-bright true

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}



oem::register_wallpapers_for_gnome() {
	# Validate the input directory
	local _wallpaper_dir="${1:-"${_WALLPAPER_DIR}"}"
	if [[ ! -d "$_wallpaper_dir" ]]; then
		echo "Error: Directory '$_wallpaper_dir' does not exist."
		return 1
	fi

	local xml_file="oem-backgrounds.xml"
	local dest_dir="/usr/share/gnome-background-properties"
	local dest_file="${dest_dir}/${xml_file}"

	# Start with the XML header
	cat > "$xml_file" <<-EOF
	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE wallpapers SYSTEM "gnome-wp-list.dtd">
	<wallpapers>
	EOF

	# Safely iterate over .jpg and .png files
	shopt -s nullglob
	for i in "$_wallpaper_dir"/*.jpg "$_wallpaper_dir"/*.png; do
		cat >> "$xml_file" <<-EOF
	<wallpaper>
	    <name>$(basename "$i")</name>
	    <filename>$i</filename>
	    <options>stretched</options>
	    <pcolor>#8f4a1c</pcolor>
	    <scolor>#8f4a1c</scolor>
	    <shade_type>solid</shade_type>
	</wallpaper>
	EOF
	done
	shopt -u nullglob

	# Finish with the XML footer
	echo "</wallpapers>" >> "$xml_file"

	# Ensure the destination directory exists
	mkdir -p "$dest_dir"

	# Use 'mv' instead of 'sed' to place the file to avoid unnecessary complexity
	# and potential issues with file paths. If further processing is needed,
	# it should be handled more explicitly.
	mv "$xml_file" "$dest_file"

	echo "Wallpapers registered successfully at $dest_file"
}


rtd_oem_turn_on_gui_network_management() {
	# Description: Function to set NetworkManager by default to manage networking.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# The function expects no arguments.
	# Usage:
	# rtd_oem_turn_on_gui_network_management
	#
	# End of documentation

	if ls /usr/bin/*session ; then
		# backup any existing network yaml definitions:
		mkdir -p /etc/netplan/bak && mv /etc/netplan/*.yaml /etc/netplan/bak/

		# Create a new netplan for all interfaces:
		# Be careful with white spaces in yaml files!!!
		cat > /etc/netplan/01-network-manager-all.yaml <<- 'EOF'
		# Let NetworkManager manage all devices on this system
		network:
		  version: 2
		  renderer: NetworkManager

		EOF

		# Enable network manager:
		systemctl disable systemd-networkd
		systemctl enable  NetworkManager
		systemctl start  NetworkManager
		systemctl stop systemd-networkd
		systemctl restart  NetworkManager
	else
		write_error "No graphical session appear to be availabl in this system! Skipping netconfig..."
	fi
}


add_gnome3_favorite_app() {
	# Description: Function to add a new favorite app to the gnome favorites bar.
	# Globals: none
	# Arguments: name of the shortcut to create (appname.desktop)
	# Outputs:
	# Returns: 0/1
	# Usage: add_gnome3_favorite_app [appname.desktop]
	#
	# NOTE: This function must be run in the user context.
	# End of documentation
	# A potentioal simplification if the escapes cn be figured out:
	# sudo -iu $SUDO_USER /bin/bash -c \" "gsettings set org.gnome.shell favorite-apps \\\"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\\$//), '${Newapp}']\\\"" \"

	NewApp="$1"
	if TMP_FIL=$(mktemp -p "$(mktemp -d )") ; then
		chown -R $SUDO_USER ${TMP_FIL%/*}
		sudo -iu  $SUDO_USER  echo "gsettings set org.gnome.shell favorite-apps \"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\$//), '${NewApp}']\"" >${TMP_FIL}
		sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus /bin/bash ${TMP_FIL}
		rm ${TMP_FIL}
	else
		return 1
	fi
}



system::run_command_in_gnome_user_session() {
	# Description: Function to do a reverse sudo back to teh original Gnome user who called upon sudo.
	# This functon expects any number of parameters that would make up the command or commands
	# to be run in the users session. For example:
	# 	system::run_command_in_gnome_user_session script_name.sh parameter one two etc
	#
	# Globals:
	# Arguments: [path/script.sh] [bash command]
	# Outputs:
	# Returns:
	# Usage: system::run_command_in_gnome_user_session script_name.sh
	#
	# End of documentation
	echo -------------------------- Begin as user: $SUDO_USER ---------------------
	echo "$*"
	sudo -H -u "$SUDO_USER" DISPLAY=$DISPLAY DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus $*
	echo " "
	echo -------------------------- End as user: $SUDO_USER   ---------------------
}



ensure_admin() {
	# Description: Function to elevate priviledges of script execution and to ensure administrative privileges
	# such that system wide settings or configuration may be done.
	#
	# This function evaluates and uses multiple ways to elevate priviledges based on the environment. In an
	# X session; and normal GUI w. systemd: elevate privs with normal GUI policy kit, otherwise try dialog
	# menu system and cached sudo, and finally fall back on good old sudo. Since scripts may be launched with
	# a GUI front (for user interaction) end and NO terminal; it is really preferable to display a proper
	# priviledge escalation propt in a GUI format and only use sudo in cases where there is a terminal or
	# no other option is present.
	#
	# Should the function not discover an X session, then dialog will be preferred over regular sudo.
	#
	# Globals: $UID
	# Arguments: None
	# Outputs: GUI
	# Dependencies: soft dependency on "dialog", will fall back on CLI if dialog is absent.
	# Returns: relaunches script under sudo.
	# Usage: The function expects no arguments, but will prompt for system password if required.
	# Usage: ensure_admin
	#
	# End of documentation

	if [ -n "$DISPLAY" ] ; then 
		system::log_item "👌 An X session is running."
		# Because of course it is not installed by default in SUSE!
		if ! command xhost ; then software::command_exists xhost ; fi 
	elif [ -n "$WAYLAND_DISPLAY" ]; then
		system::log_item "👌 A Wayland session is running."
	else
		system::log_item "👌 No graphical session detected."
	fi

	if [ ! "$UID" -eq 0 ]; then
		if xset q &>/dev/null; then
			# If X is running in this session then...
			if echo $(systemctl get-default ) |grep graphical &>/dev/null ; then
				system::log_item "🔐 We are in a normal GUI w. systemd: elevating privs with normal GUI policy kit..."
				system::log_item "🔐 Allowing root to display menus..."
				if [ -n "$DISPLAY" ] ; then xhost local:root ; fi
				system::log_item "🔐 Authenticating..."
				pkexec env DISPLAY="$DISPLAY" XAUTHORITY="$XAUTHORITY" SUDO_USER="$USER" DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" "$(readlink -m "${0}")"
				exit
			else
				system::log_item "🔐 We are some other kind of older GUI: authenticating using lowest common denominatior..."
				system::log_item "🔐 Allowing root to display menus..."
				if [ -n "$DISPLAY" ] ; then xhost local:root ; fi
				write_information "🔍 Checking for dialog..."
				if hash dialog 2>/dev/null ; then
					token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
					ret=$? ; clear
					case $ret in
						0)
							system::log_item "🔐 Authenticating using dialog..."
							export HISTIGNORE='*sudo -S*'
							echo ${token} | sudo -S -v || ensure_admin
							sudo -E SUDO_USER=$USER /bin/bash "${0}" "$*" || rtd_oem_pause 1
						;;
						1) echo "Request cancelled" ;;
						255) echo "[esc] Request aborted" ;;
						* )  exit 1
					esac
					exit
				else
					system::log_item "🔐 We have some kind of X but no dialog installed: authenticating using plain sudo..."
					write_warning "🔐 This script needs administrative access..."
					xhost local:root
					sudo -E SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
					exit
				fi
			fi
		else
			write_information "🖥️ No X server at \$DISPLAY [$DISPLAY] : we are running in a TTY..."
			# Use dialog if possible, otherwise just terminal...
			if hash dialog 2>/dev/null ; then
				token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
				ret=$? ; clear
				case $ret in
					0)
						system::log_item "🔐 Authenticating using dialog..."
						export HISTIGNORE='*sudo -S*'
						echo ${token} | sudo -S -v || ensure_admin
						sudo -E SUDO_USER=$USER /bin/bash "${0}" "$@" || rtd_oem_pause 1
					;;
					1) echo "Request cancelled" ;;
					255) echo "[esc] Request aborted" ;;
					* )  exit 1
				esac
				exit
			else
				system::log_item "🔐 we are in a TTY and no dialog installed: authenticating using plain sudo..."
				write_warning "🔐 This script needs administrative access..."
				sudo -E SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
				exit
			fi
		fi
	else
		system::log_item "✅ Administrative access confirmed for: 👩‍🦰 ${SUDO_USER:-"❓ unknon user"} as requested by ${FUNCNAME[1]} ..."
	fi

}



system::ensure_admin() {
	# Description:
	# Ensures the script runs with administrative privileges, attempting to use
	# graphical methods in GUI environments and falling back to terminal-based
	# sudo in non-GUI environments or when graphical methods fail.
	#
	# Globals:
	#   UID - User ID of the current user. Root user has UID 0.
	#   DISPLAY - Environment variable specifying the X display.
	#   SUDO_USER - The user who invoked sudo or pkexec.
	#
	# Arguments: None
	#
	# Outputs:
	#   Informational messages about the authentication process.
	#
	# Returns:
	#   Exits the current script and restarts it with administrative privileges
	#   if necessary.
	#
	# Usage:
	#   Call `ensure_admin` at the beginning of a script that requires administrative privileges.


	if [[ "$UID" -eq 0 ]]; then
		system::log_item "Administrative access granted to ${SUDO_USER:-"unknon user"} as requested by ${FUNCNAME[1]} ..."
		return
	fi

	# Attempt to use PolicyKit's pkexec for graphical privilege escalation
	if command -v pkexec &>/dev/null && xset q &>/dev/null; then
		system::log_item "Attempting to gain privileges using pkexec..."
		pkexec env DISPLAY="$DISPLAY" XAUTHORITY="$XAUTHORITY" SUDO_USER="$USER" "$0" "$@"
		exit $?
	fi

	# Attempt to use dialog for a nicer terminal interface, if available
	if command -v dialog &>/dev/null; then
		echo "Attempting to gain privileges using dialog for sudo..."
		token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
		ret=$? ; clear
		case $ret in
			0)
				export HISTIGNORE='*sudo -S*'
				echo ${token} | sudo -S -v || ensure_admin
				sudo -E SUDO_USER=$USER /bin/bash "${0}" "$@" || rtd_oem_pause 1
			;;
			1) 
				system::log_item "Request cancelled"
				exit $?
			;;
			255)
				system::log_item "[esc] Request aborted"
				exit $?
			;;
			* )  
				system::log_item "Failed to gain administrative privileges."
				exit 1
			;;
		esac
	fi

	# Fallback to using sudo directly in the terminal
	system::log_item "Attempting to gain privileges using sudo..."
	if ! sudo -v; then
		system::log_item "Unable to gain administrative privileges."
		exit 1
	fi

	# Relaunch the script with sudo
	sudo SUDO_USER="$USER" "$0" "$@"
	exit $?

}



system::rtd_oem_check_inet_access() {
	# Description: Function to verrify internet availabiltiy.
	# The funciton will pause for 10 seconds by default, and will accept
	# an integer to indicate a non-decault time to pause.
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# system::rtd_oem_check_inet_access [ integer ]
	#
	# Example:
	# system::rtd_oem_check_inet_access 60
	#
	# If an argument is omitted system::rtd_oem_check_inet_access will wait indefinitley
	# for input.
	#
	# End of documentation
	_ARG=$1
	if ! hash curl &>/dev/null; then
		read -t 10 -p "N O T I C E ! --
		Could not check for internet connectivity...
		Please install (curl) web crawler/downloader.
		Press [ENTER] to continue and [CTRL] + [C] to exit! Continuing in 10 seconds..."
	else
		if [[ -z "$_ARG" ]]; then
			curl ipinfo.io &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
		else
			curl ipinfo.io &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
		fi
	fi
}


rtd_oem_kde_set_wallpaper() {
	# Description:
	# Function to set KDE Plasma wallpaper from a script. this function expects one variable
	# indication what file to set as background. You must provide the full path to the file.
	# rtd_oem_kde_set_wallpaper /opt/oem/wallpaper.png Supported fule types are:
	# webm, mp4, png, jpeg, gif, webp.
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# End of documentationsystem::toggle_oem_auto_elevated_privilege

	echo "Setting wallpaper $1"
	full_image_path=$(realpath "$1")
	ext=$(file -b --mime-type "$full_image_path")
	XDG_RUNTIME_DIR="/run/user/${SUDO_UID}"

	if [ -z "$2" ]; then
	# Identify filetype and make changes
	case $(echo $ext | cut -d'/' -f2) in
		"mp4"|"webm") type='VideoWallpaper' ; write='VideoWallpaperBackgroundVideo';;
		"png"|"jpeg"|"jpg") type='org.kde.image' ; write='Image' ;;
		"gif"|"webp") type='GifWallpaper' ; write="GifWallpaperBackgroundGif" ;;
	esac
	else
	type="$2";
	write="$3";
	fi

	wallpaper_set_script="var allDesktops = desktops();
	print (allDesktops);
	for (i=0;i<allDesktops.length;i++)
	{
		d = allDesktops[i];
		d.wallpaperPlugin = '${type}';
		d.currentConfigGroup = Array('Wallpaper', '${type}', 'General');
		d.writeConfig('Image', 'file:///dev/null')
		d.writeConfig('$write', 'file://${full_image_path}')
	}"

	# have to put in these stupid fixes because distros can't agree where to but stuff!
	hash qdbus || ${_qdbus="/usr/bin/qdbus-qt5" } && ${_qdbus="qdbus" }
	${_qdbus} org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "${wallpaper_set_script}"
	kwriteconfig5 --file kscreenlockerrc --group Greeter --group Wallpaper --group org.kde.image --group General --key Image "file://$full_image_path"
}



rtd_oem_setup_brand_splash_screen() {
	# Description: Function to brand the installer splash screen for the customized installer
	# downloaded from a ginve vendor. This function expects a few simple peices of information:
	# parameter 1: full path to image file to be branded.
	# parameter 2: quoted text to be incerted.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# rtd_oem_setup_brand_splash_screen [string] [string]
	#
	# [string]: /path/to/imagefile.png, "text to brand image with"
	#
	# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
	#
	# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $tmp_disc_dir/splash.png ]; then
			echo "$tmp_disc_dir/splash.png"
		elif  [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		elif [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || write_error "Image [ $image_file_to_brand ] NOT branded!  "
	fi
}



system::prepare_environment_for_iso_creation() {
	# Description: Function to check that all dependencies are available for manipulating the
	# net install ISO from Ubuntu. Subsequently, the temporary file locations
	# are setup and templates are downloaded.
	#
	# Several key software components are required to create ISO files (virtual DVD/CD/BlueRay)
	# as well as a few others needed to download files from the internet, etc.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# DEPENDENCIES: dos2unix, cpio, gzip, genisoimage, whois, pwgen, wget, fakeroot, xorriso.
	#
	# This function will find full paths for the binaries needed since if they are recently
	# added, they may not be found in the current $PATH.
	#
	#	Software PATH insurance:
	#	: "${bin_7z:=$(type -P 7z)}"
	#	: "${bin_xorriso:=$(type -P xorriso)}"
	#	: "${bin_cpio:=$(type -P gnucpio || type -P cpio)}"
	#	: "${bin_qemu_img:=$(type -P qemu-img)}"
	#	: "${bin_kvm:=$(type -P kvm)}"
	#	: "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
	#	: "${put_iso_file_here_when_done:="/home/$SUDO_USER/Virtual-DVDs"}"
	#	: "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
	#	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	#	: "${ssh_public_key_file:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	#	: "${permanent_download_dir:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"
	#
	# The main tool to create ISO files system is "xorriso".
	# [xorriso] copies file objects from POSIX compliant filesystems into Rock Ridge
	# enhanced ISO 9660 filesystems and allows session-wise manipulation of such filesystems.
	# It can load the management information of existing ISO images and it writes the session results
	# to optical media or to filesystem objects.
	#
	# At this time this function expects no arguments.
	#
	# End of Documentation

        if [[ "$1" == "--cleanup" ]]; then
		for dir in "$tmp_download_dir" "$tmp_disc_dir" "$tmp_initrd_dir"; do
			if [ -z "$dir" ]; then
				system::log_item "Warning: Directory variable is not set for the directory cleanup."
			fi

			if [ "$dir" = "/" ] || [[ "$dir" =~ ^/[^/]+/?$ ]] || [ "$dir" = "$HOME" ]; then
				system::log_item "Error: Attempt to delete critical directory $dir"
			else 
				if [ -d "$dir" ]; then
					system::log_item "Cleaning up temporary directory: $dir"
					rm -rf "$dir"
				else
					system::log_item "Warning: Directory $dir does not exist."
				fi
			fi
		done

		unset bin_7z
		unset bin_xorriso
		unset bin_cpio
		unset bin_qemu_img
		unset bin_kvm
		unset bin_qemu_system_x86_64
		unset put_iso_file_here_when_done
		unset put_qcow_file_here_when_done
		unset VOLUME_TITLE
		unset ssh_public_key_file
		unset permanent_download_dir
		unset isohdpfx_bin
		unset current_dir
		unset script_dir
		unset tmp_download_dir
		unset tmp_disc_dir
		unset tmp_initrd_dir
		unset _dependencies
		return 0
        else
                system::log_item "Preparing environment for ISO creation..."

                : "${target_iso="$put_iso_file_here_when_done/$target_iso_file_name"}"

		# List of package dependencies for the script depending on the distro (naming may vary)
                if cat "/etc/os-release" | grep "debian" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-system libvirt-daemon-system"
                elif cat "/etc/os-release" | grep "fedora" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-system libvirt-daemon-system"
                elif  cat "/etc/os-release" | grep "suse" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-x86 libvirt-daemon-qemu"
                else
                        write_error "Neither debian, fedora, or suse base distros or derivatives could be found; NOT installing dependencies."
                        return 1
                fi
		
		# set index to be augmented and count the total number of dependencies
		local index=0
		local total_dependencies=0
		for dep in $_dependencies; do
			((total_dependencies++))
		done

		# Check for dependencies
                for i in $_dependencies; do 
			software::check_native_package_dependency $i && ((index++))
		done

		# Compare the count of available dependencies to the total number of dependencies
		if [[ $index -eq $total_dependencies ]]; then
			system::log_item "All dependencies are available."
		else
			write_error "⛔ Some dependencies are missing. Available: $index, Required: $total_dependencies"
			return 1
		fi		

                : "${bin_7z:=$(type -P 7z)}"
                : "${bin_xorriso:=$(type -P xorriso)}"
                : "${bin_cpio:=$(type -P gnucpio || type -P cpio)}"
                : "${bin_qemu_img:=$(type -P qemu-img)}"
                : "${bin_kvm:=$(type -P kvm)}"
                : "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
                : "${put_iso_file_here_when_done:="/home/$SUDO_USER/Virtual-DVDs"}"
                : "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
                : "${VOLUME_TITLE:="🤖 RTD_AUTO_INSTALLER 🤖"}"
                : "${ssh_public_key_file:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
                : "${permanent_download_dir:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

                system::log_item "Checking for presence of (isohdpfx.bin)..."
                if [[ -e /usr/lib/ISOLINUX/isohdpfx.bin ]]; then
                        : "${isohdpfx_bin:="/usr/lib/ISOLINUX/isohdpfx.bin"}"
			write_information "Found: $isohdpfx_bin"
                else
                        write_warning "An important file (isohdpfx.bin) was not found in the expected location. Attepting to workaround the issue..."
                        if hash locate 2>/dev/null ; then
                                locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 ; return 1 )
                                : "${isohdpfx_bin:=$(locate isohdpfx.bin  | head -n 1)}"
                                write_information "Found: $isohdpfx_bin"
                        else
                                check_dependencies plocate && ( write_warning "Updating file location DB, this may take a long time if there are a lot of files on the system..." ; updatedb )
                                locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 ; return 1 )
                                : "${isohdpfx_bin:=$(locate isohdpfx.bin  | head -n 1)}"
                                write_information "Found: $isohdpfx_bin"
                        fi
                fi

                if [[ ! -f "$ssh_public_key_file" ]] ; then
                        write_warning "Error: public SSH key $ssh_public_key_file not found!
                        You will need to setup automatic login using ssh manually each time you build a server with this media."
                fi

                current_dir="$(pwd)"
                script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                tmp_download_dir=$(mktemp -d )
                tmp_disc_dir=$(mktemp -d )
                

                for i in $put_qcow_file_here_when_done\
                        $put_iso_file_here_when_done\
                        $permanent_download_dir
                do
                        mkdir -p "$i" && chown "$SUDO_USER":"$SUDO_USER" "$i"
                done
        fi 
}




system::download_and_manipulate_iso_debian() {
	# Description:
	# system::download_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
	# This is a simple command sequence to read the preference of distribution to install
	# and what release to get... then download the network install file from debian
	# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	#
	# system::download_and_manipulate_iso_debian [ISO Name] [Environment] [Addon Task]
	#
	# where [ISO Name] may be: any string to starte the file name with
	# where [Environment] may be: any debian supported desktop environment
	# where [Addon Task] may be: additional pre determined configuration
	#
	# EXAMPLE:
	# system::download_and_manipulate_iso_debian openssh-server MinecraftTasks
	# system::download_and_manipulate_iso_debian gnome-desktop
	# system::download_and_manipulate_iso_debian xfce-desktop
	#
	# End of Documentation

 	kvm::util::read_common_options "$@"
	kvm::util::read_distro_options "$@"
	system::prepare_environment_for_iso_creation

	# Determine the name of the ISO file to create, and wich iso to download using default values if none are provided.
	# Capitlal variable names are generally global and set in the _loctations file.
	# Variables will be populated either from the default _locations file or detected.
	: "${_SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${_SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	: "${_CURRENT_DEB_ISO:="$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${target_iso_file_name="Auto_Install_${_CURRENT_DEB_ISO%.iso}-${_role:-"ssh-server"}-${_UserDesktopEnvironmentSelection:-cli}.iso"}"
	target_iso="$put_iso_file_here_when_done/$target_iso_file_name"
	iso_store="$put_iso_file_here_when_done/Downloaded/$_CURRENT_DEB_ISO"
	tmp_initrd_dir=$(mktemp -d )

	if [[ ! -f "$iso_store" ]]; then
		write_status "Geting install image..."
		write_information "Download: $_SOURCE_ISO_URL"
		wget -4  -q --show-progress "$_SOURCE_ISO_URL" -O "$iso_store" 
		write_information "Retreived: $(ls $iso_store)"
	fi

	$bin_7z x "$iso_store" "-o$tmp_disc_dir" || write_error  "FAILED to download and/or extract $_SOURCE_ISO_URL" 
	mkdir -p "$tmp_initrd_dir/custom" && system::log_item "Created custom directory in $tmp_disc_dir" || write_error  "FAILED to create custom directory in $tmp_disc_dir"

	# write_status "Geting non-free firmware..."
	# write_information "Download: $_SOURCE_FIRMWARE"
	# wget -4  -q --show-progress "$_SOURCE_FIRMWARE" -O "$tmp_download_dir/firmware.zip" && ( mkdir "$tmp_disc_dir/firmware" & "$bin_7z" x "$tmp_download_dir/firmware.zip" "-o$tmp_disc_dir/firmware" )
	# write_information "Retreived: $(ls "$tmp_disc_dir"/firmware )"

	# Load the installation answers template.
	write_status "Getting intall instructions template... "
	system::make_preseed_cfg --saveto ${tmp_initrd_dir} --ask YES || ( write_error "Failed to create preseed.cfg template" ; dialog::display_error "Something went wrong, please check the logfile $_LOGFILE" )

	# ----------------------- Modify Boot Media --------------------------- #
	# Edit the grub.cfg file...
	#sed -i '/timeout/s/.*/set timeout=10/' "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i s/"menuentry --hotkey=g 'Graphical install' {"/"menuentry --hotkey=g 'Automatic Graphical install' {"/g "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i s/"linux    /install.amd/vmlinuz vga=788 --- quiet {"/"linux    /install.amd/vmlinuz vga=788 theme=dark	 --- quiet {"/g "$tmp_disc_dir/boot/grub/grub.cfg"

	sed -i s/"menuentry --hotkey=i 'install' {"/"menuentry --hotkey=g 'Automatic install' {"/g "$tmp_disc_dir/boot/grub/grub.cfg"
	#sed -i '/insmod play/d' "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i 's/^[[:space:]]*set gfxmode=800x600$/  set gfxmode=1024x768/' "$tmp_disc_dir/boot/grub/grub.cfg"

	# Edit the gtk.cfg file...
	sed -i s/"menu label ^Graphical install"/"menu label ^Automatic Graphical install"/g "$tmp_disc_dir/isolinux/gtk.cfg"

	# Edit the txt.cfg file...
	sed -i s/"menu label ^Install"/"menu label ^Automatic Install"/g "$tmp_disc_dir/isolinux/txt.cfg"

	# Edit the spkgtk.cfg file...
	sed -i 's|ontimeout /install.amd/vmlinuz vga=788 initrd=/install.amd/gtk/initrd.gz speakup.synth=soft --- quiet|ontimeout /install.amd/vmlinuz vga=788 initrd=/install.amd/gtk/initrd.gz theme=dark --- quiet|' "$tmp_disc_dir/isolinux/spkgtk.cfg"

	dos2unix "$tmp_disc_dir/isolinux/isolinux.cfg"
	sed -i 's/^timeout 0$/timeout 100/' "$tmp_disc_dir/isolinux/isolinux.cfg"
	# --------------------------------------------------------------------- #

	

	system::download_and_manipulate_iso_debian::modify_installer() {
		local initrd_path="$1"

		write_status "🔧 Modifying the installer: $initrd_path"
		gzip -d -c "$initrd_path" > "$tmp_initrd_dir/initrd" || { write_error "Failed to extract $initrd_path"; return 1; }

		for file in "preseed.cfg" "task.sh" "custom"; do
			if [ -e "./$file" ]; then
				if [ "$file" == "custom" ]; then
					find "./custom" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
				else
					echo "./$file" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
				fi
			else
				write_error "No $file found in $(pwd)"
			fi
		done

		write_status "🔩📀 Injecting created content into the new INITRD in the folder $tmp_disc_dir ..."
		if cat "$tmp_initrd_dir/initrd" | gzip -9c > "$initrd_path"; then
			write_status "🔧 Modified the installer: $initrd_path"
		else
			write_error "❌ Failed to modify the installer: $initrd_path"
		fi

		rm "$tmp_initrd_dir/initrd" || write_error "Failed to remove initrd file"
	}

	pushd "$tmp_initrd_dir" || { write_error "Failed to enter init directory: $tmp_initrd_dir"; exit 1; }

	system::download_and_manipulate_iso_debian::modify_installer "$tmp_disc_dir/install.amd/initrd.gz" || rtd_oem_pause 1 "Failed to modify installer: $tmp_disc_dir/install.amd/initrd.gz"
	system::download_and_manipulate_iso_debian::modify_installer "$tmp_disc_dir/install.amd/gtk/initrd.gz" || rtd_oem_pause 1 "Failed to modify installer: $tmp_disc_dir/install.amd/gtk/initrd.gz"

	popd || { write_error "Failed to popd"; rtd_oem_pause 1; }
	
        rtd_oem_setup_brand_splash_screen "$tmp_disc_dir/splash.png" "${_FULLNAME:-"RunTime Data"} OEM Install: $PREFERENCE"
	system::create_iso_image_debian	 --target-iso "$target_iso" --iso-source-dir "$tmp_disc_dir"
	ret_val=$?
	if [[ $ret_val -eq 255 ]]; then
		system::log_item "User declined to create a bootable thumbdrive from the new ISO media."
		return 255
	elif [[ $ret_val -eq 0 ]]; then
		system::log_item "Successfully created a bootable thumbdrive from the new ISO media."
		return 0
	else
		rtd_oem_pause 1 "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
		return 1
	fi

}



system::create_iso_image_debian() {
	# Description: Function to generate the new ISO file from the extracted and
	# altered original ISO.
	# Delete old iso file if there...
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# End of Documentation

	# Check for other input and create them if not defined...
	# : "${target_iso}"
	# : "${put_iso_file_here_when_done}"



	system::validate_parameters ${*}
	while [[ $# -gt 0 ]]; do
		case $1 in
			--target-iso )
				target_iso="$2"
				shift 2
				;;
			--iso-source-dir )
				iso_source_dir="$2"
				shift 2
				;;
			--isohdpfx-bin )
				isohdpfx_bin="$2"
				shift 2
				;;
			--prompt )
				prompt="$2"
				shift 2
				;;
			*)
				write_error "Unknown option: $1"
				shift
				;;
		esac
	done

	system::log_item "Check for required information (a target and source directory)..."
	system::check_required_variables target_iso iso_source_dir isohdpfx_bin 

	write_status "------ CREATING ISO: ${target_iso}    --------"
	write_information "Volume Title: ${VOLUME_TITLE:-"RTD"}"
	write_information "ISO Source: ${iso_source_dir}"
	write_information "ISO Target: ${target_iso}"
	write_information "ISO Boot Media: ${isohdpfx_bin}"

	if [ -f "${target_iso}" ]; then
		rm -f "${target_iso}"
	fi

	pushd "${iso_source_dir}" || system::log_item  "Failed to enter ${iso_source_dir}"

		[[ -e '[BOOT]' ]] && ( rm -r '[BOOT]' || system::log_item  "Failed to delete [BOOT] directory" )

		[[ -f "isolinux/isolinux.bin" ]]; [[ -f "isolinux/boot.cat" ]]; [[ -f "isolinux/isolinux.cfg" ]] || system::log_item  "Missing files in ${iso_source_dir}/isolinux"

		"$bin_xorriso" -as mkisofs -r \
			-V "${VOLUME_TITLE:-"RTD"}" \
			-J -b "isolinux/isolinux.bin" \
			-c boot.cat \
			-no-emul-boot \
			-boot-load-size 4 \
			-boot-info-table \
			-input-charset utf-8 \
			-isohybrid-mbr "${isohdpfx_bin}" \
			-eltorito-alt-boot \
			-e boot/grub/efi.img \
			-no-emul-boot \
			-isohybrid-gpt-basdat -o "${target_iso}" ./ &>>"${_LOGFILE}" || rtd_oem_pause 1 "An error may have occurred (review above outout) then: Press [ENTER] to continue:"

		chmod 777 "${target_iso}" &>>"${_LOGFILE}" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
		
        popd || { write_error "Failed to popd"; rtd_oem_pause 1; }
	
        test_iso_boot_media "${target_iso}"

	while true; do
		exec 3>&1
			selection=$($RTD_GUI \
			--backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select which media to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
			"1" "Create bootable USB Media" \
			"2" "Add ISO to my Ventoy media (for multiple boot)" \
			"3" "Just show me the location of the new ISO file" \
			2>&1 1>&3)
			exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return 255 ;;
			"$DIALOG_ESC") return 255 ;;
		esac

		case $selection in
			1)
				if $RTD_GUI --yesno "Proceed to make a bootable thumbdrive from this ISO media (${target_iso})?" "$HEIGHT" "$WIDTH"; then
					create_physical_media_from_iso "$target_iso"
				else
					return 255
				fi
			;;
			2)
				if $RTD_GUI --yesno "Proceed to add this ISO (${target_iso}) to your Ventoy media for multiple boot options?" "$HEIGHT" "$WIDTH"; then
					util::add_iso_to_ventoy "$target_iso"
				else
					return 255
				fi
			;;
			3)
				$RTD_GUI --msgbox "The new ISO file is located at: $target_iso" "$HEIGHT" "$WIDTH"
				return 0
			;;
			*)
				dialog::display_error "Invalid selection: $selection"
			;;
		esac
	done
	
	system::prepare_environment_for_iso_creation --cleanup
}


create_physical_media_from_iso() {
	# Description:
	# Function to automatically write ISO (virtual DVD/CD/BlueRay) to a thumb drive. No argumenst are
	# required, but a source ISO file location can may be provided when calling the function.
	# If information is required, but not provided, the end user will be interactively prompted.
	# This function requires elevated priviledges to be able to write media to a thumb drive
	# (boot sector) and other system restrictied activities. If the function is NOT called in a
	# script with elevated priviledges, it will attempt to elevate priviledges and prompt for a password.
	# Since writing a new bootable thumb drive is inherrently an interactive activity; a prompt will
	# be displayed asking what media to write to. If no media is present, a warning error
	# message will be displayed.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	#
	# "create_physical_media_from_iso" or "create_physical_media_from_iso path/to/file.iso"
	#
	# NOTE:
	# [Note 1] An ISO file, often called an ISO image, is a single file that's a perfect representation of an
	# entire CD, DVD, or BD. The entire contents of a disc can be precisely duplicated in a single ISO file.
	# An optical disc image (or ISO image, from the ISO 9660 file system used with CD-ROM media) is a disk image
	# that contains everything that would be written to an optical disc, disk sector by disc sector, including the
	# optical disc file system. ISO images are expected to contain the binary image of an optical media file system
	# (usually ISO 9660 and its extensions or UDF), including the data in its files in binary format, copied exactly
	# as they were stored on the disc. The data inside the ISO image will be structured according to the file system
	# that was used on the optical disc from which it was created.
	#
	# [Note 2] A USB flash drive is a data storage device that includes flash memory with an integrated USB interface.
	# It is typically removable, rewritable and much smaller than an optical disc. Most weigh less than 30 g (1 oz).
	# Since first appearing on the market in late 2000
	# End of documentation


	: ${BackTitle="Physical Installation Media Creator"}
	: ${Title="OS Media Manger"}

	if [ ! "$UID" -eq 0 ]; then
		ensure_admin
	fi

	if [[ -z "$1" ]]; then
		[[ -d /home/${SUDO_USER}/Virtual-DVDs ]] && SuggestedFolder="/home/${SUDO_USER}/Virtual-DVDs/" || SuggestedFolder="/home/${SUDO_USER}"
		target_iso=$(dialog --stdout --title "${Title}" --backtitle "${BackTitle}" --fselect "${SuggestedFolder}" 15 110 2)
		UserResponse=$? ; clear
		case ${UserResponse} in
			  1) echo "Request cancelled"; return 0 ;;
			  255) echo "[ESC] key pressed."; return 255 ;;
		esac
	else
		target_iso=$1
	fi

	if [[ -z "${target_iso}" ]]; then
		DIALOGRC=~/.dialogrc
		if [[ -e ${DIALOGRC} ]]; then
			mv ${DIALOGRC} ${DIALOGRC}.bak
		fi

		echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
		dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n You must provide an ISO file as argument! \n Usage: ${0##*/} ~/filename.iso"  14 90
		clear ; rm ${DIALOGRC}

		if [[ -e ${DIALOGRC}.bak ]]; then
			mv ${DIALOGRC}.bak ${DIALOGRC}
		fi
		return 1
	else
		#          List removable dev : not loop dev: not CD    : not nvme HD : filter: header w. name
		devlist="$(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep -v nvme |grep 1 | cut -f1 -d' ')"

		if [[ -z ${devlist} ]]; then
			DIALOGRC=~/.dialogrc
			echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
			dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n No removable media could be found! Please insert a thumb drive and try again."  14 90
			clear ; rm ${DIALOGRC}
			return 1
		else
			declare -A RemovableMediaList
			index=1

			for media in ${devlist};
			do
				SuggestedRemovableDevice="${media}"
				RemovableMediaList[$index]=$(echo -e \'$(fdisk -l /dev/$media |head -1)\')
				(( index++ ))
			done

			DiscoveredItems="\n
			\n Removable media found: ${#RemovableMediaList[@]}
			\n --------------------------------------------------------

			$(until [ $i -gt ${#RemovableMediaList[@]} ]
			do
				[[ $i -gt 0 ]] && echo -e "Removable Disk $i:   ${RemovableMediaList[$i]} \n"
				((i=i+1))
			done
			)"

			USBTargetDevice=$( dialog --stdout --no-collapse --title "${Title}" --backtitle "${BackTitle}"  --inputbox "${DiscoveredItems}" 15 110 /dev/${SuggestedRemovableDevice} )
			Response=$?
			clear
			case ${Response} in
				0 )
					dialog --title "${Title}" --backtitle "${BackTitle}" --yesno "Please Confirm:\n Write the ISO file: \n ${target_iso} \n To the drive: \n ${USBTargetDevice}" 25 90
						case $? in
							0 ) ( dd if=${target_iso} of=${USBTargetDevice} status=progress 2>&1 |dialog --title "${Title}" --backtitle "${BackTitle}" --programbox "Please wait, writing disk now:" 25 90) ;;
							1 ) write_status "Request cancelled" ;;
							255 ) write_status "[ESC] key pressed."; return 255 ;;
							* ) write_warning "An unknown event occurred!" ; return 1 ;;
						esac
					clear ; return
				;;
				1 ) echo "Request cancelled"; return 0 ;;
				255 ) echo "[ESC] key pressed."; return 255 ;;
				* ) echo "An unknown event occurred!" ; return 1 ;;
			esac
			return
		fi
	fi
	return
}



util::add_iso_to_ventoy() {
	# Description: Function to add an ISO file to a Ventoy USB drive for multiple boot options.
	# Globals: None
	# Arguments: 
	#   $1 - The path to the ISO file to be added.
	# Outputs: Status and error messages.
	# Returns: 0 if successful, 1 if an error occurs.
	# Usage: util::add_iso_to_ventoy "/path/to/iso/file"

	local iso_file="$1"
	local device_list=()
	local ventoy_drive
	local mount_point
	local mounted_by_script
	local exit_status
	local rtd_ventoy_dir="OEMImages"

	# Check if the ISO file exists
	if [[ ! -f "$iso_file" ]]; then
		dialog::display_error "💿 ISO file not found: $iso_file"
		return 1
	fi

	# Function to build the list of available USB devices, specifically looking for Ventoy drives
	util::add_iso_to_ventoy::build_device_list() {
		local devname partname size model label
		device_list=()
		# Iterate over all USB devices and their partitions
		while read -r line; do
			devname=$(echo "$line" | awk '{print $1}')
			size=$(echo "$line" | awk '{print $2}')
			model=$(echo "$line" | awk '{print $3}')
			
			# Check each partition of the device
			for part in $(lsblk -ln -o NAME "/dev/$devname" | awk '{print $1}'); do
				partname="/dev/$part"
				label=$(lsblk -no LABEL "$partname")

				# Check if the label is Ventoy
				if [[ "$label" == "Ventoy" ]]; then
					device_list+=("$partname" "$model $size")
				fi
			done
		done < <(lsblk -d -o NAME,SIZE,MODEL,TRAN | grep "usb")
	}

	# Check if any USB drives are available before proceeding
	util::add_iso_to_ventoy::build_device_list
	system::log_item "Checking for USB drives... (devicelist= ${device_list[*]})"
	if [[ ${#device_list[@]} -eq 0 ]]; then
		until [[ ${#device_list[@]} -gt 0 ]]; do
			dialog::display_notice "🔌 No USB drives found. Please insert a USB drive and press [OK]."
			util::add_iso_to_ventoy::build_device_list
		done
	fi

	# Prompt the user to select the Ventoy USB drive
	exec 3>&1
		ventoy_drive=$(dialog --backtitle "$BRANDING" --title "💾 Select Ventoy USB drive" --menu "Select Ventoy USB drive to save the ISO in:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" "${device_list[@]}" 2>&1 1>&3)
		exit_status=$?
	exec 3>&-

	if [[ $exit_status -ne 0 || -z "$ventoy_drive" ]]; then
		dialog::display_error "🔌 No Ventoy USB drive selected or dialog was canceled."
		return 1
	fi

	# Check if the drive is already mounted
	mount_point=$(lsblk -n -o MOUNTPOINT "$ventoy_drive")
	
	# Mount the Ventoy drive if it is not already mounted
	if [[ -z "$mount_point" ]]; then
		# If not mounted, create a mount point and mount the drive
		mount_point=$(mktemp -d)
		if ! mount "$ventoy_drive" "$mount_point"; then
			dialog::display_error "💥 Failed to mount $ventoy_drive"
			rmdir "$mount_point"
			return 1
		fi
		mounted_by_script=true
	else
		mounted_by_script=false
	fi

	if [[ -n "$mount_point" ]]; then
		write_status "Mounted Ventoy drive: $ventoy_drive -> $mount_point"
		if [[ -f "$mount_point/.config/oem.json" ]]; then
			write_status "Ventoy configuration file found: .config/oem.json"
			_oem_id=$(jq -r '.TLA' "$mount_point/.config/oem.json")
			write_status "OEM ID: $_oem_id"
		else
			write_information "Ventoy OEM configuration file not found: $mount_point"
			write_information "This is a generic Ventoy drive."
		fi
	else
		dialog::display_error "🔌 Ventoy drive is not mounted: $ventoy_drive"
		return 1
	fi

	if [[ ! -d "$mount_point/$rtd_ventoy_dir" ]]; then
		write_warning "📁 Ventoy directory not found (!) creating it now: $mount_point/$rtd_ventoy_dir"
		mkdir -p "$mount_point/$rtd_ventoy_dir" || system::log_item "Failed to create: $mount_point/$rtd_ventoy_dir"
	fi

	# Copy the ISO file to the Ventoy drive
	# if cp "$iso_file" "$mount_point/$rtd_ventoy_dir"; then
	# 	dialog::display_notice "✅💿📥 Successfully added ISO to Ventoy drive: $iso_file Boot from the Ventoy drive on another computer to access the new ISO."
	# else
	# 	dialog::display_error "❌💿📥 Failed to copy ISO to Ventoy drive: $iso_file"
	# 	if $mounted_by_script; then
	# 		{ umount "$mount_point" ; } && { rmdir "$mount_point" ; }
	# 	fi
	# 	return 1
	# fi
	
	# Define your variables
	destination="$mount_point/$rtd_ventoy_dir/$(basename "$iso_file")"

	# Ensure destination directory exists
	mkdir -p "$mount_point/$rtd_ventoy_dir"

	# Copy the ISO file to the Ventoy drive with progress bar
	if dialog::copy_with_progress "$iso_file" "$destination" "$mount_point"; then
		dialog --msgbox "✅💿📥 Successfully added ISO to Ventoy drive: $iso_file Boot from the Ventoy drive on another computer to access the new ISO." 10 70
	else
		dialog --msgbox "❌💿📥 Failed to copy ISO to Ventoy drive: $iso_file" 10 70
	if $mounted_by_script; then
		{ umount "$mount_point" ; } && { rmdir "$mount_point" ; }
	fi
		exit 1
	fi


	# Unmount the Ventoy drive and clean up if it was mounted by this script
	if $mounted_by_script; then
		if umount "$mount_point"; then
			write_status "✅ ⏏️ Successfully unmounted Ventoy drive."
			rmdir "$mount_point"
		else
			write_error "❌ ⏏️ Failed to unmount Ventoy drive."
			return 1
		fi
	fi
	
	return 0
}




rtd_oem_setup_brand_splash_screen() {
	# Description: Function to brand the installer splash screen for the customized installer
	# downloaded from a ginve vendor. This function expects a few simple peices of information:
	# parameter 1: full path to image file to be branded.
	# parameter 2: quoted text to be incerted.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# rtd_oem_setup_brand_splash_screen [string] [string]
	#
	# [string]: /path/to/imagefile.png, "text to brand image with"
	#
	# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
	#
	# End of Documentation

	system::validate_parameters ${*}
	while [[ $# -gt 0 ]]; do
		case $1 in
			--target-iso )
				target_iso="$2"
				shift 2
				;;
			--iso-source-dir )
				iso_source_dir="$2"
				shift 2
				;;
			*)
				write_error "Unknown option: $1"
				shift
				;;
		esac
	done
	

	system::log_item "🔯 Ensure that imagemagik is installed so images can be manipulated."
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $tmp_disc_dir/splash.png ]; then
			echo "$tmp_disc_dir/splash.png"
		elif  [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="RunTime Data OEM Install: $PREFERENCE"}"

	write_status "found: $image_file_to_brand" 
	write_status "branding with: $text_to_brand_with " 

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || write_error "Image [ $image_file_to_brand ] NOT branded!  " 
	fi

        unset image_file_to_brand
        unset text_to_brand_with
}



system::get_tgt_ubuntu_version()
{
	# Determine available versions of Ubuntu to offer...
	system::log_item "🔎 Retreive list of available $ubuntu_flavor $_role versions..."
	declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
	declare -a all_normal_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+)/ && print "$1\n"' | sort -Vu))
	dist_logo="${ubuntulogo}"


	# Check if a version of Ubuntu was specified, otherwise make sure it is (default to latest LTS)...
	if [[ -z ${_tgt_ubuntu_ver} ]]; then
		write_information "🐧 - No version of Ubuntu specified..."
		if [[ ${_ask} == "YES" ]]; then
			write_information "🐧 - Requested to ask for Ubuntu version; prompting for version of Ubuntu to use..."
			extra_option="Manually_specify"

			# Display a menu to choose an Ubuntu version, including an option for manual entry
			_tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor $_role" --menu "\n \Z1\n$dist_logo\Zn \n 👍 Please pick an available \Z1$ubuntu_flavor\Zn version from the list below or choose to manually specify a version. Long Term Support (LTS) Versions to choose from are as follows:\n\n " 35 90 $(( ${#all_lts_versions[@]} + 1 )) \
			$(for i in "${!all_lts_versions[@]}"; do echo  "${all_lts_versions[$i]}" "$i"; done ) "$extra_option" "$(( ${#all_lts_versions[@]} + 1 ))"  3>&1 1>&2 2>&3)
			dialog_status=$?

			# Handle the user's menu selection or cancellation based on the captured status
			case $dialog_status in
				$DIALOG_CANCEL) echo "Dialog was cancelled."; return ;;
				$DIALOG_ESC) echo "Dialog was escaped."; return ;;
			esac

			# Check if the user chose to manually specify a version
			if [[ "${_tgt_ubuntu_ver}" == "${extra_option}" ]]; then
				_tgt_ubuntu_ver=$($RTD_GUI --colors --title "Manual Version Input" --inputbox "\nPlease enter the desired Ubuntu version (e.g., 22.10):" 10 60 3>&1 1>&2 2>&3)
				
				# Capture and handle the exit status of the input dialog
				case $? in
					$DIALOG_CANCEL) echo "Input was cancelled."; return ;;
					$DIALOG_ESC) echo "Input was escaped."; return ;;
				esac
			fi

			clear
		else
			write_information "🐧 - No version of Ubuntu specified, so using the latest LTS version: ${all_lts_versions[-1]}"
			_tgt_ubuntu_ver=${all_lts_versions[-1]}
		fi
	fi

	# Validate Ubuntu LTS version selections against available versions (manual selection may have occurred)...
	for lts_version in "${all_lts_versions[@]}"; do
		if [[ "${lts_version}" == "${_tgt_ubuntu_ver}" ]]; then
			local _selection_is_valid="yes"
			write_information "🐧 - The version of Ubuntu selected is valid: ${_tgt_ubuntu_ver}"
		fi
	done

	# Validate Ubuntu normal version selections against available versions (manual selection may have occurred)...
	for normal_version in "${all_normal_versions[@]}"; do
		if [[ "${normal_version}" == "${_tgt_ubuntu_ver}" ]]; then
			local _selection_is_valid="yes"
			write_information "🐧 - The version of Ubuntu selected is valid: ${_tgt_ubuntu_ver}"
		fi
	done

	if [[ "${_selection_is_valid}" != "yes" ]]; then
		write_error "⛔ - The version of Ubuntu selected [${_tgt_ubuntu_ver}] is not valid. Please select a valid version list. Alternatively, you may let me choose for you..."
		read -p "Press [ENTER] to continue..." 
		return 1
	fi

	# Return the version number selected
	_tgt_ubuntu_ver=${_tgt_ubuntu_ver:-${all_lts_versions[-1]}}

	system::log_item "Exporting selection: $tgt_ubuntu_ver"
	export tgt_ubuntu_ver

}



system::get_ubuntu_media()
{
	permanent_download_dir=$1
	if [[ -z $1 ]] ; then 
		{ system::log_item "no parameters provided, defaulting to default QEMU media location..."; permanent_download_dir=/var/lib/libvirt/boot ; }
	fi
	
	# Ensure that the file is available for VM creation... 
	write_status "Checking if $iso_filename already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$iso_filename")
	if [ ! -e "$iso" ]; then
		write_warning "$iso_filename is not in cache, downloading..."
		wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "FATAL Problem: Failure to download ISO file $ubuntu_iso_url"
		iso="$permanent_download_dir/$iso_filename"
	else
		write_information "💿 - $iso_filename already in cache, using it for greenfield creation..."
	fi

	system::log_item "Exporting ISO value: iso = $iso"
	export iso
}




rtd_oem_ubuntu_auto_install_iso_builder() {
	# Description: Function to generate an edited ISO file from a folder.
	# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
	# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
	# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# :: function name				:: target		:: iso version to download
	# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	desktop ⏭ creates auoinstall iso using the Ubuntu live dvd
	# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	live	⏭ creates auoinstall iso using the Ubuntu live dvd
	# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	server	⏭ creates auoinstall iso using the Ubuntu server dvd
	#
	# End of Documentation
	system::log_item "request received for: ${*}"
	# Check for other input and create them if not defined...
	kvm::util::read_common_options ${*} 

	# Set specific options for Ubuntu...
	kvm::util::read_distro_options ${*} 

	CONFIG=${_UserDesktopEnvironmentSelection}
	system::log_item "Config set to: $CONFIG"
	ISO_VER=${_role}
	system::log_item "ISO_VER set to: $ISO_VER"
	system::prepare_environment_for_iso_creation

	write_information "Retreive list of available Ubuntu versions..."
	system::get_tgt_ubuntu_version
	# all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# # Ask for desired version to use:
	# ubuntu_ver=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... \n $picachu "  25 110 "${all[-1]}" 3>&1 1>&2 2>&3) ;clear
	# [ "$ubuntu_ver" ] || ubuntu_ver=${all[-1]}

	# write_information Find the precice location of the requested ISO image:
	# ISO_URL=$(system::rtd_oem_find_live_release --version ${_tgt_ubuntu_ver} --distribution ${ubuntu_flavor} --desktop)
	# 	echo "requested iso for download : $ISO_URL"
	# 	ISO_FILENAME=$(basename $ISO_URL)
	# 	BASE=$(basename $ISO_URL .iso)


	# write_status "Checking if $ISO_FILENAME already downloaded..."
	# iso=$(find "$permanent_download_dir" -name "$ISO_FILENAME")
	# if [ ! -e "$iso" ]; then
	# 	echo "$ISO_FILENAME is not in cache, downloading..."
	# 	wget -nc $ISO_URL -P "$permanent_download_dir" || read -p "Failure to download ISO file"
	# 	iso="$permanent_download_dir/$ISO_FILENAME"
	# fi

	if [[ "$HOME" == "/root" ]] ; then HOME=/home/$SUDO_USER ; fi
	system::get_ubuntu_media $HOME/Virtual-DVDs/Downloaded

	mnt="${tmp_disc_dir:=$(mktemp -d )}"
	tmp_disc_dir=$mnt
	write_status "Mounting intallation media..."
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	write_status "Verifying media presence..."
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	write_information "Creating Installations media: $auto "
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	write_status "Modifying startup instructions...  "
		for f in splash.pcx splash.png ; do
			rtd_oem_setup_brand_splash_screen $auto/isolinux/$f
		done
		pushd ./$auto/isolinux/
			find splash.pcx | cpio -ov >>bootlogo
			find splash.png | cpio -ov >>bootlogo
		popd
	write_status "Unmounting $mnt... "
	umount $mnt || rtd_oem_pause 1


	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in live media... "
			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			system::make_preseed_cfg  $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in server image... "
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			system::make_preseed_cfg  ${*}

		;;
	esac


	target_iso="$put_iso_file_here_when_done/$auto.iso"


	if [[ -f $target_iso ]]; then
		rm $target_iso
	fi

	$bin_xorriso -as mkisofs -isohybrid-mbr "$isohdpfx_bin" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$put_iso_file_here_when_done/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$put_qcow_file_here_when_done/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$target_iso" "$put_qcow_file_here_when_done/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}




system::process_vm_opt_args() {
	# Description:
	# Function to evaluate input fiven to a VM build finction and set configuration override variables. 
	#
	# Globals:
	# Arguments: No[-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]ne
	# Outputs:
	# Returns: variables; _cpu _mem _dsk _task _role 
	# Usage:
	#
	# system::process_vm_opt_args [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]
	#
	#	Supported overrides:
	#	Role:   -r ${role}
	#	Task:   -t ${CONFIG}
	#	CPU:    -c ${_cpu} VCPU
	#	Memory: -m ${_mem} GB
	#	Disk:   -d ${_dsk} GB
	#
	#
	# call from another function or script:
	# 	system::process_vm_opt_args $@
	#
	# This will call this function and pass all parameters received here. Any parameters that match the expected
	# format will set the variable accordingly. 
	#
	# End of documentation

	# Check for optional default T-Shirts size overrides... 
	write_information "Set custom values for VM T-Shirts sizes, tasks and roles..."
	local OPTIND o a
	while getopts ':c:m:d:t:r:*' OPTION; do
		case "$OPTION" in
		c )
			_cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			_mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			_dsk="${OPTARG}"
			write_information "Custom disk size set to: ${OPTARG}"
		;;
		t )
			_task="${OPTARG}"
			write_information "Custom task set to: ${OPTARG}"
		;;
		r )
			_role="${OPTARG}"
			write_information "Custom role set to: ${OPTARG}"
		;;
		? )
			write_information "Usage: ${FUNCNAME[1]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]"
			return 0
		;;
		*)
			echo "Using default VM settings..."
			return 0
		;;
		esac
	done
	unset OPTIND
}



system::find_download_ubuntu_iso() {

	ubuntu_flavor="${1}"
	write_information "🔎 Retreive list of available $ubuntu_flavor versions..."
	case "$ubuntu_flavor" in
		ubuntu)
			declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$ubuntulogo"
		;;
		kubuntu)
			declare -a all_lts_versions=($(wget -O- cdimage.ubuntu.com/kubuntu/releases -q | perl -ne '/ (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$kubuntulogo"
		;;
		*)
			declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$ubuntulogo"
		;;
	esac

	tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor " --inputbox "\n 👍 Please pick an available \Z1 $ubuntu_flavor \Zn version by entering it below.
	Long Term Support Versions to choose from are the following:\Z4 ${all_lts_versions[*]} \Zn You may also enter an inbetween release version
	by typing its release number below as well. If you are not sure just let me choose intelligently for you... \n \Z1 ${dist_logo} \Zn"  30 90 "${all_lts_versions[-1]}" 3>&1 1>&2 2>&3)
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	[ "$tgt_ubuntu_ver" ] || tgt_ubuntu_ver=${all_lts_versions[-1]}

	: ${ubuntu_iso_url=$(system::rtd_oem_find_live_release $tgt_ubuntu_ver $ubuntu_flavor live)}
	: ${iso_filename:="$(basename $ubuntu_iso_url)"}
	: ${permanent_download_dir:="/var/lib/libvirt/boot/"}
	
	
	write_status "Checking if $iso_filename already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$iso_filename")
	if [ ! -e "$iso" ]; then
		write_warning "$iso_filename is not in cache, downloading..."
		wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "Failure to download ISO file"
		iso="$permanent_download_dir/$iso_filename"
	fi

}



system::create_physical_media_from_ubuntu_iso() {
	# Description:
	# Courtesy of 'covertsh':  ubuntu-autoinstall-generator
	# Function to automatically write ISO (virtual DVD/CD/BlueRay) to a thumb drive. No argumenst are
	# required, but a source ISO file location can may be provided when calling the function.
	# If information is required, but not provided, the end user will be interactively prompted.
	# This function requires elevated priviledges to be able to write media to a thumb drive
	# (boot sector) and other system restrictied activities. If the function is NOT called in a
	# script with elevated priviledges, it will attempt to elevate priviledges and prompt for a password.
	# Since writing a new bootable thumb drive is inherrently an interactive activity; a prompt will
	# be displayed asking what media to write to. If no media is present, a warning error
	# message will be displayed.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	#
	# "system::create_physical_media_from_ubuntu_iso" or "create_physical_media_from_iso path/to/file.iso"
	#
	# End of documentation

	cleanup() {
		trap - SIGINT SIGTERM ERR EXIT
		if [ -n "${tmpdir+x}" ]; then
			rm -rf "$tmpdir"
			log "🚽 Deleted temporary working directory $tmpdir"
		fi
	}

	trap cleanup SIGINT SIGTERM ERR EXIT
	script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
	[[ ! -x "$(command -v date)" ]] && echo "💥 date command not found." && exit 1
	today=$(date +"%Y-%m-%d")

	log() {
		write_host --cyan "[$(date +"%Y-%m-%d %H:%M:%S")] ${1-}"
	}

	die() {
		local msg=$1
		local code=${2-1} # Bash parameter expansion - default exit status 1. See https://wiki.bash-hackers.org/syntax/pe#use_a_default_value
		log "$msg"
		exit "$code"
	}

	usage() {
		create_physical_media_from_ubuntu_iso_usage="
		
		Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v] [-a] [-e] [-u user-data-file] [-m meta-data-file] [-k] [-c] [-r] [-s source-iso-file] [-d destination-iso-file]

		💁 This script will create fully-automated Ubuntu 20.04 Focal Fossa installation media.

		Available options:

		-h, --help              Print this help and exit
		-v, --verbose           Print script debug info
		-a, --all-in-one        Bake user-data and meta-data into the generated ISO. By default you will
					need to boot systems with a CIDATA volume attached containing your
					autoinstall user-data and meta-data files.
					For more information see: https://ubuntu.com/server/docs/install/autoinstall-quickstart
		-e, --use-hwe-kernel    Force the generated ISO to boot using the hardware enablement (HWE) kernel. Not supported
					by early Ubuntu 20.04 release ISOs.
		-u, --user-data         Path to user-data file. Required if using -a
		-m, --meta-data         Path to meta-data file. Will be an empty file if not specified and using -a
		-k, --no-verify         Disable GPG verification of the source ISO file. By default SHA256SUMS-$today and
					SHA256SUMS-$today.gpg in ${script_dir} will be used to verify the authenticity and integrity
					of the source ISO file. If they are not present the latest daily SHA256SUMS will be
					downloaded and saved in ${script_dir}. The Ubuntu signing key will be downloaded and
					saved in a new keyring in ${script_dir}
		-c, --no-md5            Disable MD5 checksum on boot
		-r, --use-release-iso   Use the current release ISO instead of the daily ISO. The file will be used if it already
					exists.
		-s, --source            Source ISO file. By default the latest daily ISO for Ubuntu 20.04 will be downloaded
					and saved as ${script_dir}/ubuntu-original-$today.iso
					That file will be used by default if it already exists.
		-d, --destination       Destination ISO file. By default ${script_dir}/ubuntu-autoinstall-$today.iso will be
					created, overwriting any existing file."
		echo $create_physical_media_from_ubuntu_iso_usage
	}


	parse_params() {
		# default values of variables set from params
		user_data_file=''
		meta_data_file=''
		ubuntu_flavor="ubuntu"
		dist_logo="$ubuntulogo"
		tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor " --inputbox "\n 👍 Please pick an available \Z1 $ubuntu_flavor \Zn version by entering it below.
		Long Term Support Versions to choose from are the following:\Z4 ${all_lts_versions[*]} \Zn You may also enter an inbetween release version
		by typing its release number below as well. If you are not sure just let me choose intelligently for you... \n \Z1 ${dist_logo} \Zn"  30 90 "${all_lts_versions[-1]}" 3>&1 1>&2 2>&3)
		case $? in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac
		clear
		: ${ubuntu_iso_url=$(system::rtd_oem_find_live_release $tgt_ubuntu_ver $ubuntu_flavor live)}
		download_url="https://cdimage.ubuntu.com/ubuntu-server/focal/daily-live/current"
		download_iso="focal-live-server-amd64.iso"
		original_iso="ubuntu-original-$today.iso"
		source_iso="${script_dir}/${original_iso}"
		destination_iso="${script_dir}/ubuntu-autoinstall-$today.iso"
		sha_suffix="${today}"
		gpg_verify=1
		all_in_one=0
		use_hwe_kernel=0
		md5_checksum=1
		use_release_iso=0

		while :; do
			case "${1-}" in
			-h | --help) usage ;;
			-v | --verbose) set -x ;;
			-a | --all-in-one) all_in_one=1 ;;
			-e | --use-hwe-kernel) use_hwe_kernel=1 ;;
			-c | --no-md5) md5_checksum=0 ;;
			-k | --no-verify) gpg_verify=0 ;;
			-r | --use-release-iso) use_release_iso=1 ;;
			-u | --user-data)
				user_data_file="${2-}"
				shift
				;;
			-s | --source)
				source_iso="${2-}"
				shift
				;;
			-d | --destination)
				destination_iso="${2-}"
				shift
				;;
			-m | --meta-data)
				meta_data_file="${2-}"
				shift
				;;
			-?*) die "Unknown option: $1" ;;
			*) break ;;
			esac
			shift
		done

		log "👶 Starting up..."

		# check required params and arguments
		if [ ${all_in_one} -ne 0 ]; then
			[[ -z "${user_data_file}" ]] && die "💥 user-data file was not specified."
			[[ ! -f "$user_data_file" ]] && die "💥 user-data file could not be found."
			[[ -n "${meta_data_file}" ]] && [[ ! -f "$meta_data_file" ]] && die "💥 meta-data file could not be found."
		fi

		if [ "${source_iso}" != "${script_dir}/${original_iso}" ]; then
			[[ ! -f "${source_iso}" ]] && die "💥 Source ISO file could not be found."
		fi

		if [ "${use_release_iso}" -eq 1 ]; then
			download_url="https://releases.ubuntu.com/focal"
			log "🔎 Checking for current release..."
			download_iso=$(curl -sSL "${download_url}" | grep -oP 'ubuntu-20\.04\.\d*-live-server-amd64\.iso' | head -n 1)
			original_iso="${download_iso}"
			source_iso="${script_dir}/${download_iso}"
			current_release=$(echo "${download_iso}" | cut -f2 -d-)
			sha_suffix="${current_release}"
			log "💿 Current release is ${current_release}"
		fi

		destination_iso=$(realpath "${destination_iso}")
		source_iso=$(realpath "${source_iso}")

		return 0
	}

	ubuntu_gpg_key_id="843938DF228D22F7B3742BC0D94AA3F0EFE21092"

	parse_params "$@"

	tmpdir=$(mktemp -d)

	if [[ ! "$tmpdir" || ! -d "$tmpdir" ]]; then
		die "💥 Could not create temporary working directory."
	else
		log "📁 Created temporary working directory $tmpdir"
	fi

	log "🔎 Checking for required utilities..."
	[[ ! -x "$(command -v xorriso)" ]] && die "💥 xorriso is not installed. On Ubuntu, install  the 'xorriso' package."
	[[ ! -x "$(command -v sed)" ]] && die "💥 sed is not installed. On Ubuntu, install the 'sed' package."
	[[ ! -x "$(command -v curl)" ]] && die "💥 curl is not installed. On Ubuntu, install the 'curl' package."
	[[ ! -x "$(command -v gpg)" ]] && die "💥 gpg is not installed. On Ubuntu, install the 'gpg' package."
	[[ ! -f "/usr/lib/ISOLINUX/isohdpfx.bin" ]] && die "💥 isolinux is not installed. On Ubuntu, install the 'isolinux' package."
	log "👍 All required utilities are installed."

	if [ ! -f "${source_iso}" ]; then
		log "🌎 Downloading ISO image for Ubuntu 20.04 Focal Fossa..."
		curl -NsSL "${download_url}/${download_iso}" -o "${source_iso}"
		log "👍 Downloaded and saved to ${source_iso}"
	else
		log "☑️ Using existing ${source_iso} file."
		if [ ${gpg_verify} -eq 1 ]; then
			if [ "${source_iso}" != "${script_dir}/${original_iso}" ]; then
				log "⚠️ Automatic GPG verification is enabled. If the source ISO file is not the latest daily or release image, verification will fail!"
			fi
		fi
	fi

	if [ ${gpg_verify} -eq 1 ]; then
		if [ ! -f "${script_dir}/SHA256SUMS-${sha_suffix}" ]; then
			log "🌎 Downloading SHA256SUMS & SHA256SUMS.gpg files..."
			curl -NsSL "${download_url}/SHA256SUMS" -o "${script_dir}/SHA256SUMS-${sha_suffix}"
			curl -NsSL "${download_url}/SHA256SUMS.gpg" -o "${script_dir}/SHA256SUMS-${sha_suffix}.gpg"
		else
			log "☑️ Using existing SHA256SUMS-${sha_suffix} & SHA256SUMS-${sha_suffix}.gpg files."
		fi

		if [ ! -f "${script_dir}/${ubuntu_gpg_key_id}.keyring" ]; then
			log "🌎 Downloading and saving Ubuntu signing key..."
			gpg -q --no-default-keyring --keyring "${script_dir}/${ubuntu_gpg_key_id}.keyring" --keyserver "hkp://keyserver.ubuntu.com" --recv-keys "${ubuntu_gpg_key_id}"
			log "👍 Downloaded and saved to ${script_dir}/${ubuntu_gpg_key_id}.keyring"
		else
			log "☑️ Using existing Ubuntu signing key saved in ${script_dir}/${ubuntu_gpg_key_id}.keyring"
		fi

		log "🔐 Verifying ${source_iso} integrity and authenticity..."
		gpg -q --keyring "${script_dir}/${ubuntu_gpg_key_id}.keyring" --verify "${script_dir}/SHA256SUMS-${sha_suffix}.gpg" "${script_dir}/SHA256SUMS-${sha_suffix}" 2>/dev/null
		if [ $? -ne 0 ]; then
			rm -f "${script_dir}/${ubuntu_gpg_key_id}.keyring~"
			die "👿 Verification of SHA256SUMS signature failed."
		fi

		rm -f "${script_dir}/${ubuntu_gpg_key_id}.keyring~"
		digest=$(sha256sum "${source_iso}" | cut -f1 -d ' ')
		set +e
		grep -Fq "$digest" "${script_dir}/SHA256SUMS-${sha_suffix}"
		if [ $? -eq 0 ]; then
			log "👍 Verification succeeded."
			set -e
		else
			die "👿 Verification of ISO digest failed."
		fi
	else
		log "🤞 Skipping verification of source ISO."
	fi
	log "🔧 Extracting ISO image..."
	xorriso -osirrox on -indev "${source_iso}" -extract / "$tmpdir" &>/dev/null
	chmod -R u+w "$tmpdir"
	rm -rf "$tmpdir/"'[BOOT]'
	log "👍 Extracted to $tmpdir"

	if [ ${use_hwe_kernel} -eq 1 ]; then
		if grep -q "hwe-vmlinuz" "$tmpdir/boot/grub/grub.cfg"; then
			log "☑️ Destination ISO will use HWE kernel."
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/isolinux/txt.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/isolinux/txt.cfg"
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/boot/grub/grub.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/boot/grub/grub.cfg"
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/boot/grub/loopback.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/boot/grub/loopback.cfg"
		else
			log "⚠️ This source ISO does not support the HWE kernel. Proceeding with the regular kernel."
		fi
	fi

	log "🧩 Adding autoinstall parameter to kernel command line..."
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/isolinux/txt.cfg"
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/boot/grub/grub.cfg"
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/boot/grub/loopback.cfg"
	log "👍 Added parameter to UEFI and BIOS kernel command lines."

	if [ ${all_in_one} -eq 1 ]; then
		log "🧩 Adding user-data and meta-data files..."
		mkdir "$tmpdir/nocloud"
		cp "$user_data_file" "$tmpdir/nocloud/user-data"
		if [ -n "${meta_data_file}" ]; then
			cp "$meta_data_file" "$tmpdir/nocloud/meta-data"
		else
			touch "$tmpdir/nocloud/meta-data"
		fi
		sed -i -e 's,---, ds=nocloud;s=/cdrom/nocloud/  ---,g' "$tmpdir/isolinux/txt.cfg"
		sed -i -e 's,---, ds=nocloud\\\;s=/cdrom/nocloud/  ---,g' "$tmpdir/boot/grub/grub.cfg"
		sed -i -e 's,---, ds=nocloud\\\;s=/cdrom/nocloud/  ---,g' "$tmpdir/boot/grub/loopback.cfg"
		log "👍 Added data and configured kernel command line."
	fi

	if [ ${md5_checksum} -eq 1 ]; then
		log "👷 Updating $tmpdir/md5sum.txt with hashes of modified files..."
		md5=$(md5sum "$tmpdir/boot/grub/grub.cfg" | cut -f1 -d ' ')
		sed -i -e 's,^.*[[:space:]] ./boot/grub/grub.cfg,'"$md5"'  ./boot/grub/grub.cfg,' "$tmpdir/md5sum.txt"
		md5=$(md5sum "$tmpdir/boot/grub/loopback.cfg" | cut -f1 -d ' ')
		sed -i -e 's,^.*[[:space:]] ./boot/grub/loopback.cfg,'"$md5"'  ./boot/grub/loopback.cfg,' "$tmpdir/md5sum.txt"
		log "👍 Updated hashes."
	else
		log "🗑️ Clearing MD5 hashes..."
		echo > "$tmpdir/md5sum.txt"
		log "👍 Cleared hashes."
	fi

	log "📦 Repackaging extracted files into an ISO image..."
	cd "$tmpdir"
	xorriso -as mkisofs -r -V "ubuntu-autoinstall-$today" -J -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin -boot-info-table -input-charset utf-8 -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "${destination_iso}" . &>/dev/null
	cd "$OLDPWD"
	log "👍 Repackaged into ${destination_iso}"

	die "✅ Completed." 0
}




tool::compress_all_items_here() {
	# Description: Function to compress the contents of the present working directory.
	#
	# Purpose:	To compress all files and folders individually found in the current folder.
	#		The current folder refers to the present working directory "PWD". Compression method
	#		is 7z. This privides a high level of compression.
	#
	# Globals:
	# Arguments: --noprompt, --encrypt (mutually exclusive)
	# Outputs:
	# Returns:
	# Usage:	compress_all_items_here [--compress] [--noprompt]
	# Usage:	Simply call this function to accomplish this task.
	#
	# Arguments:	No parameters required for basic function (user will be prompted).
	#
	# End of documentation

	if hash 7z ; then
		write_information "7z is present, good..."
	else
		write_error "the 7z (7 zip) program was not found"
		for i in p7zip-full 7za
		do
			for i in dnf zypper apt-get ; do
				write_warning "Installing software requires elevated priviladges!"
				write_status "Peare enter password beloow (if not cached):"
				sudo $i install -y p7zip-full
			done
			exit 0
		done
	fi

	if [[ ! "$1" == "--noprompt" ]]; then
		if hash dialog 2>/dev/null ; then
			if ( dialog --backtitle "${BRANDING:-"${FUNCNAME[0]}"} ${1}" --title "Compress Content Here" --colors --cr-wrap --no-collapse --no-button "NO: Quit" --yes-button "YES: Compress" --yesno "Hello ${USER}... I am going to compress each file or folder that I find here: $(pwd) These are: \Z5 \n$(ls -h1 -F -I "*.7z")" 20 90 ); then
				clear
			else
				clear
				exit
			fi
		else
			clear
			write_host --cyan  "Hello ${USER}... I am going to compress each file or folder that I find in this folder. These are:"
			ls -I "*.7z" --color=always
			echo -e " \n"
			write_information "To cancel this, just close the terminal or press [CRTL] + [C]."
			read -p "Press the [ENTER] key to continue..."
		fi
	fi


	if echo ${*} |grep "encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" --stdout --insecure --passwordbox "\n Please provide a passphrase for the encryption. \n Please do not forget it!" 10 90 )
		ret=$? ; clear
		case $ret in
			0)
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $(ls -I "*.7z")
				do
					7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS
				result="
				\n Created the following archives encrypted with a pass-phrase:

				\n \Z1  $(ls *.7z)"
				dialog::display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		for line in $(ls -I "*.7z")
		do
			7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=64m -ms=on -mhe=on $line.7z $line
		done
		IFS=$SAVEIFS
		result="
		Created the following archives un-encrypted:

		\n \Z1  $(ls *.7z)"
		dialog::display_result "Done Compressing"
	fi
}


tool::compress_provided_items() {
	# Description: Function to compress the contents of the present working directory.
	#
	# Purpose:	To compress all files and folders individually found in the current folder.
	#		The current folder refers to the present working directory "PWD". Compression method
	#		is 7z. This privides a high level of compression.
	#
	# Globals:
	# Arguments: --noprompt, --encrypt (mutually exclusive)
	# Outputs:
	# Returns:
	# Usage:	compress_provided_items [--encrypt] [--noprompt]
	# Usage:	Simply call this function to accomplish this task.
	#
	# Arguments:	No parameters required for basic function (user will be prompted).
	#
	# End of documentation
	list="$*"
	if echo "${@}" |grep "--encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" \
                  --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" \
                  --stdout \
                  --insecure \
                  --passwordbox "\n To encrypt the content you have to give me a phrase to encrypt it with. \n This can be anything in one long word, but never forget it!" \
                  10 90 )
		ret=$?
		case $ret in
			0)

				echo "☕ Please be patient, Large sets of files may take serious time..."
				list="${list:9:1000}"
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $list ;
				do
					7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS

				result="
				\n♹ Created the following archive(s) encrypted: \n
				\n STATUS	FILENAME
				$(
				echo \\n
				for d in $list; do
				[[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n"
				done
				)
				\n Please review the above: ⏫"
				dialog::display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		write_information "☕ Please be patient, Large sets of files may take serious time..."

		for item in ${list} ;
		do
			case $item in
				--noprompt ) echo skipp >/dev/null ;;
				* ) 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on $item.7z $item ;;
			esac
		done

		IFS=$SAVEIFS
		result="
		Created the following archive(s): \n
		\n STATUS	FILENAME
		$(
		echo \\n
		for d in ${list} ; do
			case $d in
				--noprompt ) echo skipp >/dev/null ;;
				* ) [[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n" ;;
			esac
		done
		)
		\n Please review the above: ⏫"
		if echo ${*} |grep "--noprompt" ; then
			echo $result
		else
			dialog::display_result "Done creating encrypted archives"
		fi
	fi
}



tool::recompress_all_items_in_folder() {
	# Description: Function to recompress all archive files in the current directory to a specified format.
	#
	# Purpose:    To convert all archive files found in the current directory into a different archive format.
	#             This function supports converting to and from 7z, zip, rar, tar, gz, and bz2 formats. It aims
	#             to make file management more efficient by allowing users to standardize their archive formats.
	#
	# Globals:    None.
	# Arguments:  1. target_format - The archive format to which all files will be recompressed. Supported formats
	#             are 7z, zip, rar, tar, gz, and bz2.
	# Outputs:    Outputs are the newly created archive files in the specified format. Original files can be optionally
	#             removed after successful recompression.
	# Returns:    Returns 0 on success, or 1 if an unsupported format is specified or if any errors occur during
	#             the recompression process.
	# Usage:      recompress_all_items_here <target_format>
	#             Example: recompress_all_items_here zip
	#             This will recompress all supported archive files in the current directory to zip format.
	#
	# Notes:      - This function requires the corresponding command-line utilities for the specified formats
	#               (e.g., 7z, zip, rar, tar, gzip, bzip2) to be installed and accessible in the system's PATH.
	#             - It creates temporary directories for decompression and subsequent recompression processes,
	#               which are removed upon completion.
	#
	# End of documentation

	local tgt_format="${1:-"7z"}"

	case $tgt_format in
		7z)
		write_information "Recompressing all items in the current folder to 7z format..."
		for i in *.zip *.rar *.tar *.gz *.bz2; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on "$base.7z" "$base" && rm -r "$base"
		done
		;;
		zip)
		write_information "Recompressing all items in the current folder to zip format..."
		for i in *.7z *.rar *.tar *.gz *.bz2; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && zip -r "$base.zip" "$base" && rm -r "$base"
		done
		;;
		rar)
		write_information "Recompressing all items in the current folder to rar format..."
		for i in *.7z *.zip *.tar *.gz *.bz2; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && rar a "$base.rar" "$base" && rm -r "$base"
		done
		;;
		tar)
		write_information "Recompressing all items in the current folder to tar format..."
		for i in *.7z *.zip *.rar *.gz *.bz2; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && tar cvf "$base.tar" "$base" && rm -r "$base"
		done
		;;
		gz)
		write_information "Recompressing all items in the current folder to gzip format..."
		for i in *.7z *.zip *.rar *.tar *.bz2; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && tar cvzf "$base.tar.gz" "$base" && rm -r "$base"
		done
		;;
		bz2)
		write_information "Recompressing all items in the current folder to bzip2 format..."
		for i in *.7z *.zip *.rar *.tar *.gz; do
			base="${i%%.*}"
			mkdir "$base" && 7z x "$i" -o"$base"/ && tar cvjf "$base.tar.bz2" "$base" && rm -r "$base"
		done
		;;
		*)
		write_error "Unknown format: $tgt_format"
		return 1
		;;
	esac
}



tool::recompress_provided_items() {
	# Description: Function to recompress specified files to a target compression format.
	#
	# Purpose:    To recompress a list of files (specified individually or by wildcard patterns) into a specified target format. 
	#             This function allows for converting between popular compression formats such as zip, rar, and 7z, optimizing 
	#             for different compression needs or compatibility requirements.
	#
	# Globals:    None explicitly used within the function, but assumes the existence of external logging functions 
	#             `write_information` and `write_error` for output messages.
	#
	# Arguments:  
	#   $1: A list of files or a wildcard pattern specifying the files to be recompressed (e.g., "*.zip" or "file1.zip file2.7z").
	#   $2: The target compression format (supported formats include "7z", "zip", "rar").
	#
	# Outputs:    Informational and error messages regarding the recompression process.
	#
	# Returns:    
	#   0: If the recompression process completes successfully for all specified files.
	#   1: If an unknown target format is specified or if any errors occur during the recompression process.
	#
	# Usage:      recompress_all_items_here "*.zip" 7z
	#             This command would find all .zip files in the current directory and recompress them into the 7z format.
	#
	#             recompress_all_items_here "archive.7z" zip
	#             This command would recompress the specified "archive.7z" file into the zip format.
	#
	# Note:       The function relies on external tools (7z, zip, rar) for compression tasks. Ensure these are installed 
	#             and accessible in the system's PATH for the function to work correctly. The function also makes use of 
	#             temporary directories for the recompression process, which are cleaned up after use.
	#
	# End of documentation

	local files=($1) # The list of files to be recompressed, supports wildcards or specific filenames
	local tgt_format="$2" # The target format for recompression

	case $tgt_format in
		7z)
		write_information "Recompressing specified items to 7z format..."
		for i in "${files[@]}" ; do
			local base="${i%.*}"
			mkdir "${base}" && 7z x "${i}" -o"${base}/" && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on "${base}.7z" "${base}/" && rm -r "${base}"
		done
		;;
		zip)
		write_information "Recompressing specified items to zip format..."
		for i in "${files[@]}" ; do
			local base="${i%.*}"
			mkdir "${base}" && 7z x "${i}" -o"${base}/" && zip -r "${base}.zip" "${base}/" && rm -r "${base}"
		done
		;;
		rar)
		write_information "Recompressing specified items to rar format..."
		for i in "${files[@]}" ; do
			local base="${i%.*}"
			mkdir "${base}" && 7z x "${i}" -o"${base}/" && rar a "${base}.rar" "${base}/" && rm -r "${base}"
		done
		;;
		*)
		write_error "Unknown format: $tgt_format"
		return 1
		;;
	esac
}



tool::up_2_date() {
	# Description: Function to simplify updating system completely. At present this function sets the
	# highest preference to use "pkcon", the command line interface of "Package Kit" since
	# this is the most consistent across different distrbutions. It may even work on BSD.
	# Only if "pkcon" is not available, will the function use the identified distro native
	# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may
	# alias another distributions command (like SuSE does with apt) to be helpfull.
	# This is one of the first update functions written and is kept for compatibility.
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns: 0/1/3 where 1/0 = sucess/fail and 3 = package manager NOT found
	# Usage: tool::up_2_date
	# End of documentation
	ensure_admin
	write_status "Running up2date function:"

	if hash pkcon 2>/dev/null; then
		pkcon update -y
	elif hash yum 2>/dev/null; then
		yum update -y
	elif hash apt 2>/dev/null; then
		apt-get update
		apt-get upgrade -y
		apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		zypper --terse --color --table-style=6 list-updates
                zypper --terse --color --table-style=6 update -y
	else
		return 3
	fi
}



system::create_swapfile() {
	# Description: Function to create a swapfile and enable it automatically.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# Usage: [function_name] [options]
	# Arguments:
	# 	[size] : size in MB or GB
	# 	[path] : path to file (Default path: /swapfile)
	#
	# NOTE:
	# The Linux Kernel divides RAM into chunks of memories and the swapping process is
	# when the Linux Kernel uses a hard disk space (swap space) to store information from RAM
	# and thus releases some RAM space. That is why when you install a Linux distribution, the
	# installation wizard usually asks you to assign some space for the system and another for the swap.
	#
	# Using swap is a very useful way to extend the RAM because it provides the necessary additional
	# memory when the RAM space has been exhausted and a process has to be continued. It is especially
	# recommended when you have less than 1Gb of RAM. Although in the end, everything depends on you.
	# 
	# End of documentation


	SWAP_SIZE=$1
	SWAP_PATH=$2



	: "${SWAP_SIZE:=4G}"
	: "${SWAP_PATH:="/swapfile-${RANDOM}"}"

	write_information "Swap Size: ${SWAP_SIZE}"
	write_information "File Path: ${SWAP_PATH}"

	usage_mesage () {
		write_host --blue "
		Usage: $0 {size}
		Example: $0 4G
		(Default path: /swapfile)
		Usage with optional path: $0 {size} {path}"
	}

	if [[ -z "${SWAP_SIZE}" ]]; then
		# If we are not given any size to make the swaptfile... well...
		write_error "Please tell me what size swap file to make!" 
		usage_mesage
		exit 1
	elif [[ ! "${SWAP_SIZE:0:1}" -ge "1" ]]; then
		# Fail if the argument is not a numer
		write_error "The size for swap file must be a number!" 
		usage_mesage
		exit 1
	else
		if [[ -e ${SWAP_PATH} ]]; then
			write_error "ERROR: the file ${SWAP_PATH} already exists! Please choose a different name."
			exit 1
		fi
		write_host --cyan "Welcome to Swap setup script! This script will automatically setup a swap file and enable it."

		fallocate -l "${SWAP_SIZE}" "${SWAP_PATH}"	&& write_information "Allocated ${SWAP_SIZE} swap file: ${SWAP_PATH}" || (write_error "Error creting actual swapfile using fallocate! "; exit 1)
		chmod 600 "${SWAP_PATH}"			&& write_information "Sucessfully modified permissions on $SWAP_PATH" || (write_error "Error changing premissions" ; exit 1)
		mkswap "${SWAP_PATH}"				&& (write_status "Sucessfully formatted ${SWAP_PATH} as a swap partition" ; file -s ${SWAP_PATH}) || (write_error "Error formating ${SWAP_PATH} as a swapspace!" ; exit 1)
		swapon "${SWAP_PATH}" 				# Turn on the swap file...
		if [ $? = 0 ]; then
			echo "${SWAP_PATH}   none    swap    sw    0   0" | sudo tee /etc/fstab -a # Add to fstab
			write_status "Done! You now have a ${SWAP_SIZE} swap file at ${SWAP_PATH}"
		else
			if df -T ${SWAP_PATH} |grep btrfs >/dev/null ; then
				write_error "ERROR: swapfiles cannot be allocated on BTRFS. \n The root filesystem is BTRFS. Please use an ext4 or xfs partition.
				This is a BUG and hopefully it will be fixed soon... "
				exit 1
			else
				write_error "An unknown error occurred with starting the swap partition.."
				exit 1
			fi
		fi

	fi
}






################################################################################################																		
#     ........         ..........         ........                            
#  ..';;::::;,'.     ..,;::::::;,..     .',;::::;;'..                         
# .';::::::::::;.   .,::::::::::::,.   .;::::::::::;..                        
# .;::::::::::::,. .'::::::::::::::'. .,::::::::::::;.                        
# .:::::::::::::;. .,::::::::::::::,. .;:::::::::::::.                        
# .,::::::::::::'. ..;::::::::::::;.. .,::::::::::::,.                        
#  .,;::::::::;'.   ..;::::::::::,..   .';:::::::::,.                         
#   ..',,;;,,...      ..',;;;,,'..       ..,,;;,,'..                          
#       ....             ......             ....                              
#                
#                                                                            
# MMMMMMMMMMMWWWNNNNNXXXXXXXXXXXXNNNNNWWMMMMMMMMMMMM
# MMMMMWWNXXXK00OkxddooollllllooodxxkO0KKXXNNWWMMMMM
# MWNXXK0kdlc:;,'....................',;:loxk0KXXNWM
# NK0xl:,..,c:,;cc,,cc,,,.,;;:c:.';,:c;;'';'';:lxOKN
# X0k;....,OdcoOk::kxdxkd;xOkOdxddk;x0;lkkd'....'d0X
# X0x'.....lollOk:lkc';xd;x0kOkkddx.ok..kK:......l0K
# K0d.....'clkO0x;:kdoxxxokkkOodxxx.ok..ok'......l0K
# K0o......:lc;:lc;;cl,'cl;',;',;;;.,;..,;.......lOK
# K0o...........  ...............................o0K
# K0o.........',;::cloolllloooddolc:;;'..........d0K
# K0o......:lodxxxxl:,'.......,;ldxxxxxolc,.....,k0X
# K0d.....;dxddxxc'. .''''''''. .'cdxdxddkl.....cO0N
# X0x,....,dxdxd,. .'''......',,.. 'oxddxx:.....o0KW
# NKO:.....oxxd,  .,..';:,. ....,'. 'oxdxd'....;k0XM
# WK0o.....cxxc. .,. .,dOo.  .'..,. .:xxxc.....o0KWM
# MX0k;....,dk:. ',. .oxdc.......''  ;xxo'....:k0NMM
# MWKOo.....ckc. .,. .:dd;.   ...,. .:xx:....'x0XWMM
# MMN0Oc....'ox,  .,....',......,'. 'dxc.....oOKWMMM
# MMWX0k;....,dd,. .'''.......''...,okl.....lOKNMMMM
# MMMWK0x,....,dxc'. ..''''''.. .'cdxl'....lOKNMMMMM
# MMMMWK0d'....'oxxo:;'......';:ldxxc.....lO0NMMMMMM
# MMMMMWK0d'.....cdxxxxddodddxxxdxd:....'oOKNWMMMMMM
# MMMMMMWK0x,.....;dxxdddddddxdxxl'....,x0KNMMMMMMMM
# MMMMMMMWX0k:.....'cdxdxxxxxxxo;.....ck0XWMMMMMMMMM
# MMMMMMMMWX0Ol'.....,ldxdxxxo;.....,oOKNWMMMMMMMMMM
# MMMMMMMMMWNKOx;......,lolc;......ck0XNWMMMMMMMMMMM
# MMMMMMMMMMMWX0Oo,..............:x0KNWMMMMMMMMMMMMM
# MMMMMMMMMMMMWNX0kl'..........;dOKXWMMMMMMMMMMMMMMM
# MMMMMMMMMMMMMMWNK0kl'......:dOKXWMMMMMMMMMMMMMMMMM
# MMMMMMMMMMMMMMMMWNK0ko;,cox0KNWMMMMMMMMMMMMMMMMMMM
# MMMMMMMMMMMMMMMMMWWWXK0OKKXNWMMMMMMMMMMMMMMMMMMMMM
# MMMMMMMMMMMMMMMMMMMMMWNNWWMMMMMMMMMMMMMMMMMMMMMMMM
#
################################################################################################
#
#  .d8888b.                                     d8b 888             
# d88P  Y88b                                    Y8P 888             
# Y88b.                                             888             
#  "Y888b.    .d88b.   .d8888b 888  888 888d888 888 888888 888  888 
#     "Y88b. d8P  Y8b d88P"    888  888 888P"   888 888    888  888 
#       "888 88888888 888      888  888 888     888 888    888  888 
# Y88b  d88P Y8b.     Y88b.    Y88b 888 888     888 Y88b.  Y88b 888 
#  "Y8888P"   "Y8888   "Y8888P  "Y88888 888     888  "Y888  "Y88888 
#                                                               888 
#                                                          Y8b d88P 
#                                                           "Y88P"  
#
################################################################################################








security::enable_firewall() {
	# Description:
	# Function to enable the system firewall and add a rule to allow SSH.
	# This function attempts to detect and configure UFW or firewalld,
	# common in Ubuntu/Debian, Fedora, and SUSE systems. If neither is
	# detected, it will display a message and prompt the user to enable
	# the firewall and configure SSH access manually.
	#
	# Globals:
	# Arguments: None
	# Outputs:
	# Returns:
	# Usage:
	# End of documentation

	write_warning "Configuring Firewall..."

	if hash ufw 2>/dev/null; then
		write_status "Using UFW to enable firewall and allow SSH..."
		ufw enable && ufw allow ssh
	elif hash firewall-cmd 2>/dev/null; then
		write_status "Using firewalld to enable firewall and allow SSH..."
		firewall-cmd --zone=public --add-service=ssh --permanent
		firewall-cmd --reload
	else
		write_error "Firewall tool not recognized. Please enable the firewall and configure SSH access manually."
    fi

}






security::check_if_password_pOwned() {
	# Description: 
	# Function to query a user for a password suggestion and check it against P0wned data base online.
	# Globals: $RTD_GUI
	# Arguments: None
	# Outputs: dialog box
	# Returns:
	# Usage: security::check_if_password_pOwned

	# End of documentation

	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep "$(echo "${sha1:5:35}" | tr '[:lower:]' '[:upper:]')");
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	dialog::display_result "Password P0wned Status"
}






security::scan_for_malware() {
	# Description: This function uses clam AV to scan for malware in a given location.
	# Globals: None.
	# Arguments: None
	# Outputs: STDOUT
	# Returns: STDERR & STDOUT
	# Usage: scan_for_malware /directory/to/scan
	#
	# End of documentation

	# Set the location of the quarantined files
	QUARANINE=~/VIRUS
	if [ ! -d "$QUARANINE" ]; then
		mkdir "$QUARANINE"
	fi

	# set the location of the log file
	CLAMSCANLOGFILE=~/clamscan.log
	SCANDIR=$@

	# First discover what menu system is installed. Some systems use "dialog" and
	# other systems use whiptail for the terminal to show menus and dialogs.

	if ! type clamscan ; then
		check_dependencies clamscan && exit
	fi




	write_host --purple "
	___________________________________________________

	[   Setting    ] [           Value             ]
	Logging to:         $CLAMSCANLOGFILE
	Quarantine in:      $QUARANINE

	___________________________________________________
	Starting scan....
	Scanning folder: ${*}"

	# Run the scan function
	clamscan $SCANDIR -r -a -i -l $CLAMSCANLOGFILE --bytecode=yes --stdout  --phishing-sigs --bell --algorithmic-detection=yes --move="$QUARANINE"
	return $?
}







###########################################################################################
#
#                  .88888888:.
#                 88888888.88888.
#               .8888888888888888.
#               888888888888888888
#               88' _`88'_  `88888
#               88 88 88 88  88888
#               88_88_::_88_:88888
#               88:::,::,:::::8888
#               88`:::::::::'`8888
#              .88  `::::'    8:88.
#             8888            `8:888.
#           .8888'             `888888.
#          .8888:..  .::.  ...:'8888888:.
#         .8888.'     :'     `'::`88:88888
#        .8888        '         `.888:8888.
#       888:8         .           888:88888
#     .888:88        .:           888:88888:
#     8888888.       ::           88:888888
#     `.::.888.      ::          .88888888
#    .::::::.888.    ::         :::`8888'.:.
#   ::::::::::.888   '         .::::::::::::
#   ::::::::::::.8    '      .:8::::::::::::.
#  .::::::::::::::.        .:888:::::::::::::
#  :::::::::::::::88:.__..:88888:::::::::::'
#   `'.:::::::::::88888888888.88:::::::::'
#         `':::_:' -- '' -'-' `':_::::'`
###########################################################################################
#  .d8888b.            .d888 888                                                           
# d88P  Y88b          d88P"  888                                                           
# Y88b.               888    888                                                           
#  "Y888b.    .d88b.  888888 888888 888  888  888  8888b.  888d888 .d88b.                  
#     "Y88b. d88""88b 888    888    888  888  888     "88b 888P"  d8P  Y8b                 
#       "888 888  888 888    888    888  888  888 .d888888 888    88888888                 
# Y88b  d88P Y88..88P 888    Y88b.  Y88b 888 d88P 888  888 888    Y8b.                     
#  "Y8888P"   "Y88P"  888     "Y888  "Y8888888P"  "Y888888 888     "Y8888                  
                                                                                         
                                                                                         
                                                                                         
# 888b     d888                                                                     888    
# 8888b   d8888                                                                     888    
# 88888b.d88888                                                                     888    
# 888Y88888P888  8888b.  88888b.   8888b.   .d88b.  88888b.d88b.   .d88b.  88888b.  888888 
# 888 Y888P 888     "88b 888 "88b     "88b d88P"88b 888 "888 "88b d8P  Y8b 888 "88b 888    
# 888  Y8P  888 .d888888 888  888 .d888888 888  888 888  888  888 88888888 888  888 888    
# 888   "   888 888  888 888  888 888  888 Y88b 888 888  888  888 Y8b.     888  888 Y88b.  
# 888       888 "Y888888 888  888 "Y888888  "Y88888 888  888  888  "Y8888  888  888  "Y888 
#                                               888                                        
#                                          Y8b d88P                                        
#                                           "Y88P"     
###########################################################################################








software::package_kit::add_package() {
	# Description: Function to simplify the installation of software by including all display and
	# installation logic for a given software provider. This function should work consistently 
	# on any distribution with the back end:     
	#     Advanced Packaging Tool (APT)
	#     Conary
	#     libdnf[10] & librepo,[11] the libraries upon which DNF, (the successor to yum) builds
	#     Entropy
	#     Opkg
	#     pacman
	#     PiSi
	#     Portage
	#     Smart Package Manager
	#     urpmi
	#     YUM
	#     ZYpp
	# PackageKit is a free and open-source suite of software applications designed to provide a 
	# consistent and high-level front end for a number of different package management systems. 
	# PackageKit was created by Richard Hughes in 2007,[2][3] and first introduced into an 
	# operating system as a default application in May 2008 with the release of Fedora 9.[4]
	# 
	# The suite is cross-platform, though it is primarily targeted at Linux distributions which 
	# follow the interoperability standards set out by the freedesktop.org group. It uses the 
	# software libraries provided by the D-Bus and Polkit projects to handle inter-process 
	# communication and privilege negotiation respectively. 
	# Arguments: package_name
	# Outputs:
	# Returns: Does not return error as it is designed for best effort smooth operation.  
	# Usage: Call the function with one arguments matching then name of the package you need to install.
	#
	# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}
	
	if pkcon resolve "${1}" --filter installed | grep "${1}" &>/dev/null ; then
		write_status "The software package ${1} is Allready installed... " 
		system::log_item "The software package ${1} is Allready installed... "
	else
		if pkcon resolve "${1}" | grep "${1}" &>/dev/null; then
			write_status "The software package ${1} found in repository, installing... "
			system::log_item "The software package ${1} found in repository, installing... "
			pkcon install "${1}" --noninteractive --cache-age 5000 
			if [ $? = 0 ] ; then
				write_status "The software package ${1} transaction appears to have been sucessful..."
				system::log_item "The software package ${1} transaction appears to have been sucessful..."
			else
				write_warning "There appears to have been some problem installing the package ${1}..."
				system::log_item "There appears to have been some problem installing the package ${1}..."
			fi
		else
			write_error "The software package ${1} is not available in any configured repository..." 
			system::log_item "The software package ${1} is not available in any configured repository..." 
		fi	
	fi

}






software::package_kit::remove_package() {
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpak
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpak. A preference order between package system and
# snap or flatpak use.
# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}

	(
	if pkcon resolve "${1}" --filter installed | grep "${1}" &>/dev/null ; then
		write_status " ✓ The software package ${1} is installed, removing as requested... "
		pkcon remove "${1}" --noninteractive
		if [ $? = 0 ] ; then
			write_status "The software package ${1} transaction appears to have been sucessful..."
		else
			write_warning "There appears to have been some problem removing the package ${1}..."
		fi
	else
		write_information "The software package ${1} is not installed, no need for action..." 
	fi
	) | tee -a ${_LOGFILE}
}









software::ensure_software_store_available() {
# Description: Function to ensure that flatpak is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# GNOME Software is a utility for installing applications and updates on Linux.
# It is part of the GNOME Core Applications, and was introduced in GNOME 3.10.[3]
#
# It is the GNOME front-end to the PackageKit, in turn a front-end to several package management
# systems, which include systems based on both RPM and DEB.
#
# The program is used to add and manage software repositories as well as Ubuntu
# Personal Package Archives (PPA). Ubuntu replaced its previous Ubuntu Software Center
# program with GNOME Software starting with Ubuntu 16.04 LTS,[5] and re-branded it as "Ubuntu Software".
#
# It also supports fwupd for servicing of system firmware.[6]
#
# GNOME Software removed Snap support in July 2019, due to code quality issues, lack of integration
# (specifically, the user can't tell what snap is doing after they click "install" and that it
# generally ignores GNOME's settings), and the fact that it competes with the GNOME-supported Flatpak standard.[7]
#
# End of documentation


	case "$DESKTOP_SESSION" in
		plasma )
			# If we find any plasma session then install the plasma store addons...
			write_information "${FUNCNAME[0]}: plasma on anything..".
			check_dependencies plasma-discover
			check_dependencies plasma-discover-backend-flatpak
			check_dependencies plasma-discover-backend-snap
		;;
		"/usr/share/xsessions/default" )
			# Special case for suse again...
			if cat /usr/share/xsessions/default.desktop |grep "Plasma"  ; then
				write_information "${FUNCNAME[0]}: kde on suse"
				check_dependencies plasma-discover
				check_dependencies plasma-discover-backend-flatpak
				check_dependencies plasma-discover-backend-snap
			else
				write_information "${FUNCNAME[0]}: gnome on suse"
				check_dependencies gnome-software
				check_dependencies gnome-software-plugin-flatpak
				check_dependencies gnome-software-plugin-snap
			fi
		;;
		* )
			# in any other case, install the gnome versions of store and plugins... 
			write_information "${FUNCNAME[0]}: case = *"
			check_dependencies gnome-software
			check_dependencies gnome-software-plugin-flatpak
			check_dependencies gnome-software-plugin-snap
		;;
	esac

}







software::ensure_flatpak_package_managment() {
# Description: Function to ensure that flatpak is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Like Snap, Flatpak is another distribution independent package format aimed to simplify overall
# app distribution and usage in Linux systems. Previously known as xdg-app, the framework was based
# on the concept of running applications in a secure virtual sandbox without requiring root privileges
# or posing a security threat to the system.
# Flatpak was officially released in 2015 with a reliable backup from Red Hat, Endless Computers, and
# Collabora. It targeted primarily three Desktop Environments. That is FreeDesktop, KDE, and GNOME. The
# Linux distributions currently having this framework are arch Linux, Debian, Fedora, Mageia,
# Solus, and Ubuntu.The Flatpak framework itself is developed in C programming and released under the
# LGPL license. The lead developer is Alexander Larsson – a Red Hat employee. Like Snapcraft for Snap,
# Flatpak also has the Flathub app store where users can find and install all Flatpak packages.
# Initially, Flathub only allowed open-source publishing applications on the website but
# has recently approved the publishing of proprietary apps.
# Additionally, unlike Snap, where we have a single repository controlled by Canonical to install and update
# software packages, Flatpak supports the use of multiple repos. The one significant disadvantage with this
# package is the lack of support for Servers.
#
#	*	---       PREFFERRED Software install (Security + Control)           ----		*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation
	if [[ $(echo "$OSTYPE" |grep "linux") ]] &>/dev/null ; then
		# these tests focus on the latest versions of the distros evaluated...
		write_information "Ensuring flatpak software distribution system is available..."
		if hash flatpak &>/dev/null ; then
			write_status "flatpak command is available... "
			if flatpak remotes | grep flathub  &>/dev/null ; then 
				write_status "flathub remote is present..."
				export PATH=$PATH:/var/lib/flatpak/exports/bin
			else
				write_warning "flathub remote is not present... adding now... "
				ensure_admin
				flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || write_error "Failed to add flatpak repo!"
				export PATH=$PATH:/var/lib/flatpak/exports/bin
			fi

			if flatpak list|grep com.github.tchx84.Flatseal  &>/dev/null ; then 
				write_status "flatseal security management is also present..."
			else
				ensure_admin
				write_status "flatseal security manager not found, adding now..."
				flatpak install flathub com.github.tchx84.Flatseal --noninteractive -y
			fi
		else
			ensure_admin
			write_information "Ensuring Flatpak software distribution system is available..."
			if check_dependencies flatpak ; then
				flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || write_error "Failed to add flatpak repo!"
				export PATH=$PATH:/var/lib/flatpak/exports/bin			
			else
				write_error "Failed to satisfy dependecy flatpak!"
			fi
			
			if flatpak list|grep com.github.tchx84.Flatseal  &>/dev/null ; then 
				write_status "flatseal security management is also present..."
			else
				ensure_admin
				write_status "flatseal security manager not found, adding now..."
				flatpak install flathub com.github.tchx84.Flatseal --noninteractive -y
			fi
			return $?
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported with snap... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported with snap... " ; return 1
	else
		echo "I have no Idea what this system is" ; return 1
	fi
}





software::ensure_snap_package_managment() {
# Description: Function to ensure that snap is installed.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs: stdout
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE:
# https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Snap is a distribution independent package format developed by Canonical and first released
# in 2014. It was initially developed for Ubuntu but has been adopted by other Linux distributions
# like Arch, Linux Mint, CentOS, Gentoo, and Fedora, and also included support for the Snap
# framework. The main aim behind this package format development was to come up with a
# single unified format for software packages to run in a wide range of devices.
# That includes IoT (IoT), embedded devices running Ubuntu Core (a minimalistic
# version of Ubuntu), and computer systems that ran some Ubuntu version.
# Snap also offers an online app store – Snapcraft, where users can find and
# install the software packages. It creates a large pool where users can find all
# available a snap package. Snapcraft is itself controlled and maintained by the
# Canonical team.
#
#
#	*	---   PREFFERRED Software install (Security + Control)        ----	*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation


	if [[ $(echo "$OSTYPE" |grep "linux") ]] &>/dev/null ; then
		# these tests focus on the latest versions of the distros evaluated...
		system::log_item "ensuring SNAP software distribution system is available..."
		if hash snap &>/dev/null ; then
			system::log_item "Snap is already present..."
			if [[ -e /snap ]]; then
				system::log_item "SNAP classic support present... "
				return $?
			else
				system::log_item "SNAP classic support NOT present... "
				system::log_item "adding links... "
				ln -s /var/lib/snapd/snap /snap
				return $?
			fi
		else
			if hostnamectl |grep "SUSE" 2>/dev/null ; then
				system::log_item "Special case for suse..."
				ensure_admin
				if hostnamectl |grep -i "tumbleweed" ; then
					local _repo=$(echo https://download.opensuse.org/repositories/system:/snappy/openSUSE_Tumbleweed snappy)
					system::log_item "Detected OpenSUSE Timbleweed. Adding repo: ${_repo}"
					zypper addrepo --refresh "${_repo}"
				else
					_repo=$(echo https://download.opensuse.org/repositories/system:/snappy/openSUSE_Leap_$(cat /etc/os-release |grep VERSION_ID |cut -d= -f2|cut -d\" -f2) snappy)
					system::log_item "Detected OpenSUSE Leap. Adding repo:${_repo}"
					zypper addrepo --refresh "${_repo}"
				fi
				zypper --gpg-auto-import-keys refresh || ( write_error "Failed to gpg keys!" ; return 1 ) 
				zypper dup --from snappy || ( write_error "Failed to update snap repository!" ; return 1 )
				check_dependencies snapd || ( write_error "Failed to satisfy dependecy SNAP!" ; return 1 )
				systemctl enable snapd ; systemctl start snapd
				systemctl is-active --quiet snapd || ( write_error "Service snapd not started sucessfully!" ; return 1 )
				ln -s /var/lib/snapd/snap /snap
				return $?
			else
				# For distributions that do not need to add a repository to install snap
				# But would need to install it from their standard reopsitory....
				if check_dependencies snapd ; then
					systemctl enable snapd ; systemctl start snapd
					echo snapd is $(systemctl is-active snapd) || return 1
					if [[ -e /snap ]]; then
						write_information "SNAP classic support present... "
					else
						ln -s /var/lib/snapd/snap /snap
					fi
					return $?
				else
					write_error "Failed to satisfy dependecy SNAP!"
				fi
			fi
		fi	

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported with snap... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported with snap... " ; return 1
	else
		echo "I have no Idea what this system is" ; return 1
	fi
}







system_config::tune_system_power_profile() {
# Description: Tuned is a Linux feature that monitors a system and optimizes its performance
# under certain workloads. Tuned uses profiles to do this. A profile is a set of rules that
# defines certain system parameters such as disk settings, kernel parameters, network
# optimization settings, and many other aspects of the system.
#
# This function sets the performance according to laptop/desktop/vm based on what is detected.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: simply call function in a script
# End of documentation

	check_dependencies tuned
	systemctl enable --now tuned
	tuned-adm profile balanced

	case "${1}" in
		--quiet | -q ) : ${_print="#"} ;;
		* ) unset _print ;;
	esac

	check_dependencies virt-what
	check_dependencies laptop-detect
	if virt-what ; then
		"${_print}" write_information "${FUNCNAME[0]}: This is likely not running in a virtual machine."
		if laptop-detect ; then
			"${_print}" write_information "${FUNCNAME[0]}: This is likely a laptop; applying pwersave profile..."
			tuned-adm profile powersave
		else
			"${_print}" write_information "${FUNCNAME[0]}: This is likely NOT a laptop; applying desktop profile..."
			tuned-adm profile desktop
		fi
	else
		"${_print}" write_information "${FUNCNAME[0]}: This is likely a VM; applying virtual-guest profile..."
		tuned-adm profile virtual-guest
	fi
}




oem::check_boot_splash_screen_enable() {
# Description: OEM function to enable splash screen on boot if desktop is indicated in
# a configuration file. This file could be an AutoYast.xml, or ks.cfg, or a preseed.cfg.
#
# Globals:
# Arguments: [FILE]
# Outputs:
# Returns: error level
# Usage: oem::check_boot_splash_screen_enable /root/original-ks.cfg
# End of documentation
	if [[ -n "$1" ]] ; then
		if [[ -r "$1" ]] ; then
			if cat $1 |grep -i "desktop" ; then
				check_dependencies splash
				echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"'>> /etc/default/grub
				update-grub
				
			fi
		fi
	fi
}




is_software_package_installed() {
# Description: Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Globals:
# Arguments: None
# Outputs:
# Returns: 1/0 where 0 = package is installed/1 = package is NOT installed
# Usage:
# Call this function by:
# is_software_package_installed "package name"
#                 or
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash dnf &> /dev/null; then
		rpm -q "$1" &> /dev/null && return 0 || return 1
	elif hash zypper &> /dev/null; then
		zypper se -i "$1" &> /dev/null && return 0 || return 1
	elif hash apt &> /dev/null; then
		dpkg -l "$1" | grep -E "^ii\s+$1\s" &> /dev/null && return 0 || return 1
	else
		return 3
	fi

}




software::is_native_package_installed() {
# Description: Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Globals:
# Arguments: None
# Outputs:
# Returns: 1/0 where 0 = package is installed/1 = package is NOT installed
# Usage:
# Call this function by:
# software::is_native_package_installed "package name"
#                 or
# software::is_native_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash dnf &> /dev/null; then
		rpm -q "$1" &> /dev/null && return 0 || return 1
	elif hash zypper &> /dev/null; then
		zypper se -i "$1" &> /dev/null || return 1 && return 0 
	elif hash apt &> /dev/null; then
		dpkg -l "$1" |tail -1 |grep "ii  $1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi
}



is_software_package_available() {
# Description: Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum &> /dev/null ; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash zypper &> /dev/null ; then
		zypper se "${1}" |grep "${1}" &> /dev/null && return 0 || return 1
	elif hash apt &> /dev/null ; then
		apt -qq list "$1" | grep -q "$1" &> /dev/null  && return 0 || return 1
	else
		return 3
	fi
}



software::is_native_package_available() {
# Description: Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		if zypper se "${1}" |grep "${1}" &> /dev/null ; then return 0 ; else return 1 ; fi
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	else
		return 3
	fi
}



InstallSoftwareFromRepo() {
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpak
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpak. A preference order between package system and
# snap or flatpak use.
# End of documentation

	local PAD LINE PRE _return

	set_install_command &>>"${_LOGFILE}"

	PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"

	display_message() {
		local message="$1" color="$2" symbol="$3"
		printf "%b%-6s%b [ $symbol ] $color $message $ENDCOLOR \n"
	}

	if is_software_package_installed "${1}"; then
		display_message "Already installed..." "$YELLOW" "\xE2\x9C\x94"
		return 1
	elif is_software_package_available "${1}"; then
		if printf "${PRE}" & software::add_native_package "${1}" &>>"${_LOGFILE}"; then
			display_message "OK!" "$GREEN" "\xE2\x9C\x94"
			return 0
		else
			display_message "FAILED" "$RED" "!"
			return 1
		fi
	else
		display_message "Not available..." "$YELLOW" "\xE2\x9C\x94"
		return 1
	fi
}





software::add_native_package() {
# Description:
# add global install command for portability and convenience. This function
# allows for scripts to add software across many systems.
# Primarily for Linux: this function will look for the common package managers
# apt (all debina and ubuntu based distributions), dnf (RedHat, Fedora, Mandriva, and others)
# zypper (SuSE and Open SUSE). If neither of those package manages are available many systems
# use package kit; and this will be registered as an sinstall option.
#
# Globals:
# Arguments: package_name
# Outputs:
# Returns:
# Usage: "software::add_native_package <package_name> <package_name> <...n>"
#
#
# Return Codes:
# 
# A return code of "1" will be returned the function was not able install the package.
#
#
# End of documentation

        if [[ $(echo $OSTYPE | grep "linux") ]]; then

		if hash zypper 2>/dev/null; then
			write_status "📦 Installing ${1} using ZYPPER:"
			sudo zypper install -y ${1} || { write_error "Failed to install ${1} using ZYPPER" ; return 1 ; }
			{ write_information "The software package ${1} has been installed sucessfully..." ; return 0 ; }

		elif hash apt 2>/dev/null; then
			write_status "📦 Installing ${1} using DEB:"
			sudo apt-get -y install ${1} || { write_error "Failed to install ${1} using DEB" ; return 1 ; }
			{ write_information "The software package ${1} has been installed sucessfully..." ; return 0 ; }
		elif hash dnf 2>/dev/null; then
			write_status "📦 Installing ${1} using DNF:"
			sudo dnf -y install ${1} || { write_error "Failed to install ${1} using DNF" ; return 1 ; }
			{ write_information "The software package ${1} has been installed sucessfully..." ; return 0 ; }
		elif hash pkcon 2>/dev/null; then
			write_status "📦 Installing ${1} using Package Kit:"
			pkcon install -y ${1} || { write_error "Failed to install ${1} using Package Kit" ; return 1 ; }
			{ write_information "The software package ${1} has been installed sucessfully..." ; return 0 ; }
		else
			write_error "This system does not seem to have a software managment system"
			return 1
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		return 1
	fi
	return $?
}





set_install_command() {
# Description:
# add global install command for portability and convenience. This function
# allows for scripts to add software across many systems.
# Primarily for Linux: this function will look for the common package managers
# apt (all debina and ubuntu based distributions), dnf (RedHat, Fedora, Mandriva, and others)
# zypper (SuSE and Open SUSE). If neither of those package manages are available many systems
# use package kit; and this will be registered as an sinstall option.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: "set_install_command"
#
# Arguments: none.
#
# Return Codes:
# set_install_command will return a global variable ${_INSTCMD}
# ${_INSTCMD} will expand to teh appropriate install cmmand including options
# for non interactive install of a package. ${_INSTCMD} package.name will install said pacakge.
#
# A return code of "1" will be returned the function was not able to set the install command.
#
#
# End of documentation

                if [[ $(echo $OSTYPE |grep "linux") ]]; then

		if hash dnf 2>/dev/null; then
			# Try dnf (RedHat, Cent OS, Fedora)
			write_status "Setting install options for DNF"
			export _INSTCMD="sudo dnf -y  install"
		elif hash zypper 2>/dev/null; then
			# Try zypper (Open SUSE)
			write_status  "Setting install options for ZYPPER"
			export _INSTCMD="sudo zypper install -y "
		elif hash apt 2>/dev/null; then
			# Try apt (Debian, Ubuntu, and all derivatives)
			write_status  "Setting install options for DEB"
			export _INSTCMD="sudo apt-get -y install"
		elif hash pkcon 2>/dev/null; then
			# If there is no apt, zypper, dnf
			write_status  "Setting install options for Package Kit"
			export _INSTCMD="sudo pkcon -y  install"
		else
			write_error "This system does not seem to have a software managment system"
			return 1
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		return 1
	fi
	return $?
}







software::add_gnome_extensions() {
# Description:
# Description:
# Function to add GNOME extensions to the system. This function takes one or more extension names
# as parameters, checks if each extension is installed, and if not, installs them.
#
# Globals:
#   _TLA - Expected to be set to a unique identifier for the script or application.
#   _LOGFILE - Optional global variable to specify a custom log file path.
#
# Arguments:
#   Extension names (one or more).
#
# Outputs:
#   Writes status messages and errors to stdout or stderr, and logs installation details.
#
# Returns:
#   0 if all specified extensions were installed successfully, 1 otherwise.
#
# Usage:
#   software::add_gnome_extensions "dash-to-dock" "some-other-extension"
#
# Example:
#   software::add_gnome_extensions "dash-to-dock"

#
# End of documentation


	if [ $# -eq 0 ]; then
		write_warning "Error: No GNOME extensions were provided for me to install."
		return 1
	fi

	local extension_installer_path="/opt/${_TLA,,}"
	local extension_installer="$(find "$extension_installer_path" -name 'rtd-gnome-shell-extension-installer')"
	local gnome_shell_ver="$(gnome-shell --version | awk '{print $3}')"
	local _logfile="${_LOGFILE:-"/var/log/${_TLA,,}/$(basename ${0})"}"

	if [[ -z "$gnome_shell_ver" && -n "$SUDO_USER" ]]; then
		gnome_shell_ver=$(sudo -H -u $SUDO_USER XDG_RUNTIME_DIR="/run/user/$(id -u $SUDO_USER)" gnome-shell --version | awk '{print $3}')
	fi

	if [[ -z "$extension_installer" ]]; then
		write_error "Error: GNOME extension installer not found in $extension_installer_path."
		return 1
	fi

	# "Dont run if gnome is not running..."
	if [[ -z "$gnome_shell_ver" ]]; then
		write_error "Error: Unable to determine GNOME Shell version."
		return 1
	fi

	local install_status=0
	local extensions=("$@") # Capture all arguments as an array
	write_status "Status: Installing GNOME extension(s): $* ..."
	for extension in "${extensions[@]}"; do
		write_status "Status: Installing GNOME extension: $extension."
		if ! bash "$extension_installer" "$extension" --yes |& tee -a "${_logfile}" ; then
			write_error "Error: Failure to install GNOME extension: $extension." 
			install_status=1
		else
			write_status "Status: Successfully installed GNOME extension: $extension."
		fi
	done

	return $install_status
}








check_dependencies() {
# Description:
# Function to maintain backward compatibility with the check_dependencies function.
# This function will take a parameter that is expected to match the name of the package.
# The function will then pass it to the software::check_native_package_dependency function.
# 
# End of documentation
software::check_native_package_dependency ${*} && return 0 || return 1 

}





software::check_native_package_dependency() {
# Description:
# Function to check that a piece of software is installed and if not install it.
# Works for apt, zypper, dnf or yum based systems currently. The function will take a parameter 
# that is expected to match the software name or rather the name of the package. 
# 
# 
# This is done to comply wiht the philosophy to do what it takes to reach the objective, and 
# just work. Rather than just fail, we want to try and solve the problem and make the software
# available. 
# 
# Globals:
# Arguments: None
# Dependencies: [package manager]
# Function Dependencies: (other functions)
# ensure_admin, write_status, write_information, write_warning, write_error, is_software_package_installed,
# InstallSoftwareFromRepo
# 
# Outputs:
# Returns: 1/0
# Usage: software::check_native_package_dependency [packagename]
# 
# EXAMPLE: software::check_native_package_dependency snapd
# 
# End of documentation
	[[ "${EUID}" -eq 0 ]] || ensure_admin
	

	write_status "📦 Checking for script dependency ${1} and install if not there..."

	if software::is_native_package_installed "${1}" ; then
		write_information "📦 I found that the dependency ${1} is present on this system... "
	else
		write_warning "📦 The dependency: ${1} does not appear to be installed. I will try to get it... "
		if software::add_native_package "${1}" ; then
			write_status "📦 OK Done! Continuing..."
		else
			write_error "📦 That install didn't work out so well. Please manually try to add the software since I couldn't do it."
			return 1
		fi
	fi
}






rtd_ppa_checker() {
# Description:
# Function to check status of Ubuntu and derivatives' PPA aarchives.
# This function will take one optional argument to toggle the "delete" option. If the delet option
# is requested rtd_ppa_checker will delete any PPA's that are not used (no software is installed from it)
#
# PPA stands for Personal Package Archive. The PPA allows application developers and
# Linux users to create their own repositories to distribute software. With PPA, you can
# easily get newer software version or software that are not available via the official Ubuntu
# repositories.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# rtd_ppa_checker [] [--delete]
#
# End of documentation
	ensure_admin
	for f in /etc/apt/sources.list.d/*.list; do
		grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
			echo "ENTRY: $ENTRY"
			HOST=$(cut -d/ -f3 <<< "$ENTRY")
			if [ "ppa.launchpad.net" = "$HOST" ]; then
				USER=$(cut -d/ -f4 <<< "$ENTRY")
				PPA=$(cut -d/ -f5 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "PPA: ppa:$USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			else
				USER=$(cut -d/ -f3 <<< "$ENTRY")
				PPA=$(cut -d/ -f4 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "REPOSITORY: $USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			fi
		done
	done
}









rtd_oem_release_upgrade() {
# Description: Function to attempt to perform a release upgade on several Linux distributions.
# Supported distributions are: Ubuntu, Pop! OS, Debian, SUSE, and fedora.
# This function does not require any arguments but will respect "interactive". The "interactive"
# parameter will force the function to pause if a supported distribution is not found.
# It will check for a supported distribution and attempt the upgrade if possible.
# If a supported distribution is not detected the function will do nothing.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  (in a script):
#  rtd_oem_release_upgrade [ string ]
#
# [ string ] : interactive
#
# End of Documentation


	ensure_admin
	local interactive=$1
	local distro=$(hostnamectl | grep -Eo 'Ubuntu|Pop!_OS|Debian|SUSE|fedora|TUXEDO|Zorin')

	case $distro in
		"Ubuntu"|"Pop!_OS"|"TUXEDO|Zorin")
			# Common update steps for Ubuntu and derivativres
			write_warning "This may take some time, please be patient!"
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			if [[ "$interactive" == "interactive" ]]; then
				$RTD_GUI --title "$distro Distribution Upgrade Confirmation" --yesno "Please confirm that you want to upgrade to the next version of $distro. This may take some time, please be patient!" 8 78
				case $? in
				0 ) do-release-upgrade | tee -a ${_LOGFILE} ;;
				1|255 ) return 1 ;;
				esac
			else
				do-release-upgrade --quiet | tee -a ${_LOGFILE}
			fi
		;;
		"Debian")
			write_error "Debian does not provide an upgrade tool between major releases. Please use the manual upgrade method."
			return 1
		;;
		"SUSE")
			# SUSE upgrade steps
			if current_version=$(cat /etc/os-release | grep VERSION_ID | cut -d '"' -f2) ; then
				write_status "Current SUSE version: $current_version"
			else
				write_error "unable to query /etc/os-release for current version of SUSE! "
				return 1
			fi

			if latest_version=$(curl -s https://download.opensuse.org/distribution/openSUSE-current/iso/ | grep -Eo '1[5-9]\.[0-9]|20\.[0-9]+' | sort -V | tail -n1) ; then
				write_status "Latest SUSE version: $latest_version"
			else
				write_error "unable to query opensuse.org for latest version of SUSE! Check access to internet and try again."
				return 1
			fi

			if [ "$(printf '%s\n' "$current_version" "$latest_version" | sort -V | head -n1)" != "$current_version" ]; then
				write_status "A newer version of SUSE is available: $latest_version"
				write_warning "This REALLY may take some time, please be patient!"
				write_information "These are the current repositories:"
				{
					zypper repos --uri
					zypper modifyrepo --enable repo-update
					zypper repos --uri
					zypper refresh
				} | tee -a ${_LOGFILE}

				write_status "Checking if it is possible to upgrade to ${SUSE_VER}"
				if zypper --releasever="${SUSE_VER}" lr -u ; then
					zypper --releasever="${SUSE_VER}" ref
					write_status "Attempting upgrade of system now..."
					zypper --releasever="${SUSE_VER}" dup --force-resolution
					wait
					[[ "$interactive" == "interactive" ]] && read -p "$ERRMSG: Press  [ ENTER ] to REBOOT:"
					reboot
				else
					write_error "It is not possible to upgrade to Open Suse ${SUSE_VER} since there does not appear to be a release server available for ${SUSE_VER}"
					[[ "$interactive" == "interactive" ]] && read -p "$ERRMSG: Press  [ ENTER ] to continue:"
				fi
			else
				write_information "You are using the latest version of SUSE: $current_version"
			fi
		;;
		"fedora")
			# Fedora upgrade steps
			if [[ "$interactive" == "interactive" ]]; then
				latest_version=$(curl -s https://dl.fedoraproject.org/pub/fedora/linux/releases/ | cut -d' ' -f5 |grep -Eo '[0-9][5-9]' | sort -V | tail -n1)
				releasever=$($RTD_GUI --title "Fedora Distribution Upgrade Confirmation" \
					--inputbox "Please enter the Fedora version you want to upgrade to. Latest version is . Current version: $latest_version $(hostnamectl | grep -oP '(?<=Operating System: Fedora\s)\d+')\nOnly numbers are valid." 10 78 3>&1 1>&2 2>&3)
			else
				releasever=$(curl -s https://dl.fedoraproject.org/pub/fedora/linux/releases/ | cut -d' ' -f5 |grep -Eo '[0-9][5-9]' | sort -V | tail -n1)
			fi

			# Validate input
			if [[ ! $releasever =~ ^[0-9]+$ ]]; then
				write_error "Invalid version number. Upgrade aborted."
				return 1
			fi

			# Upgrade process
			write_status "Starting upgrade process for Fedora. This may take some time."
			{
				dnf clean all
				dnf upgrade --refresh -y
				dnf install dnf-plugin-system-upgrade -y
				if ! dnf system-upgrade download --refresh --releasever="${releasever}"; then
					write_error "Failed to download system upgrade packages."
					return 1
				fi
			} | tee -a ${_LOGFILE}

			# Confirmation for reboot
			if [[ "$interactive" == "interactive" ]]; then
				read -p "$ERRMSG: Press [ ENTER ] to REBOOT and install the upgrade:"
			fi

			# Rebooting to apply upgrade
			dnf system-upgrade reboot
			return $?
		;;
		*)
		system::log_item "This distribution is not supported for release upgrade."
		[[ "$interactive" == "interactive" ]] && read -p "This distribution is not supported. Press [Enter] key to return to menu."
		return 1
		;;
	esac
	return

}












rtd_oem_remove_non_western_latin_fonts() {
# Description:  a simple function to remove known
# non-western (latin) fonts from a distribution. Notably, Ubuntu provides too many fonts
# of all kinds by default, even if the user will never need the fonts. However, the fonts
# may cause unexpected font tool behavior and crashes, due to the large number of fonts
# and their features. It is there fore a good Idea to remove these fonts if they are not needed.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#	Simply call this function by stating its name:
# 	rtd_oem_remove_non_western_latin_fonts
#
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation
	ensure_admin
	font_list="fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lklug-sinhala fonts-lohit-guru fonts-guru fonts-nanum fonts-noto-cjk fonts-takao-pgothic fonts-tibetan-machine fonts-guru-extra \
		fonts-lao fonts-sil-padauk fonts-sil-abyssinica fonts-tlwg-* fonts-beng fonts-beng-extra fonts-deva fonts-deva-extra fonts-gubbi fonts-gujr fonts-gujr-extra fonts-kalapi fonts-knda \
		fonts-lohit-* fonts-orya* fonts-pagul fonts-sahadeva fonts-samyak-* fonts-sarai fonts-smc fonts-smc-* fonts-taml fonts-telu fonts-telu-extra"
	write_status "Attempting to remove non-western fonts..."
	count=0
	for i in $font_list ; do
		software::remove_native_software_package $i && (( count++))
	done
	write_information "Removed [ $count ] non-western Fonts"
}





software::remove_native_software_package() {
# Description:
#   Removes a specified software package using the native package management
#   system found on the system. This function is designed for portability and
#   convenience, supporting various Linux distributions by utilizing their
#   default package managers (dnf, yum, zypper, apt, pkcon). It's intended to
#   simplify the process of removing software packages across different
#   environments without needing to manually identify the package manager.
#
# Globals:
#   None
#
# Arguments:
#   $1 - The name of the package to be removed. This argument is required.
#
# Outputs:
#   Outputs various log messages to indicate the status of operations, including
#   detection of the package manager, attempts to remove the package, and
#   error messages if the package manager is not found or if no package name
#   is provided.
#
# Returns:
#   0 - If the package removal operation is successful.
#   1 - If the package removal operation fails, if no package name is provided,
#       if no known package manager is found on the system, or if the function
#       encounters any other errors during execution.
#
# Usage:
#   To remove a package named "example-package", you would call the function as follows:
#       software::remove_native_software_package example-package
#
#   It is recommended to use this function with a single package name for reliability.
#   If there is a need to remove multiple packages, consider calling this function
#   in a loop, passing one package name at a time. This approach retains the benefit
#   of multi-distribution support while ensuring that each package is correctly handled.
#
# End of documentation
	
	if [[ -z "$1" ]]; then
		system::log_item "No package name provided for removal."
		return 1
	fi

	local package_manager
	local package_name="$1" # Assuming a single package for safety and clarity

	system::log_item "Requested to remove package $package_name"
	ensure_admin

	# Detect package manager
	if hash dnf 2>/dev/null; then
		package_manager="dnf"
	elif hash yum 2>/dev/null; then
		package_manager="yum"
	elif hash zypper 2>/dev/null; then
		package_manager="zypper"
	elif hash apt 2>/dev/null; then
		package_manager="apt"
	elif hash pkcon 2>/dev/null; then
		package_manager="pkcon"
	else
		system::log_item "No known package manager found on this system."
		return 1
	fi

	# Remove package
	case $package_manager in
		dnf|yum)
			system::log_item "$package_manager package manager detected; attempting to remove package $package_name"
			$package_manager -y remove "$package_name"
		;;
		zypper)
			system::log_item "$package_manager package manager detected; attempting to remove package $package_name"
			$package_manager remove -y "$package_name"
		;;
		apt)
			system::log_item "$package_manager package manager detected; attempting to remove package $package_name"
			$package_manager -y remove "$package_name" && $package_manager -y autoremove
		;;
		pkcon)
			system::log_item "$package_manager package manager detected; attempting to remove package $package_name"
			$package_manager remove "$package_name" -y --autoremove
		;;
	esac

	if [[ $? -eq 0 ]]; then
		system::log_item "Package $package_name has been removed successfully."
		return 0
	else
		system::log_item "Failed to remove package $package_name."
		return 1
	fi
}







system::log_item() {
	# Description:
	# The purpose of this function is to consistently write script output to the right log file. 
	# By default, the log file will be /var/log/$(basename "$0").log. If the log file is not set
	# the function will set it to the default. If the log file is set, it will use the set log file.
	# 
	# This function will log items by prepending the time and date, as well as the calling function. 
	# If the calling function is write_warning, write_error, write_information, or write_status, 
	# the function will prepend the log item with the preceding calling function name. Otherwise, 
	# it will simply prepend the calling function name.
	# 
	# Globals: _LOGFILE
	# Arguments: "Text to log"
	# Outputs: Writes to log file
	#
	# Example:
	# 2024/01/17 11:43  --- : 🧩 source: 🧩 _LOG_DIR=/home/tangaroa/.config/rtd/logs
	# 2024/01/17 11:43  --- : 🧩 source: 🧩 _LOGFILE=/home/tangaroa/.config/rtd/logs/_rtd_library.log
	# 2024/01/17 11:43  --- : 🧩 ⚠ source: Library is sourced from a script or terminal! 
	# 2024/01/17 11:43  --- : 🧩 🛈 source: Script is sourced from bash in a terminal: /bin/bash 
	# 2024/01/17 11:43  --- : 🧩 dependency::search_local: Requested dependency file: _branding ...
	#
	# Returns: None
	# Usage:
	#
	# Call this function by: 
	# system::log_item "Text to log"
	#
	# End of documentation

	if [[ -z $_LOGFILE ]]; then
		# If log file not set globally, set it to defaults for this function a.k.a. script name
		local scriptname=$(basename "${BASH_SOURCE[0]}")
		local tla=${scriptname:0:3}

		if [[ $EUID -ne 0 ]]; then
			local log_dir="${HOME}/.config/rtd/logs"
		else
			local log_dir=${_LOG_DIR:-"/var/log/${tla,,}"}
		fi

		if ! mkdir -p "$log_dir"; then
			printf "Error: could not create log directory %s\n" "$log_dir" >&2
			return 1
		fi

		local logfile="${log_dir}/${scriptname}.log"
	else 
		local logfile="${_LOGFILE}"
	fi

	touch "$logfile"
	local date="$(date '+%Y/%m/%d %H:%M')"

	# Format the log item based on the calling function for clear reading
	local log_prefix="${date}  ---"
	local log_type=""
	local log_message=""

	case "${FUNCNAME[1]}" in
		write_error)
			log_type="ERR!"
			log_ico="💥"
			log_message="$*"
		;;
		write_warning)
			log_type="WARN"
			log_icon="⚠ "
			log_message="$*"
		;;
		write_information)
			log_type="INFO"
			log_icon="🛈 "
			log_message="$*"
		;;
		write_host)
			log_type="HOST"
			log_icon="💻"
			log_message="$*"
		;;
		write_status)
			log_type="STAT"
			log_icon="✔ "
			log_message="$*"
		;;
		*)
			log_type="LOGD"
			log_icon="📜"
			log_message="${FUNCNAME[1]}: $*"
		;;
	esac

	echo "${log_prefix} ${log_icon} : ${log_type} : ${log_message}" >> "$logfile"
}





rtd_update_system() {
# Description:
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak with a cleaned up oputput only displaying status.
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output.
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: rtd_update_system
# End of documentation
	#ensure_admin
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.14 (built in)"
	DIALOGRC="~/.config/rtd/dialogrc"
	_LOGFILE="${_LOGFILE:-$0.log}"

	write_status "${PUBLICATION}: Version ${VERSION}"
	write_status "------------------------------------------------------------------"

	write_host --cyan "I am updating software from all channels I can find on the system."
	write_host --cyan "I will update via the native package manager as well as newer formats"
	write_host --cyan "like snap and flatpak ..."
	echo -e " \n"

	rtd_software_task ()
	{
		system::log_item "running rtd_software_task with parameters $*"
		# make some decent display terminal graphics...
		PAD="----------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "Executing $LINE:"\ & "$@" >>"$_LOGFILE" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] ${RED} FAILED $ENDCOLOR  \n"
		# write_status "Executing ${LINE}:"\ & "$@" >>"${_LOGFILE}" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] OK!  \n" ||printf "%b%-6s%b [ ! ] FAILED  \n"

	}
	

	if hash dnf 2>/dev/null; then
		rtd_software_task dnf -y upgrade
	elif hash zypper 2>/dev/null; then
		rtd_software_task zypper up -y
	elif hash apt 2>/dev/null; then
		rtd_software_task apt-get update
		UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
		if [ "$UPGRADABLE" -eq 0 ]; then
			write_information "$UPGRADABLE packages that need updates; Skipping update task... "
		else
			write_information "There are $UPGRADABLE packages that need updates..."
			rtd_software_task dpkg --configure -a
			rtd_software_task apt-get upgrade -y
			rtd_software_task apt-get full-upgrade -y
			rtd_software_task apt-get --purge autoremove -y
			rtd_software_task apt-get clean
		fi
	elif hash pkcon 2>/dev/null; then
		rtd_software_task pkcon -y refresh
		rtd_software_task pkcon get-updates
		rtd_software_task pkcon -y update --autoremove 
	else
		write_error "This system does not seem to have a software managment system" 
		return 1
	fi

	write_status "updating snaps if snap is present on the system..."
	if hash snap 2>/dev/null; then
		rtd_software_task snap refresh
	else
		write_warning "--- snap software is not present on this system... skipping..."
	fi

	write_status "updating flatpaks if flatpak is present on system..."
	if hash flatpak 2>/dev/null; then
		rtd_software_task flatpak update --user --noninteractive -y
		rtd_software_task flatpak update --system --noninteractive -y
	else
		write_warning "--- flatpak software is not present on this system... skipping..."
	fi

}





software::update_system_txt() {
# Description:
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak with normal text only default output.
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output.
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: software::update_system_txt
# End of documentation
	ensure_admin
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.14 (built in)"
	DIALOGRC="~/.config/rtd/dialogrc"
	_LOGFILE="${_LOGFILE:-$0.log}"

	write_status "${PUBLICATION}: Version ${VERSION}"
	write_status "------------------------------------------------------------------"

	write_host --cyan "I am updating software from all channels I can find on the system."
	write_host --cyan "I will update via the native package manager as well as newer formats"
	write_host --cyan "like snap and flatpak ..."
	echo -e " \n"
	(
	if hash dnf 2>/dev/null; then
		dnf -y upgrade 
	elif hash zypper 2>/dev/null; then
		zypper up -y 
		zypper dup -y --auto-agree-with-licenses --allow-vendor-change 
	elif hash apt 2>/dev/null; then
		apt-get update
		UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
		if [ "$UPGRADABLE" -eq 0 ]; then
			write_information "$UPGRADABLE packages that need updates; Skipping update task... "
		else
			write_information "There are $UPGRADABLE packages that need updates..."
			dpkg --configure -a
			apt-get upgrade -y
			apt-get full-upgrade -y
			apt-get --purge autoremove -y
			apt-get clean
		fi
	elif hash pkcon 2>/dev/null; then
		pkcon -y refresh
		pkcon get-updates
		pkcon -y update --autoremove
	else
		write_error "This system does not seem to have a software managment system" 
		return 1
	fi
	) | tee -a "$_LOGFILE"

	write_status "updating snaps if snap is present on the system..."
	if hash snap 2>/dev/null; then
		snap refresh
	else
		write_warning "--- snap software is not present on this system... skipping..."
	fi
	

	write_status "updating flatpaks if flatpak is present on system..."
	if hash flatpak 2>/dev/null; then
		flatpak update --user -y
		flatpak update --system -y 

	else
		write_warning "--- flatpak software is not present on this system... skipping..."
	fi

	echo "
	
	$(write_information "All updates have been processed.")
	NATIVE PACKAGES:
	$(
		if hash apt ; then cat /var/log/dpkg.log | grep "\ upgrade\ "
		elif hash dnf ; then cat /var/log/dnf.log | grep "\ upgrade\ "
		elif hash zypper ; then for i in $(cat /var/log/zypp/history |grep '|install|' | cut -f3 -d'|' ) ; do echo -n "* $i "  ;done
		elif hash pkcon ; then pkcon get-updates
		fi
	) 

	SNAPS:
	$(snap changes)

	FLATPAKS:
	$(flatpak history --system --since=1h
	  flatpak history --user --since=1h)" | tee -a "$LOGFILE"
}






software::update_all_ui() {
	ensure_admin
	local TERMUITXT="nocolor"
	local PUBLICATION="$BRANDING Update Manager for Linux"
	local VERSION="1.15 (built in with dialog)"
	local DIALOGRC="~/.config/rtd/dialogrc"
	local _LOGFILE="${_LOGFILE:-$0.log}"
	local dialog_ui=${RTD_GUI:-"dialog --erase-on-exit --colors "}

	Native_Software_Packages ()
	{
		(
		if hash zypper 2>/dev/null; then
			zypper up -y
			write_information "Update task complete."
		elif hash apt 2>/dev/null; then
			apt-get update
			UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
			if [ "$UPGRADABLE" -eq 0 ]; then
				write_information "$UPGRADABLE packages that need updates; Skipping update task... "
			else
				write_information "There are $UPGRADABLE packages that need updates..."
				dpkg --configure -a
				apt-get upgrade -y
				apt-get full-upgrade -y
				apt-get --purge autoremove -y
				apt-get clean
			fi
			write_information "Update task complete."
		elif hash dnf 2>/dev/null; then
			dnf -y upgrade
			write_information "Update task complete."
		elif hash pkcon 2>/dev/null; then
			pkcon -y refresh
			pkcon get-updates
			pkcon -y update --autoremove 
			write_information "Update task complete."
		else
			write_error "This system does not seem to have a software managment system" 
			return 1
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB"  --progressbox "Updating all natively installed software..." 25 120
	}

	Snap_Apps ()
	{
		(
		write_status "updating snaps if snap is present on the system..."
		if hash snap 2>/dev/null; then
			snap refresh
			write_information "Update task complete."
		else
			write_warning "!snap software is not present on this system... skipping..."
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --progressbox "Updating all Contained Snap Apps..." 25 120
	}

	Flatpak_Apps ()
	{
		(
		write_status "updating flatpaks if flatpak is present on system..."
		if hash flatpak 2>/dev/null; then
			flatpak update --user --noninteractive -y
			flatpak update --system --noninteractive -y
			write_information "Update task complete."
		else
			write_warning "!flatpak software is not present on this system... skipping..."
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --progressbox "Updating all Contained Flatpaks Apps..." 25 120
	}

	while true; do
		exec 3>&1
			local _proglist=""Native_Software_Packages"  1 "on"  "Snap_Apps" 2 "on" "Flatpak_Apps" 3 "on""
			_run=$($dialog_ui --ok-label Update --cancel-label QUIT --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --checklist "Select what to update:" 20 80 10 ${_proglist} 2>&1 1>&3 )
			exit_status=$?
		exec 3>&-

		case $exit_status in
			1) clear && echo [Quit] && return ;;
			255) clear && echo [ESC] && exit ;;
		esac

		case $_run in
			$_run )
				for i in $_run ; do $i 
				done
				$dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" \
				--title "Updates Complete" \
				--msgbox "
				
				All updates have been processed.
				NATIVE PACKAGES:
				$(
					if hash apt ; then cat /var/log/dpkg.log | grep "\ upgrade\ "
					elif hash dnf ; then cat /var/log/dnf.log | grep "\ upgrade\ "
					elif hash zypper ; then cat /var/log/zypp/history | grep "\ upgrade\ "
					elif hash pkcon ; then pkcon get-updates
					fi
				)

				SNAPS:
				$(snap changes)

				FLATPAKS:
				$(flatpak history --system --since=1h
				flatpak history --user --since=1h)
				
				
				" \
				20 120
			;;
			* ) 
				write_warning "No update actions were requested."
				exit 
			;;
		esac
	done
}



software::from_flathub.org() {
# Description: Function to simplify and streamline the installation and removal of flatpaks.
# Globals: none
# Dependencies: [distro pakage managment] [function: check_dependencies] [Internet access]
# Arguments: 
# -- Default action is to add software title matching passed parameter. 
# -- An optioin "--remove" may be passed to atempt removal of the software title. 
#
# Outputs:
# Returns: Standard return codes 1/0
# Usage: software::from_flathub.org [ title-name | title-name --remove ]
#
# 
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Like Snap, Flatpak is another distribution independent package format aimed to simplify overall
# app distribution and usage in Linux systems. Previously known as xdg-app, the framework was based
# on the concept of running applications in a secure virtual sandbox without requiring root privileges
# or posing a security threat to the system.
#
#	*	---       PREFFERRED Software install for GUI apps           ----		*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation

	local app_name=""
	local remove_flag=""

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--remove)
			remove_flag="--remove"
			shift
		;;
		*)
			if [[ -z "$app_name" ]]; then
				app_name="$1"
			else
				write_error "Error: Invalid parameter '$1'"
				write_information "Usage: software::from_flathub.org [app_name] [--remove]"
				return 1
			fi
			shift
		;;
		esac
	done

	software::ensure_flatpak_package_managment

	if [[ -z "$app_name" ]]; then
		write_error "Error: App name is missing."
		write_information "Usage: software::from_flathub.org [app_name] [--remove]"
		return 1
	fi

	if [[ "$remove_flag" == "--remove" ]]; then
		system::log_item "Request to remove Flatpak app '$app_name'"

		if flatpak uninstall -y "$app_name"; then
			system::log_item "Flatpak app '$app_name' has been uninstalled."
		else
			system::log_item "Error: Failed to uninstall Flatpak app '$app_name'"
			return 1
		fi
	else
		system::log_item "Request to install Flatpak app '$app_name'"

		if flatpak info "$app_name" >/dev/null 2>&1; then
			write_information "Flatpak app '$app_name' is already installed."
		else
			if flatpak install -y "$app_name"; then
				system::log_item "Flatpak app '$app_name' has been installed."
			else
				system::log_item "Error: Failed to install Flatpak app '$app_name'"
				return 1
			fi
		fi
	fi
}






software::from_snapcraft.io() {
# Description: Function to ensure that snap is installed.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs: stdout
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE:
# https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Snap is a distribution independent package format developed by Canonical and first released
# in 2014. It was initially developed for Ubuntu but has been adopted by other Linux distributions
# like Arch, Linux Mint, CentOS, Gentoo, and Fedora, and also included support for the Snap
# framework. The main aim behind this package format development was to come up with a
# single unified format for software packages to run in a wide range of devices.
# That includes IoT (IoT), embedded devices running Ubuntu Core (a minimalistic
# version of Ubuntu), and computer systems that ran some Ubuntu version.
# Snap also offers an online app store – Snapcraft, where users can find and
# install the software packages. It creates a large pool where users can find all
# available a snap package. Snapcraft is itself controlled and maintained by the
# Canonical team.
#
#
#	*	---   PREFFERRED Software install for CLI apps        ----	*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation


	local app_name=""
	local remove_flag=""
	local requires_classic=""

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--remove)
			remove_flag="--remove"
			shift
		;;
		*)
			if [[ -z "$app_name" ]]; then
			app_name="$1"
			else
				write_error "Error: Invalid parameter '$1'"
				write_information "Usage: install_or_remove_snap_app [app_name] [--remove]"
				return 1
			fi
			shift
			continue  # Skip the remaining part of the loop
			;;
		esac
	done

	if [[ -z "$app_name" ]]; then
		write_error "Error: App name is missing."
		write_information "Usage: ${FUNCNAME[0]} [app_name] [--remove]"
		return 1
	fi

	hash snap || software::ensure_snap_package_managment

	if [[ "$remove_flag" == "--remove" ]]; then

		system::log_item "Request to remove Snap app '$app_name'"

		if snap remove "$app_name"; then
			system::log_item "Snap app '$app_name' has been removed."
		else
			system::log_item "Error: Failed to remove Snap app '$app_name'"
		fi
	else
		system::log_item "Request to install Snap app '$app_name'"

		if snap list "$app_name" >/dev/null 2>&1; then
			system::log_item "Snap app '$app_name' is already installed."
		else
			requires_classic=$(snap info "$app_name" | grep "latest/stable" | grep -o " classic")
			if [[ -n "$requires_classic" ]]; then
				system::log_item "The app '$app_name' requires classic confinement (less confined)..."
				if snap install "$app_name" --classic; then
					system::log_item "Snap app '$app_name' has been installed."
				else
					system::log_item "Error: Failed to install Snap app '$app_name'"
				fi
			else
				if snap install "$app_name"; then
					system::log_item "Snap app '$app_name' has been installed."
				else
					system::log_item "Error: Failed to install Snap app '$app_name'"
				fi
			fi
		fi
	fi
}





software::add_software_task() {
# Description: Display executed task and echo ON/NOK based on sucess
# This function is created to reduce the terminal output and create a more poliched output of
# the tasks executed. This function has no idea shat it is doing, it will simply call the function
# it was asked to call or execute the command ist was asked to, and echo OK or FAIL based on the
# return code.
# Globals:
# Arguments: function or command to execute
# Outputs:
# Returns:
# Usage: software::add_software_task function_name
# End of documentation

	PAD="---------------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	#display_spinner start
	echo -ne "Task: ${LINE/recipe_/}:" & ${*} &>>${_LOGFILE:-"/var/log/rtd/${FUNCNAME[0]}$(date +%Y-%m-%d-%H)-oem-setup.log"} && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] ${RED} FAILED $ENDCOLOR  \n"
	#display_spinner stop
}







software::ensure_restricted_codecs() {
# Description: simple function to ensure that restricted codecs are available on the system. 
# Globals: expects zypper, dnf, or apt available. 
# Arguments: none
# Outputs:
# Returns:
# Usage: software::ensure_restricted_codecs
# End of documentation	
	write_status "Install all the required multimedia codecs..."
	for i in libdvdcss2 ffmpeg ; do
		check_ependencies $i || write_error "Failed to install restricted codecs..."
	done
}







software::vendor_download_and_install() {
# Description: Function by Nate Beaken to ease and make consistent the downloading of the non repository
# packages and install them. It can install any package that Package Kit can manage (available on most Linux dists)
# It expects one parameter: the complete URL to download from.
# Globals:
# Arguments: URL to rpm or deb file and possibly some other formats of distributions that use package kit.
# Outputs:
# Depends:
#           - Functions; write_error, check_dependencies
#           - Software: wget, pkcon
# Returns: 0/1
# Usage:
# 	   software::vendor_download_and_install https://download.teamviewer.com/download/linux/teamviewer_amd64.deb
# 	   software::vendor_download_and_install https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm
# End of documentation

	download_url="$1"
	fetch_file () { wget -P ${_OEM_DIR}/cache "${download_url}"  ; }

	echo  "${FUNCNAME[0]}: getting package ${download_url}..."
	if hash wget ; then
		fetch_file
	elif check_dependencies wget ; then
		fetch_file
	else
		write_error "Unable to download requested file:  ${download_url}..."
		write_error "Please check if wget is available since this is used to download files..."
		write_error "You may also want to check that the internet is reachable from this computer?"
		return 1
	fi

	echo "${FUNCNAME[0]}: Installing package $(basename ${download_url}) ..."
	if hash pkcon ; then
		pkcon install-local -y ${_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	else
		check_dependencies packagekit-tools
		pkcon install-local -y ${_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	fi
}









SoftwareManagementAvailabilityCHK() {
# Description: Function to check and see if the system software managment is available. In some cases
# the software managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	if hash apt ; then
		echo ""
		write_information "--- Checking if software maintenance system is available:"
		i=0
		tput sc
		while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
			case $((${i} % 4)) in
				0 ) j="-" ;;
				1 ) j="\\" ;;
				2 ) j="|" ;;
				3 ) j="/" ;;
			esac
			tput rc
			echo -en "\r[${j}] Waiting for other software managers to finish..."\

			sleep 5
			((i=i+1))
		done
		write_information "--- Software maintenance system is available."
	fi
}





software::native_management_availability_check() {
# Description: Function to check and see if the system software managment is available. In some cases
# the software managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	if hash zypper ; then
		write_information "--- Checking if software maintenance system is available:"
	elif hash dnf ; then
		write_information "--- Checking if software maintenance system is available:"
	elif hash apt ; then
		echo ""
		write_information "--- Checking if software maintenance system is available:"
		i=0
		tput sc
		while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
			case $((${i} % 4)) in
				0 ) j="-" ;;
				1 ) j="\\" ;;
				2 ) j="|" ;;
				3 ) j="/" ;;
			esac
			tput rc
			echo -en "\r[${j}] Waiting for other software managers to finish..."\

			sleep 5
			((i=i+1))
		done
		write_information "--- Software maintenance system is available."
	fi
}




display_software_installation_choices_gtk() {
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACKTITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#                           DEPRECATED
#
# End of documentation

	DisplayMenu=( zenity  --list  --cancel-label="Go Back" --timeout 120 --width=800 --height=600 --text "$_BACKTITLE" --checklist \
	--column "ON/OFF" --column "Select Software to add:" --separator " " )
	SoftwareList=$(list_loaded_software_functions --nonum)
	MenuOptions=($(for i in $SoftwareList ; do echo -e "${zstatus:=false} ${i}" ; done ))

	declare -A choices
	choices=$("${DisplayMenu[@]}" "${MenuOptions[@]}" )

	for choice in ${choices}
		do
		# call each chosen software install (by function) & add recepie (removed for display purposes)
		software::add_software_task recipe_${choice}
	done
}




software::display_bundle_install_choices_gtk() {
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACK_TITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

	while true; do
		exec 3>&1
		local DisplayList=$(software::list_bundles --zformat-installable)
		local IFS_SAV=$IFS
		local IFS=$(echo -en "\n\b")

		selection=$(zenity --list --title="${FUNCNAME[1]}: Select Task" --cancel-label="Go Back" --checklist \
			--text=" Select a Software Bundle below that you want to add to this computer: \n NOTE: only bundles that are not yet installed are shown. \n" \
			--height=600 --width=980 \
			--print-column=2 --column="Selected" --column="Bundle" --column="Description" \
			--separator=" " ${DisplayList} )
		exit_status=$?
		IFS=$IFS_SAV
		exec 3>&-

		case $exit_status in
			1) clear && echo [Cancel] && break ;;
			255) clear && echo [ESC] && return ;;
		esac

		case "${selection}" in
			"${selection}" )
				_done=0 ; for i in $(cat ${completed_bundles_list}) ; do ((_done=_done+1)) ; done
				_count=0
				previously_completed_bundles="$(cat ${completed_bundles_list})"

				run_bundle_install () {
					selection_list=(${selection})
					total_count=${#selection_list[@]}
					for i in ${selection} ; do
						current_bundle="${i}"
						((_count=_count+1))
						echo "# Installing bundle ${_count} of ${total_count}: ${current_bundle}..."
						if recipe_Bundle:_${current_bundle} &>/dev/null  ; then
							echo "${current_bundle}" >> ${completed_bundles_list}
							system::log_item "Progress so far: $(( 100*${_count}/${total_count} ))% of bundles installed."
						else 
							system::log_item "ERROR: ${_count} of ${total_count}: ${current_bundle} may have installed with errors or failed to install." 
							echo "${current_bundle}" >> ${completed_bundles_list}
							system::log_item "Progress so far: $(( 100*${_count}/${total_count} ))% of bundles installed."
						fi
						echo $(( 100*${_count}/${total_count} ))
					done
				}
				run_bundle_install | zenity --progress --no-cancel --auto-close  \
				--title="Installing Software Prodictivity Bundles" \
				--text="Please wait for the bundle installs to complete..." \
				--percentage=10 --height=200 --width=600

				for i in $(cat ${completed_bundles_list}) ; do ((_count=_count+1)) ; done
				_diff=$(( ${_count} - ${_done} ))
				completed_bundles="$(tail -${_diff} ${completed_bundles_list} )"

				zenity --info --timeout 120 \
				--title "Bundles Installed: ${_count} Bundles Previously Installed: ${_done}" \
				--text="The following Software bundles have been installed: \n \n ${completed_bundles} \n \n Previouly installed bundles: \n \n ${previously_completed_bundles}" \
				--height=600 \
				--width=800

				for i in _done _count completed_bundles previously_completed_bundles selection_list total_count current_bundle ; do unset ${i} ; done
			;;
			* )
				# Trap unknown conditions so as to not do harm
				exit
			;;
		esac
	done
	return
}




software::display_bundle_removal_choices_gtk() {
# Function to display the Software Prodictivity Bundles removal otions. All software options are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populste
# the menu displayed to the user.
#
# Globals: ${_BACK_TITLE} ${zstatus}
# Dependencies: file: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

	while true; do
		exec 3>&1
			DisplayList=$(software::list_bundles --zformat-removable)
			IFS_SAV=$IFS
			IFS=$(echo -en "\n\b")
			selection=$(zenity --list --title="${FUNCNAME[1]}: Select Task" --cancel-label="Go Back" --checklist \
			--text=" Select a Software Bundle below that you want to REMOVE from this computer: \n \n" \
			--height=600 --width=980 \
			--print-column=2 --column="Selected" --column="Bundle" --column="Description" --separator=" " ${DisplayList} )
			exit_status=$?
			IFS=$IFS_SAV
		exec 3>&-

		case $exit_status in
			1) clear && echo [Cancel] && return ;;
			255) clear && echo [ESC] && return ;;
		esac

		case "${selection}" in
			"${selection}" )
				local d=0 ; for i in $(cat ${completed_bundles_list}) ; do ((d=d+1)) ; done
				local c=0
				selection_list=(${selection})
				total_count=${#selection_list[@]}
				removed_bundle_list="$(mktemp)"
				run_bundle_uninstall () {
					for i in ${selection} ; do
						current_bundle="${i}"
						((c=c+1))
						echo "# Removing bundle ${c} of ${total_count}: ${current_bundle}..."
						recipe_Bundle:_${i} --remove 
						sed -i "/${current_bundle}/d" "${completed_bundles_list}"
						echo ${current_bundle} >> "${removed_bundle_list}"
						echo $(( 100*${c}/${total_count} ))
					done
				}
				run_bundle_uninstall | zenity --progress --no-cancel --auto-close \
				--title="Removing Software Prodictivity Bundles" \
				--text="Please wait for the bundle removals to complete..." \
				--percentage=10 --height=200 --width=600

				zenity --info \
				--timeout 120 \
				--title "Bundles Removed: $c " \
				--text="The following Software bundles have been REMOVED: \n \n $(cat ${removed_bundle_list}) " \
				--height=600 \
				--width=800
			;;
			* )
				# Trap unknown conditions so as to not do harm
				exit
			;;
		esac

		for i in DisplayList selection_list total_count current_bundle removed_bundle_list ; do unset ${i} ; done
	done
	return
}







rtd_server_setup_choices_services() {
# Description: Function to display server installation options. This will install software that is usefull
# on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
#
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...
	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Server Role Options Menu" --separate-output --checklist "Please Select a role for this system below:" 22 85 16 )
	options=(1 "Install Minecraft Server" off
		 2 "Install LAMP Server" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)	write_status "Installing and configuring Minecraft server, launcher, auto startup, etc... "
					if java --version ; then
						echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
					else
						check_dependencies default-jre
					fi

					if cat /home/$SUDO_USER/minecraft-server |grep SLS ; then
						write_information "minecraft server launcher is already present..."
					else
						system::minecraft_server_launcher "/home/$SUDO_USER/minecraft-server"
					fi

					if cat /etc/systemd/system/getty@tty1.service.d/override.conf |grep tangarora ; then
						write_information "Service auto login already setup..."
					else
						write_warning "Minecraft server startup is not enabled: seting up now..."
						toggle_oem_auto_login --enable
					fi

					if cat /home/$SUDO_USER/.bashrc |grep minecraft-server ; then
						write_information "minecraft server is ready to start on login"
					else
						sudo -H -u tangarora bash -c 'echo ~/minecraft-server >> ~/.bashrc'
					fi

					dialog --backtitle "$BRANDING" --title "Install Status" --yesno "I am done installing Minecraft Server. What Do you want to run the Minecraft Server now? " "$HEIGHT" "$WIDTH"
					exit_status=$?

					case $exit_status in
						0 ) sudo -H -u tangarora bash -c 'bash ~/minecraft-server' ;;
						1 ) return ;;
					esac
				;;
				2)  for i in apache2 mysql-server php libapache2-mod-php php-mcrypt php-mysql phpmyadmin nodejs ; do InstallSoftwareFromRepo $i ; done ;;
			esac
		done
}








rtd_server_setup_choices_productivity() {
# Description: Function to display terminal software installation options. This will install
# software that is usefull on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
# NOTE:
# This may be a good usecase if you happen to be in an opressed geographic locaiton where
# your only option is to ssh to a remote server and access email and web that way.
# Perfomance in these cases may be very poor over the internet (as for example with
# the great firewall of China). In Such a case it would be usefull to have the good
# old CLI software! :)
# End of documentation

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Terminal Productivity Software Options" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on
		2 "Alpine email client" on
		3 "Vim text editor" on
		4 "Finch multi protocol chat" on
		5 "Word Grinder word precessor" on
		6 "Spreadsheet Calculator" on
		7 "TPP Presentation Program" on
		8 "Midnight Commander file manager (Norton Commander)" on
		9 "Cmus Music Player" on
		10 "Byobu Terminal Window Manger" on
		11 "W3M web Browser" on
		12 "LYNX Web Browser" on
		13 "Mega.nz command line tools (Mega-CMD)" on
		14 "Rtorrent torrent download software" off
		15 "Install the OpenVpn client Software" on
		16 "Games: Freesweep mine sweep game" on
		17 "Games: Bastet Tetris Game" on
		18 "OEM Customizatons" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			case $choice in
				1) for i in htop powertop iftop monit nethogs bmon darkstat mtr glances nmap multitail ncdu ; do InstallSoftwareFromRepo $i ; done ;;
				2)  InstallSoftwareFromRepo alpine ;;
				3)  InstallSoftwareFromRepo vim ;;
				4)  InstallSoftwareFromRepo finch ;;
				5)  InstallSoftwareFromRepo wordgrinder ;;
				6)  InstallSoftwareFromRepo sc ;;
				7)  InstallSoftwareFromRepo tpp ;;
				8)  InstallSoftwareFromRepo mc ;;
				9)  InstallSoftwareFromRepo cmus ;;
				10) InstallSoftwareFromRepo byobu ;;
				11) InstallSoftwareFromRepo w3m ;;
				12) InstallSoftwareFromRepo lynx ;;
				13) Single_Install_MEGA.nz_Encrypted_Cloud_Storage megacmd ;;
				14) InstallSoftwareFromRepo rtorrent ;;
				15) InstallSoftwareFromRepo openvpn ;;
				16) InstallSoftwareFromRepo freesweep ;;
				17) InstallSoftwareFromRepo bastet ;;
				18) echo 'export PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "' >> ~/.bashrc ;;
			esac
		done
}






rtd_setup_choices_server() {
# Description: Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "System Software Chooser" --menu "It looks like this is a server to me. Please Select a role for htis system below:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  )
	options=(1 "Select terminal apps to install (i.e. vim, Lynx, Midnight Commander etc.)"
		 2 "Select Role (i.e. SSH server, Minecraft Server, etc.)"
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)  rtd_server_setup_choices_productivity ;;
				2)  rtd_server_setup_choices_services ;;
			esac
		done
}









































###########################################################################################
#
# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
#            . _..::__:  ,-"-"._        |7       ,     _,.__
#    _.___ _ _<_>`!(._`.`-.    /         _._     `_ ,_/  '  '-._.---.-.__
# >.{     " " `-==,',._\{  \  / {)      / _ ">_,-' `                mt-2_
#   \_.:--.       `._ )`^-. "'       , [_/(                       __,/-'
#  '"'     \         "    _L        oD_,--'                )     /. (|
#           |           ,'          _)_.\\._<> 6              _,' /  '
#           `.         /           [_/_'` `"(                <'}  )
#            \\    .-. )           /   `-'"..' `:.#          _)  '
#     `        \  (  `(           /         `:\  > \  ,-^.  /' '
#               `._,   ""         |           \`'   \|   ?_)  {\
#                  `=.---.        `._._       ,'     "`  |' ,- '.
#                    |    `-._         |     /          `:`<_|h--._
#                    (        >        .     | ,          `=.__.`-'\
#                     `.     /         |     |{|              ,-.,\     .
#                      |   ,'           \   / `'            ,"     \
#                      |  /              |_'                |  __  /
#                      | |                                  '-'  `-'   \.
#                      |/                                         "    /
#                      \.                                             '

#                       ,/            ______._.--._ _..---.---------._
#      ,-----"-..?----_/ )      __,-'"             "                  (
# -.._(                  `-----'                                       `-
# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
#
#
###########################################################################################
#
# 888     888 d8b         888                      888                                              
# 888     888 Y8P         888                      888                                              
# 888     888             888                      888                                              
# Y88b   d88P 888 888d888 888888 888  888  8888b.  888                                              
#  Y88b d88P  888 888P"   888    888  888     "88b 888                                              
#   Y88o88P   888 888     888    888  888 .d888888 888                                              
#    Y888P    888 888     Y88b.  Y88b 888 888  888 888                                              
#     Y8P     888 888      "Y888  "Y88888 "Y888888 888                                              
#                                                                                                 
#                                                                                                 
#                                                                                                 
# 888b     d888                   888      d8b                                                      
# 8888b   d8888                   888      Y8P                                                      
# 88888b.d88888                   888                                                               
# 888Y88888P888  8888b.   .d8888b 88888b.  888 88888b.   .d88b.                                     
# 888 Y888P 888     "88b d88P"    888 "88b 888 888 "88b d8P  Y8b                                    
# 888  Y8P  888 .d888888 888      888  888 888 888  888 88888888                                    
# 888   "   888 888  888 Y88b.    888  888 888 888  888 Y8b.                                        
# 888       888 "Y888888  "Y8888P 888  888 888 888  888  "Y8888                                     
#                                                                                                 
#                                                                                                 
#                                                                                                 
# 888b     d888                                                                              888    
# 8888b   d8888                                                                              888    
# 88888b.d88888                                                                              888    
# 888Y88888P888  8888b.  88888b.   8888b.   .d88b.   .d88b.  88888b.d88b.   .d88b.  88888b.  888888 
# 888 Y888P 888     "88b 888 "88b     "88b d88P"88b d8P  Y8b 888 "888 "88b d8P  Y8b 888 "88b 888    
# 888  Y8P  888 .d888888 888  888 .d888888 888  888 88888888 888  888  888 88888888 888  888 888    
# 888   "   888 888  888 888  888 888  888 Y88b 888 Y8b.     888  888  888 Y8b.     888  888 Y88b.  
# 888       888 "Y888888 888  888 "Y888888  "Y88888  "Y8888  888  888  888  "Y8888  888  888  "Y888 
#                                               888                                                 
#                                          Y8b d88P                                                 
#                                           "Y88P"       
###########################################################################################



system::validate_parameters() {
# Description: Function to validate that all parameters match the pattern --option "value".
# Globals: None
# Arguments: $@ - The parameters to validate.
# Outputs: Error messages for any invalid parameters.
# Returns: 0 if all parameters are valid, 1 if any invalid parameters are found.
# Usage: validate_parameters "$@"
# End of documentation

	# Log the start of parameter validation
	system::log_item "Validating parameter format..."
	system::log_item "Parameters: $*"
	# Initialize an index to iterate through the parameters
	local index=0

	# Iterate through the parameters
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--*)
			# Check if the next parameter is provided and is not another option
			if [[ -z "$2" || "$2" == --* ]]; then
			write_error "⛔ Invalid parameter format: '$1' must be followed by a value."
			return 1
			fi
			# Log the valid parameter and its value
			system::log_item "Valid parameter format: '$1' with value: '$2'"
			shift 2
		;;
		*)
			write_error "⛔ Unexpected parameter format: '$1'. Expected an option starting with '--'."
			return 1
		;;
		esac
		index=$((index + 1))
	done

	# Log the successful validation of parameters
	system::log_item "All $index parameter pairs are valid."
	return 0
}






kvm::util::read_common_options() {
# Description: Function to read common options for KVM virtual machine creation. This function processes 
# various parameters such as role, memory, CPU, disk size, and t-shirt size, setting them for the VM.
# The function also validates the parameters and sets the prompt option for interactive configuration
# if requested by the user.
#
# Globals: _tshirt_cpu_* _tshirt_mem_* _tshirt_dsk_* for small|medioum|large|extra-large|extra-extra-large
#          as is saved in a configuration file for the user VM preferences.
# Arguments: $@ - The parameters to process.
# Outputs: Status and error messages
# Returns: 0 if successful, 1 if an error occurs
# Usage: kvm::util::read_common_options --role workstation|desktop|VDI|server --cpu 2 --memory 2048 --disk 100 
#        --tshirt-size small|medium|large|extra-large|extra-extra-large --ask YES|NO
# End of documentation

	# Log the start of reading common options for KVM VM creation
	system::log_item "Reading common options for KVM virtual machine creation..."
	ALL_PARAMS=("$@")

	# Ensure that the parameters are in a valid format
	system::validate_parameters "${ALL_PARAMS[@]}"

	# Process each argument passed to the function
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--role | --Role )
			# Handle the role option: validate and set the role if valid
			if [[ $2 == "workstation" || $2 == "desktop" || $2 == "VDI" || $2 == "server" ]] ; then
				_role="${2}"
				write_status "🎭 Selecting role: ${2}"
			else
				write_error "⛔ Unknown role selection: ${2} ==> Use workstation, desktop, VDI, or server"
				return 1
			fi
			shift 2
		;;
		--ask | --prompt | --interactive )
			# Handle the interactive prompt option: validate and set the prompt option if valid
			if [[ $2 == "YES" || $2 == "yes" || $2 == "Yes" || $2 == "NO" || $2 == "No" || $2 == "no" ]] ; then
				_ask="${2}"
				write_status "🤔 Enabled prompting for configuration options..."
			else
				write_error "⛔ Incorrect option: ${2} ==> Use YES or NO"
				return 1
			fi
			shift 2
		;;
		--ram | --memory | -m )
			# Handle the memory option: set the memory size
			_mem="${2}"
			write_status "🖥️ Memory: ${_mem}"
			shift 2
		;;
		--cpu | -c )
			# Handle the CPU option: set the number of CPUs
			_cpu="${2}"
			write_status "🖥️ CPU's: ${_cpu}"
			shift 2
		;;
		--disk | -d )
			# Handle the disk option: set the disk size
			_dsk="${2}"
			write_status "🖥️ Disk Size: ${_dsk}"
			shift 2
		;;
		--tshirt-size | -t )
			# Handle the T-shirt size option: set CPU, memory, and disk size based on the selected size
			case "${2}" in
			"small" | "S" | "s" )
				_cpu=${_tshirt_cpu_small:-"2"}
				_mem=${_tshirt_mem_small:-"2048"}
				_dsk=${_tshirt_dsk_small:-"100"}
				write_status "👕 T-Shirt Size Small: CPU: ${_cpu} Memory: ${_mem} Disk: ${_dsk}"
			;;
			"medium" | "M" | "m" )
				_cpu=${_tshirt_cpu_medium:-"4"}
				_mem=${_tshirt_mem_medium:-"4096"}
				_dsk=${_tshirt_dsk_medium:-"100"}
				write_status "👕 T-Shirt Size Medium: CPU: ${_cpu} Memory: ${_mem} Disk: ${_dsk}"
			;;
			"large" | "L" | "l" )
				_cpu=${_tshirt_cpu_large:-"8"}
				_mem=${_tshirt_mem_large:-"8192"}
				_dsk=${_tshirt_dsk_large:-"100"}
				write_status "👕 T-Shirt Size Large: CPU: ${_cpu} Memory: ${_mem} Disk: ${_dsk}"
			;;
			"extra-large" | "XL" | "xl" )
				_cpu=${_tshirt_cpu_XL:-"16"}
				_mem=${_tshirt_mem_XL:-"16384"}
				_dsk=${_tshirt_dsk_XL:-"100"}
				write_status "👕 T-Shirt Size Extra Large: CPU: ${_cpu} Memory: ${_mem} Disk: ${_dsk}"
			;;
			"extra-extra-large" | "XXL" | "xxl" )
				_cpu=${_tshirt_cpu_XXL:-"32"}
				_mem=${_tshirt_mem_XXL:-"32768"}
				_dsk=${_tshirt_dsk_XXL:-"100"}
				write_status "👕 T-Shirt Size Extra Extra Large: CPU: ${_cpu} Memory: ${_mem} Disk: ${_dsk}"
			;;
			esac
			shift 2
		;;
		*)
			# Log any unknown parameters and ignore them
			system::log_item "Unknown common parameter:[$1] - ignoring..."
			shift
		;;
		esac
		shift 
	done

}




kvm::util::read_distro_options() {
# Description: Function to read distribution specific options for KVM virtual machine creation. This function processes
# various parameters such as desktop environment, server role, and source URL, setting them for the VM.
# It also handles interactive prompts for configuration options if specified.
# Globals: None
# Arguments: $@ - The parameters to process.
# Outputs: Status and error messages
# Returns: 0 if successful, 1 if an error occurs
# Usage: kvm::util::read_distro_options --desktop_environment @deepin-desktop-environment --server_role @web-server-environment --source https://dl.fedoraproject.org/pub/fedora/linux/releases/39/Everything/x86_64/os/
# End of documentation

	# Log the start of reading distribution specific options for KVM VM creation
	system::log_item "Reading distribution specific options for KVM virtual machine creation..."
	ALL_PARAMS=("$@")

	# Ensure that the parameters are in a valid format
	system::validate_parameters "${ALL_PARAMS[@]}"

	# process each argument passed to the function and find the distributoin option if it exists
	system::log_item "Reading if distribution has been explicitly requested..."
	while [[ $# -gt 0 ]]; do
		case "$1" in 
			--distribution | --distro | --dist | -d )
				# Handle the distribution option: set the distribution
				_distribution="$2"
				write_status "🐧 Distribution requested explicitly: ${_distribution}"
				shift 2
			;;
			*)
				shift
			;;
		esac
		shift
	done


	# If a distribution is not set, try to determine it from the calling function name
	if [[ -z "${_distribution}" ]]; then
		# List of distributions to check
		system::log_item "Determining distribution from function name; looking for fedora, ubuntu, debian, suse, centos, rhel, or microsoft..."
		distributions=("fedora" "ubuntu" "debian" "suse" "centos" "rhel" "microsoft")
		
		# Iterate over the distributions and check if the function name contains one of them
		for distro in "${distributions[@]}"; do
			if [[ ${FUNCNAME[1]} == *"$distro"* ]]; then
				_distribution="$distro"
				system::log_item "Distribution determined from function name: ${_distribution}"
				break
			fi
		done
	else 
		system::log_item "Distribution set by caller: ${_distribution}"
	fi

	# Finally check if the distribution is set, if not log an error
	if [[ -z "${_distribution}" ]]; then
		# Log an error if the distribution is not set
		write_error "⛔ Distribution not set or determined, ingoring any speciffic settings and continuing with defaults..."
	fi

	# Process known distribution speciffic options
	kvm::util::read_distro_options::process_all_params() {
		case "${_distribution}" in 
			"fedora" | "Fedora" | "FEDORA" )
				system::log_item "🐧 Set the requested options for Fedora..."
				while [[ $# -gt 0 ]] ; do
					case ${1} in
						--desktop_environment | --DE )
							if [[ $2 == "@deepin-desktop-environment" || $2 == "@sway-desktop-environment" || $2 == "@basic-desktop-environment" || $2 == "@(i3-desktop-environment" || $2 == "@developer-workstation-environment" || $2 == "@budgie-desktop-environment" || $2 == "@sugar-desktop-environment" || $2 == "@mate-desktop-environment" || $2 == "@kde-desktop-environment" || $2 == "@xfce-desktop-environment" || $2 == "@lxde-desktop-environment" || $2 == "@lxqt-desktop-environment" || $2 == "@cinnamon-desktop-environment" || $2 == "@mate-desktop-environment" || $2 == "@workstation-product-environment" ]] ; then
								_UserDesktopEnvironmentSelection="${2}"
								write_host --cyan  "🖥️ Selecting desktop environment: ${_UserDesktopEnvironmentSelection}"
							else
								write_error "⛔ Unknown Desktop Environment: $2 ==> Use deepin-desktop-environment, sway-desktop-environment, basic-desktop-environment, i3-desktop-environment, developer-workstation-environment, budgie-desktop-environment, sugar-desktop-environment, mate-desktop-environment, kde-desktop-environment, xfce-desktop-environment, lxde-desktop-environment, lxqt-desktop-environment, cinnamon-desktop-environment, mate-desktop-environment, workstation-product-environment"
								return 1
							fi
							shift 2
						;;
						--server_role | --ServerRole | --SR )
							if [[ $2 == "@minimal-environment" || $2 == "@web-server-environment" || $2 == "@freeipa-server" || $2 == "@network-server" || $2 == "@cloud-server-environment" || $2 == "@infrastructure-server-environment" ]] ; then
								_UserServerEnvironemtSelection="${2}"
								write_status "🎭 Selecting server role: ${2}"
							else
								write_error "⛔ Unknown server role selection: ${2} ==> Use web-server-environment, freeipa-server, network-server, cloud-server-environment, infrastructure-server-environment"
								return 1
							fi
							shift 2
						;;
						--source | --URL | --url )
							_repo_url="${2}"
							write_status "🌐 Using URL: ${_repo_url}"
							shift 2
						;;
						*)
							shift
						;;
					esac
					shift
				done
			;;
			"ubuntu" | "Ubuntu" | "UBUNTU" )
				while [[ $# -gt 0 ]]; do
					case "$1" in
					--saveto | --location | --path | --dir | --directory | -p )
						_saveto="$2"
						write_host --cyan  "📜 Directed to create preseed instructions file: ${_saveto}/preseed.cfg"
						shift 2
					;;
					--file | --preseed | --preseed_file | --preseed_cfg | --preseed_cfg_file | --preseed_file )
						_preseed_file="$2"
						write_host --cyan  "📜 Directed to create preseed instructions file: ${_preseed_file}"
						shift 2
					;;
					--flavor | --Flavor )
						# Ubuntu flavor to use (e.g. ubuntu, kubuntu, lubuntu, xubuntu, etc.)
						_flavor="$2"
						shift  2
					;;
					--desktop_environment | --DE )
						if [[ $2 == "ubuntu-desktop" || $2 == "kubuntu-desktop" || $2 == "xubuntu-desktop" || $2 == "lubuntu-desktop" || $2 == "ubuntu-mate-desktop" || $2 == "ubuntu-budgie-desktop" ]] ; then
							_UserDesktopEnvironmentSelection="${2}"
							write_host --cyan  "🖥️ Selecting desktop environment: ${_UserDesktopEnvironmentSelection}"
						else
							write_error "⛔ Unknown Desktop Environment: $2 ==> Use ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop, ubuntu-mate-desktop, ubuntu-budgie-desktop"
							return 1
						fi
						shift 2
					;;
					--server_role | --ServerRole | --SR )
						if [[ $2 == "openssh-server" || $2 == "xubuntu-core" || $2 == "lamp-server" || $2 == "postfix" || $2 == "bind9" || $2 == "dnsmasq" || $2 == "dhcp-server" || $2 == "print-server" ]]  ; then
							_UserServerEnvironemtSelection="${2}"
							write_status "🎭 Selecting server role: ${2}"
						else
							write_error "⛔ Unknown server role selection: ${2} ==> Use open-ssh-server, xubuntu-core, lamp-server, postfix, bind9, dnsmasq, dhcp-server, print-server"
							return 1
						fi
						shift 2
					;;
					--version | -v )
						_tgt_ubuntu_ver="$2"
						write_status "🐧 Ubuntu version requested: ${_tgt_ubuntu_ver}"
						return 0
					;;
					*)
						shift
					;;
					esac
					shift 
				done
			;;
			"debian" | "Debian" | "DEBIAN" )
				while [[ $# -gt 0 ]]; do
					case "$1" in
					--desktop_environment | --DE )
						if [[ $2 == "gnome-desktop" || $2 == "kde-desktop" || $2 == "lxde-desktop" || $2 == "xfce-desktop" || $2 == "mate-desktop" || $2 == "cinnamon-desktop"  ]] ; then
							_UserDesktopEnvironmentSelection="${2}"
							write_host --cyan  "🖥️ Selecting desktop environment: ${_UserDesktopEnvironmentSelection}"
						else
							write_error "⛔ Unknown Desktop Environment: $2 ==> Use gnome-desktop, kde-desktop, lxde-desktop, xfce-desktop, mate-desktop, cinnamon-desktop"
							return 1
						fi
						shift 2
					;;
					--server_role | --ServerRole | --SR )
						if [[ $2 == "openssh-server" || $2 == "lamp-server" || $2 == "postfix" || $2 == "bind9" || $2 == "dnsmasq" || $2 == "dhcp-server" || $2 == "print-server" ]]  ; then
							_UserServerEnvironemtSelection="${2}"
							write_status "🎭 Selecting server role: ${2}"
						else
							write_error "⛔ Unknown server role selection: ${2} ==> Use web-server-environment, freeipa-server, network-server, cloud-server-environment, infrastructure-server-environment"
							return 1
						fi
						shift 2
					;;
					--saveto | --location | --path | --dir | --directory | -p )
						_saveto="$2"
						write_host --cyan  "📜 Directed to create preseed instructions file: ${_saveto}/preseed.cfg"
						shift 2
					;;
					--file | --preseed | --preseed_file | --preseed_cfg | --preseed_cfg_file | --preseed_file )
						_preseed_file="$2"
						write_host --cyan  "📜 Directed to create preseed instructions file: ${_preseed_file}"
						shift 2
					;;
					*)
						shift
					;;
					esac
					shift 
				done
			;;
			"suse" | "SUSE" | "Suse" | "openSUSE" | "OpenSUSE" | "opensuse" | "OpenSuse" | "OPENSUSE" | "OPENSuse" | "OPENSUSE" )
				while [[ $# -gt 0 ]]; do
					case "$1" in
					--source_url | --url | --source | --URL )
						source_url="${2}"
						system::log_item "📋 instructed to use source: ${_filename}"
						shift 2
					;;
					--filename | --file )
						_autoyast_filename="$2"
						system::log_item "AutoYaST file will be saved as: ${_autoyast_filename}"
						shift 2
					;;
					--desktop_environment | --DE )
						if [[ $2 == "kde" || $2 == "gnome" || $2 == "xfce" || $2 == "lxde" || $2 == "mate" || $2 == "cinnamon" || $2 == "enlightenment" || $2 == "lxqt" ]] ; then
							_UserDesktopEnvironmentSelection="${2}"
							system::log_item "Desktop selection: ${_UserDesktopEnvironmentSelection}"
						else
							write_error "⛔ Unknown Desktop Environment: $2"
							return 1
						fi
						shift 2
					;;
					--server_role | --ServerRole | --SR )
						if [[ $2 == "lamp" || $2 == "dns" || $2 == "dhcp_dns_server" || $2 == "file_server" || $2 == "print_server" || $2 == "mail_server" || $2 == "monitoring" || $2 == "desktop" || $2 == "gateway_server" || $2 == "kvm_server" || $2 == "sap-bone" || $2 == "sap-hana" || $2 == "sap-nw" || $2 == "sap_server" || $2 == "xen_server" || $2 == "yast2_server" || $2 == "directory_server"  ]] ; then
							_UserServerEnvironemtSelection="${2}"
							system::log_item "Server selection: ${_UserServerEnvironemtSelection}"
						else
							write_error "⛔ Unknown Server selection: $2"
							return 1
						fi
						shift 2
					;;
					--product | --product )
						if [[ $2 == "Leap" || $2 == "SLES" || $2 == "Tumbleweed" ]] ; then
							_UserProductSelection="$2"
							system::log_item "Product selection: ${_UserProductSelection}"
						else
							write_error "⛔ Unknown product selection: $2"
							return 1
						fi
						shift 2
					;;
					--disk_encryption | --DC )
						if [[ $2 == "YES" || $2 == "NO" ]] ; then
							Preference_DiskEncryption="$2"
							system::log_item "Disk encryption: ${Preference_DiskEncryption}"
						else
							write_error "⛔ Unknown disk encryption selection: $2"
							return 1
						fi
						shift 2
					;;
					--disk_password | --DP )
						Preference_Disk_Password="$2"
						system::log_item "Disk encryption password set."
						shift
					;;
					--saveto | --location | --path | --dir | --directory | -p )
						_saveto="$2"
						write_host --cyan  "📜 Directed to create instructions file: ${_saveto}/preseed.cfg"
						shift 2
					;;
					--file )
						_preseed_file="$2"
						write_host --cyan  "📜 Directed to create instructions file: ${_preseed_file}"
						shift 2
					;;
					*)
						shift
					;;
					esac
					shift 
				done
			;;
			"rhel" | "RHEL" | "RedHat" | "REDHAT" )
				system::log_item "🐧 Set the requested options for RedHat..."
				while [[ $# -gt 0 ]] ; do
					case ${1} in
						--desktop_environment | --DE )
							if [[ $2 == "@deepin-desktop-environment" || $2 == "@sway-desktop-environment" || $2 == "@basic-desktop-environment" || $2 == "@developer-workstation-environment" || $2 == "@sugar-desktop-environment" || $2 == "@kde-desktop-environment" || $2 == "@workstation-product-environment" ]] ; then
								_UserDesktopEnvironmentSelection="${2}"
								write_host --cyan  "🖥️ Selecting desktop environment: ${_UserDesktopEnvironmentSelection}"
							else
								write_error "⛔ Unknown Desktop Environment: $2 ==> Use basic-desktop-environment, developer-workstation-environment, sugar-desktop-environment, kde-desktop-environment, workstation-product-environment"
								return 1
							fi
							shift 2
						;;
						--server_role | --ServerRole | --SR )
							if [[ $2 == "@minimal-environment" || $2 == "@web-server-environment" || $2 == "@freeipa-server" || $2 == "@network-server" || $2 == "@cloud-server-environment" || $2 == "@infrastructure-server-environment" ]] ; then
								_UserServerEnvironemtSelection="${2}"
								write_status "🎭 Selecting server role: ${2}"
							else
								write_error "⛔ Unknown server role selection: ${2} ==> Use web-server-environment, freeipa-server, network-server, cloud-server-environment, infrastructure-server-environment"
								return 1
							fi
							shift 2
						;;
						--source | --URL | --url )
							_repo_url="${2}"
							write_status "🌐 Using URL: ${_repo_url}"
							shift 2
						;;
						*)
							shift
						;;
					esac
				done
			;;
			"Windows" | "WINDOWS" | "Win" | "Win11" | "Win10" | "Microsoft" | "microsoft" )
				system::log_item "❖ Set the requested options for Windows..."
				while  [[ $# -gt 0 ]] ; do
					case "$1" in
						--winver )
							target_winver="$2"
							write_information "❖ Custom Windows version requested and set to: ${target_winver}"
							shift 2
						;;
						*)
							shift
						;;
					esac
					shift
				done
			;;
			*)
				# Log any unknown distribution and set the default values
				system::log_item "⛔ No valid distribution requested or found, ignoring distribution speciffic VM settings..."
			;;
		esac
	}
	kvm::util::read_distro_options::process_all_params "${ALL_PARAMS[@]}"

}



test_iso_boot_media() {
# Description: Function to test a created ISO file by booting it in a temporary VM using QEMU.
# This function requires one argument or one variable (iso_test) to be set; since it needs
# to now what media to test.
#
# QEMU is a free and open-source emulator and virtualizer that
# can perform hardware virtualization. QEMU is a hosted virtual machine monitor: it emulates
# the machine's processor through dynamic binary translation and provides a set of different
# hardware and device models for the machine, enabling it to run a variety of
# guest operating systems.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# test_iso_boot_media /path/to/media
# 	OR
# iso_test=/path/to/media
# test_iso_boot_media
#
# End of Documentation
	iso_test="${1}"
	if [[ -z "${iso_test}" ]]; then
		dialog::display_error "${FUNCNAME[0]}: requires one argument (ISO file to test). Please read ${_LOGFILE} for more information."
		return 1
	else
		system::log_item "Testing ${iso_test}..."
		if ($RTD_GUI --title "BOOT Media Testing" --yesno "\n Would you like to test your boot media ${iso_test} to see if it works?" 10 80); then
			clear
			write_information "TESTING ${iso_test}."
			if ! hash qemu-system-x86_64 ; then check_dependencies qemu-system-x86_64 ; fi
			: "${bin_qemu_img:=$(type -P qemu-img)}"
			: "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
			: "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
			: "${qcow2_file:="${put_qcow_file_here_when_done}/$(basename "$iso_test" .iso).qcow2"}"

			system::log_item "executing command: ${bin_qemu_img} create -f qcow2 ${qcow2_file} 10G"

			[[ -f ${qcow2_file} ]] && rm -f "${qcow2_file}"
			if ${bin_qemu_img} create -f qcow2 "${qcow2_file}" 10G 2>&1 | tee -a "${_LOGFILE}" ; then 
				write_information "Created QCOW2 file: ${qcow2_file}"
			else
				write_error "Failed to create QCOW2 file: ${qcow2_file}"
			fi

			system::log_item "Executing command: ${bin_qemu_system_x86_64} -smp 2 -enable-kvm -m 4G --cdrom ${iso_test} ${qcow2_file}" 
			if ${bin_qemu_system_x86_64} -smp 2 -enable-kvm -m 4G --cdrom "${iso_test}" "${qcow2_file}" 2>&1 | tee -a "${_LOGFILE}" ; then
				write_information "Successfully tested ${iso_test}."
			else
				write_error "Failed to test ${iso_test}."
			fi
		else
			clear
			dialog::display_notice "User selected No, exit status was $?."
			system::log_item "User selected No, exit status was $?."
		fi
	fi
}







make_kvm_virtual_machine_now_from_fedora_org() {
# Description: Function to create a Fedora KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals: ${FedoraVersion} ${PRESEED_FILE}
# Optional arguments: workstation|ssh-server|ansible-server [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]
# Outputs: std err
# Returns: 
# Usage:
# 	make_kvm_virtual_machine_now_from_fedora_org
# 			or
# 	make_kvm_virtual_machine_now_from_fedora_org -c 4 -m 4096 -d 100
# End of Documentation

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Set specific options for Fedora...
	kvm::util::read_distro_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${virt_net="$(system::find_vm_bridge)"}"
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: "${_DEFAULT_FEDORA_VER:="$(curl -s https://dl.fedoraproject.org/pub/fedora/linux/releases/ | grep -oP 'href="\K[0-9]+(?=/")' | sort -n | tail -1)"}"
	: "${_os_version=$( $RTD_GUI --title "🐧 Select Release Version of Fedora" --inputbox "Please pick an available OS version by entering it below. \
	If you are not sure just let me choose for you... \n ${fedoralogo} "  25 110 "${_DEFAULT_FEDORA_VER:-"40"}" 3>&1 1>&2 2>&3)}"
		case $? in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac
	clear

	: "${_os_version:="${_DEFAULT_FEDORA_VER}"}"
	: "${_mirrorlist_url="https://mirrors.fedoraproject.org/mirrorlist?repo=fedora-${_os_version}&arch=x86_64"}"
	: "${_source_url:="https://dl.fedoraproject.org/pub/fedora/linux/releases/${_os_version}/Everything/x86_64/os/"}"
	: "${_preseed_file="$( mktemp -d )/ks.cfg"}"

	if [[ ${_role} == "workstation" ]] ; then
		local _service="VDI"
		system::generate_ks_cfg_file --source "${_source_url}" --role "${_role}" --file "${_preseed_file}" --DE "${_UserDesktopEnvironmentSelection:="@basic-desktop-environment"}"
	elif [[ ${_role} == "server" ]] ; then
		local _service="SRV"
		system::generate_ks_cfg_file --source "${_source_url}" --role "${_role}" --file "${_preseed_file}" --SR "${_UserServerEnvironemtSelection:="@network-server"}"
	else
		write_error "Unknown role selection: ${_role} ==> Use workstation or server"
		return 1
	fi


	local vm_name="Template_Fedora_${_service}_$(date +%Y-%m-%d-%H-%M)"

	_summary_message="The virtual machine (${vm_name}) \n
	📋 - Using the instructions in Kickstart: ${_preseed_file} \n
	🔧 - Using this source for the packages and files to download: \n
	🌎 - ${_source_url%%/*pub*} \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I)"

	write_information "Creating VM: ${vm_name}..."
	{
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant="fedora30" \
		--initrd-inject="${_preseed_file}" \
		--location="${_source_url}" \
		--extra-args "inst.ks=file:/$(basename $_preseed_file)" \
		--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
	} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

	for i in  _preseed_file vm_kernel vm_initrd _source_url _config _mirrorlist_url _os_version _summary_message ; do unset $i ; done
}







kvm::make_vm_template_now_from_redhat_com() {
# Description: Function to create a Alma Linux KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals: ${FedoraVersion} ${PRESEED_FILE}
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Set specific options for RedHat...
	kvm::util::read_distro_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: ${virt_net="$(system::find_vm_bridge)"}
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: ${_os_version:-$( $RTD_GUI --title "Select Release Version of RedHat" --inputbox "Please pick an available OS version by entering it below. \
	If you are not sure just let me choose for you... \n ${fedoralogo} "  25 110 "${_DEFAULT_REDHAT_VER}" 3>&1 1>&2 2>&3)}
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	: ${_os_version:="${_DEFAULT_REDHAT_VER}"}
	: ${_mirrorlist_url="https://mirrors.almalinux.org/mirrorlist/${_os_version}/baseos"}
	: ${_source_url:="https://repo.almalinux.org/almalinux/${_os_version}/BaseOS/x86_64/kickstart/"}
	: ${_preseed_file="$( mktemp ).cfg"}
	: ${_config="${1:-"workstation"}"}
	if [[ ${_role} == "workstation" ]] ; then
		local _service="VDI"
		system::generate_ks_cfg_file --source "${_source_url}" --role "${_role}" --file "${_preseed_file}" --DE "${_UserDesktopEnvironmentSelection:="@basic-desktop-environment"}"
	elif [[ ${_role} == "server" ]] ; then
		local _service="SRV"
		system::generate_ks_cfg_file --source "${_source_url}" --role "${_role}" --file "${_preseed_file}" --SR "${_UserServerEnvironemtSelection:="@network-server"}"
	else
		write_error "Unknown role selection: ${_role} ==> Use workstation or server"
		return 1
	fi


	local vm_name="Template_RedHat_${_service}_$(date +%Y-%m-%d-%H-%M)"

	_summary_message="The virtual machine (${vm_name}) \n
	📋 - Using the instructions in Kickstart: ${_preseed_file} \n
	🔧 - Using this source for the packages and files to download: \n
	🌎 - ${_source_url%%/*pub*} \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I)"


	write_information "Creating VM: ${vm_name}..."
	{
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant="fedora30" \
		--initrd-inject="${_preseed_file}" \
		--location="${_source_url}" \
		--extra-args "inst.ks=file:/$(basename $_preseed_file)" \
		--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
	} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

	for i in  _preseed_file vm_kernel vm_initrd _source_url _config _mirrorlist_url _os_version ; do unset $i ; done
}






make_kvm_virtual_machine_now_from_opensuse_org() {
# Description: Creates a SUSE KVM virtual machine disk and defines a VM. This function is intended to be 
# used on a Qemu/KVM virtual host where the virtual guest will run.
#
# QCOW2 (QEMU Copy On Write) is a storage format for virtual machine disk images. It decouples the physical 
# storage layer from the virtual layer by adding a mapping between logical and physical blocks.
#
# Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux. KVM allows 
# a host machine to run multiple, isolated virtual environments called guests or virtual machines (VMs).
# For more information: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Use the check_dependencies function to ensure the required software is available.
#
# Usage:
#   - Call this function with no arguments to use default values.
#   - Or call this function with the following arguments:
#     "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
#     Omitting any arguments will use the default values.
#
# Globals:
#   None required but read from the _locations.info file.
#   _SUSE_LEAP_SOURCE
#   _SUSE_SLES_SOURCE
#   _SUSE_TUMBLEWEED_SOURCE
#
# Arguments:
#   --filename <file path>                : Specifies the path and filename where the AutoYaST XML file will be saved.
#   --desktop_environment <DE name>       : Selects the desktop environment to install (kde, gnome, xfce, lxde, mate, cinnamon, enlightenment, lxqt).
#   --server_role <role name>             : Specifies the server role (lamp, dns, dhcp_dns_server, file_server, print_server, mail_server, monitoring, desktop).
#   --disk_encryption <YES|NO>            : Enables or disables disk encryption.
#   --disk_password <password>            : Sets the disk encryption password (ignored if disk encryption is NO).
#   --initial_user <username>             : Sets the username for the initial user account.
#   --initial_user_password <password>    : Sets the password for the initial user account.
#   --help | -h                           : Displays usage information for the function.
#   --source_url | --source | --URL       : The source URL for the SUSE version.
#
# Outputs:
#   Information about the created virtual machine.
#
# Returns:
#   0 on success, 1 on error.
#
# Example:
# 
# End of Documentation

	# Set default values for VM T-Shirts size...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}
	: ${CONFIG:="VDI"}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Set default values for VM T-Shirts sizes, overriding defaults if so instructed...
	kvm::util::read_common_options ${*}

	# Generate the AutoYaST file based on parameters provided...
	system::generate_autoyast_file ${*}

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	: ${virt_net="$(system::find_vm_bridge)"}
	
	# Set the default source URL for the SUSE version if not already set...
	# NOTE: Using --source_url first, then the global variable (from _locations.info), then the default.
	if [[ -z "${source_url}" ]]; then
		case ${_UserProductSelection} in 
			"Leap" )
				: ${source_url:="${_SUSE_LEAP_SOURCE:-"https://download.opensuse.org/distribution/openSUSE-current/repo/oss/"}"}
			;;
			"SLES" )
				: ${source_url:="${_SUSE_SLES_SOURCE:-"https://download.opensuse.org/distribution/leap/15.5/repo/oss/"}"}
			;;
			"Tumbleweed" )
				: ${source_url:="${_SUSE_TUMBLEWEED_SOURCE:-"https://download.opensuse.org/tumbleweed/repo/oss/"}"}
			;;
			* )
				: ${source_url:="${_SUSE_LEAP_SOURCE:-"https://download.opensuse.org/distribution/openSUSE-current/repo/oss/"}"}
			;;
		esac
	fi

	local vm_name="Template_SUSE_${CONFIG}_$(date +%Y-%m-%d-%H-%M)"

	_summary_message="
	The virtual machine (${vm_name}) \n
	📋 - Using the instructions in: ${_preseed_file} \n
	🔧 - Using this source for the packages and files to download: \n
	🌎 - ${_source_url%%/*pub*} \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n 
	
	NOTE: You may connecct to the VM and see the progress at IP: $(hostname -I) \n
	      After the build is complete you may reseal the VM and use it as a template for future VMs. \n"

	write_status "Creating virtual machine (${vm_name})"
	{
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant=opensusetumbleweed \
		--initrd-inject="${_autoyast_filename}" \
		--location="${source_url}" \
		--extra-args "AutoYaST=file:///$(basename ${_autoyast_filename})"   \
		--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
	} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

	for i in  PRESEED_FILE vm_kernel vm_initrd source_url CONFIG ; do unset $i ; done
}








kvm::make_vm_template_now_from_debian_org() {
# Description: Function to create a Debian KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}
	: ${_role:="desktop"}
	: ${_task:="ssh-server"}

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Set specific options for Debian...
	kvm::util::read_distro_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet, and set variables.
	: "${bin_virt_install:=$(type -p virt-install)}"

	# Set the default source URL for the Debian version if not already set... and add some options depending on the role.
	case "${_role}" in
		desktop | Desktop | VDI | vdi | workstation | Workstation)
			write_status "🖥️ 	- Using a desktop environment: ${_UserDesktopEnvironmentSelection}"
			: "${vm_kernel="${_DEBIAN_FRONTEND_GTK_KERNEL}"}"
			: "${vm_initrd="${_DEBIAN_FRONTEND_GTK_INITRD}"}"
			: "${ui_diplay_style="theme=dark"}"
			: "${vm_usecase="VDI"}"
			local vm_name="Template_Debian_${vm_usecase}_${_UserDesktopEnvironmentSelection}_$(date +%Y-%m-%d-%H-%M)"
			write_status "🖥️ 	- Using Variables: \n ${vm_kernel}, \n ${vm_initrd}"
			system::make_preseed_cfg --role "${_role}" --desktop_environment "${_UserDesktopEnvironmentSelection}" --saveto "$( mktemp -d)" 
		;;
		* )
			write_status "🖥️ 	- Using a environment: ${_role}"
			: "${vm_kernel="${_DEBIAN_FRONTEND_DEFAULT_KERNEL}"}"
			: "${vm_initrd="${_DEBIAN_FRONTEND_DEFAULT_INITRD}"}"
			: "${ui_diplay_style="theme=light"}"
			: "${vm_usecase="Server"}"
			local vm_name="Template_Debian_${_task}_$(date +%Y-%m-%d-%H-%M)"
			write_status "🖥️ 	- Using Variables: \n ${vm_kernel}, \n ${vm_initrd}"
			system::make_preseed_cfg --role "${_role}" --server_role "${_UserServerEnvironemtSelection}" --saveto "$( mktemp -d)" 
		;;
	esac
	
	write_status "🔎 	- Discovering what the appropriate VM net interface is (default or br'0 - n')"
	: ${virt_net="$(system::find_vm_bridge)"}
	write_status "🔎	- Using network (${virt_net})"
	: ${source_url:="${_DEBIAN_SOURCE_URL}"}
	
	system::check_required_variables "vm_name" "vm_kernel" "vm_initrd" "source_url" "virt_net" "_mem" "_cpu" "_dsk" "bin_virt_install" "PRESEED_FILE" \
	|| ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	_summary_message="
	The virtual machine (${vm_name}) \n
	📋 - Using the instructions in: ${_preseed_file} \n
	🔧 - Using this source for the packages and files to download: \n
	🌎 - ${_source_url%%/*pub*} \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n 
	
	NOTE: You may connecct to the VM and see the progress at IP: $(hostname -I) \n
	      After the build is complete you may reseal the VM and use it as a template for future VMs. \n"


	write_status "🔧 - Creating the VM..."	
	{
	"${bin_virt_install}" --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--location="${source_url}" \
		--os-variant="debian10" \
		--video "virtio" --channel "spicevmc" \
		--initrd-inject="${PRESEED_FILE}" \
		--install kernel="${vm_kernel}",initrd="${vm_initrd}" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE) ${ui_diplay_style}" \
		--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
	} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

	for i in  PRESEED_FILE vm_kernel vm_initrd source_url ui_diplay_style vm_name vm_usecase ; do unset $i ; done

}






kvm::make_vm_template_now_from_ubuntu_com() {
# Description: 
# Automates the creation of a virtual machine (VM) template using Ubuntu as the base OS on a KVM host.
# This function is ideal for quickly setting up virtual environments with custom configurations.
# This function should be used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual machine disk images.
# QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Prerequisites:
# - Must be run on a Qemu/KVM host with QEMU and KVM installed and configured.
# - Internet access is required for downloading the Ubuntu ISO file.
#   Alternatively, the ISO file can be downloaded manually and placed in a specified location.
#   The default location is /var/lib/libvirt/boot/.
# - The virt-install tool must be available on the system.
# - The function should be run with sudo or as the root user.
#
# Notes on QCOW2:
# - QCOW2 (QEMU Copy On Write version 2) is used for VM disks. It offers features like snapshot support and dynamic disk size allocation.
#
# Notes on KVM:
# - Kernel-based Virtual Machine (KVM) is a Linux kernel module that allows the kernel to function as a hypervisor. 
# - More details on KVM: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Parameters:
# --ram <value>           : Sets the VM's RAM in megabytes (default: 2048 MB).
# --cpus <value>          : Sets the number of CPU cores (default: 2).
# --disk <value>          : Sets the disk size in gigabytes (default: 100 GB).
# --flavor <value>        : Specifies the Ubuntu flavor (default: 'ubuntu').
# --role <value>          : Specifies the VM's role (e.g., desktop, server) (default: 'desktop').
# --version <value>       : Specifies the Ubuntu version; uses the latest LTS if not specified.
# --location <value>      : Override the default location for downloading or accessing the ISO.
# --ask <value>           : Enables interactive mode for manual input during setup (default: 'NO').
# --desktop_environment   : Specifies the desktop environment for desktop VMs.
# --server_role           : Specifies the server role for server VMs.
#
# Defaults:
# The function uses predefined defaults which can be overridden by specifying parameters.
#
# Usage Examples:
# Example 1: Default VM Creation
# Creates a VM using default parameters:
# kvm::make_vm_template_now_from_ubuntu_com
#
# Example 2: Fully Customized VM
# Creates a VM with 8 GB RAM, 4 CPUs, 250 GB disk, using Ubuntu 20.04 LTS, Kubuntu flavor:
# kvm::make_vm_template_now_from_ubuntu_com --ram 8192 --cpus 4 --disk 250 --flavor ubuntu --version 20.04 --role desktop
#
# Example 3: Interactive VM Setup
# Starts an interactive session to manually specify VM settings during creation:
# kvm::make_vm_template_now_from_ubuntu_com --ask YES
#
# Detailed Steps:
# 1. Parameter Parsing: Parses and applies provided command-line arguments to override default settings.
# 2. Dependency Check: Verifies all required software and dependencies are installed.
# 3. ISO Retrieval: Downloads or locates the specified Ubuntu ISO, depending on version and flavor.
# 4. VM Configuration: Sets up the VM according to the specified parameters including network and storage.
# 5. Installation Process: Initiates the installation of the Ubuntu OS on the VM using the virt-install tool.
# 6. Logging and Cleanup: Logs the setup process and cleans up any temporary files created during the installation.
#
# Error Handling:
# Implements error checks at each step to ensure any issues are addressed, such as missing dependencies or download errors.
#
#
# Notes
#
#     The function is part of a larger system presumably dealing with VM management, and it 
#     expects certain utilities and conventions to be present in the environment.
#     It is designed to be flexible with various Ubuntu versions and handles different 
#     installation (preseed.cfg or autoinstall.yaml) methods based on the version.
#     Error handling is incorporated to manage issues during the VM creation process.
#     The function includes logging capabilities for tracking the VM creation process.
#
#     Please note that the various Ubuntu versions may or may  not work with the preseed.cfg file
#     or the autoinstall.yaml correctly as Canonical changes the way the installer works constantly.
#     For stability and predictability please refer to Debian instead. Also please note that the
#     automatic installations are created per the Ubuntu documentation, and you may experience issues
#     with the preseed.cfg file or the autoinstall.yaml file anyway as the documentation appears incomplete.
#
# Globals: ${ubuntu_flavor} ${_role} ${_task} ${_cpu} ${_mem} ${_dsk} ${permanent_download_dir} ${_saveto} ${CloudConfigDir} ${bin_virt_install} ${virt_net}
# End of Documentation

	# Set default values for VM T-Shirts sizes (may vary by OS)...
	: ${ubuntu_flavor="ubuntu"} 				# This is the default flavor of Ubuntu to use.
	: ${_role:="server"}                                    # This is the default role of the Ubuntu VM to create.
	: ${_task:="ubuntu-desktop"}                            # This is the default task to perform on the Ubuntu VM.
	: ${_cpu:="${_cpu:=2}"}                                 # This is the default number of CPUs to use.
	: ${_mem:="${_mem:=2048}"}                              # This is the default amount of memory to use.
	: ${_dsk:="${_dsk:=100}"} 				# This is the default size of the disk to use.
	: ${permanent_download_dir:="/var/lib/libvirt/boot/"} 	# This is the default location for KVM ISO files.
	: ${_saveto:="$( mktemp -d /tmp/CloudConfig.XXXXXX )"}	# This is the default location preseed files.
	: ${CloudConfigDir:="$_saveto"} 			# This is the default location cidata files.
	: ${bin_virt_install:=$(type -p virt-install)} 		# This is the default location for the virt-install binary.
	: ${virt_net="$(system::find_vm_bridge)"} 		# This is the default network to use for the VM.

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Set specific options for Debian...
	kvm::util::read_distro_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# # Determine available versions of Ubuntu to offer...
	# system::log_item "🔎 Retreive list of available $ubuntu_flavor $_role versions..."
	# declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
	# declare -a all_normal_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+)/ && print "$1\n"' | sort -Vu))
	# dist_logo="${ubuntulogo}"


	# # Check if a version of Ubuntu was specified, otherwise make sure it is (default to latest LTS)...
	# if [[ -z ${_tgt_ubuntu_ver} ]]; then
	# 	write_information "🐧 - No version of Ubuntu specified..."
	# 	if [[ ${_ask} == "YES" ]]; then
	# 		write_information "🐧 - Requested to ask for Ubuntu version; prompting for version of Ubuntu to use..."
	# 		extra_option="Manually_specify"

	# 		# Display a menu to choose an Ubuntu version, including an option for manual entry
	# 		_tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor $_role" --menu "\n \Z1\n$dist_logo\Zn \n 👍 Please pick an available \Z1$ubuntu_flavor\Zn version from the list below or choose to manually specify a version. Long Term Support (LTS) Versions to choose from are as follows:\n\n " 35 90 $(( ${#all_lts_versions[@]} + 1 )) \
	# 		$(for i in "${!all_lts_versions[@]}"; do echo  "${all_lts_versions[$i]}" "$i"; done ) "$extra_option" "$(( ${#all_lts_versions[@]} + 1 ))"  3>&1 1>&2 2>&3)
	# 		dialog_status=$?

	# 		# Handle the user's menu selection or cancellation based on the captured status
	# 		case $dialog_status in
	# 			$DIALOG_CANCEL) echo "Dialog was cancelled."; return ;;
	# 			$DIALOG_ESC) echo "Dialog was escaped."; return ;;
	# 		esac

	# 		# Check if the user chose to manually specify a version
	# 		if [[ "${_tgt_ubuntu_ver}" == "${extra_option}" ]]; then
	# 			_tgt_ubuntu_ver=$($RTD_GUI --colors --title "Manual Version Input" --inputbox "\nPlease enter the desired Ubuntu version (e.g., 22.10):" 10 60 3>&1 1>&2 2>&3)
				
	# 			# Capture and handle the exit status of the input dialog
	# 			case $? in
	# 				$DIALOG_CANCEL) echo "Input was cancelled."; return ;;
	# 				$DIALOG_ESC) echo "Input was escaped."; return ;;
	# 			esac
	# 		fi

	# 		clear
	# 	else
	# 		write_information "🐧 - No version of Ubuntu specified, so using the latest LTS version: ${all_lts_versions[-1]}"
	# 		_tgt_ubuntu_ver=${all_lts_versions[-1]}
	# 	fi
	# fi

	# # Validate Ubuntu LTS version selections against available versions (manual selection may have occurred)...
	# for lts_version in "${all_lts_versions[@]}"; do
	# 	if [[ "${lts_version}" == "${_tgt_ubuntu_ver}" ]]; then
	# 		local _selection_is_valid="yes"
	# 		write_information "🐧 - The version of Ubuntu selected is valid: ${_tgt_ubuntu_ver}"
	# 	fi
	# done

	# # Validate Ubuntu normal version selections against available versions (manual selection may have occurred)...
	# for normal_version in "${all_normal_versions[@]}"; do
	# 	if [[ "${normal_version}" == "${_tgt_ubuntu_ver}" ]]; then
	# 		local _selection_is_valid="yes"
	# 		write_information "🐧 - The version of Ubuntu selected is valid: ${_tgt_ubuntu_ver}"
	# 	fi
	# done

	# if [[ "${_selection_is_valid}" != "yes" ]]; then
	# 	write_error "⛔ - The version of Ubuntu selected [${_tgt_ubuntu_ver}] is not valid. Please select a valid version list. Alternatively, you may let me choose for you..."
	# 	read -p "Press [ENTER] to continue..." 
	# 	return 1
	# fi

	# Return the version number selected
	# _tgt_ubuntu_ver=${_tgt_ubuntu_ver:-${all_lts_versions[-1]}}

	system::get_tgt_ubuntu_version
	# Format the name of the VM to be created...
	local vm_name="Template_Ubuntu_${_tgt_ubuntu_ver}_${_role}_$(date +%Y-%m-%d-%s)"

	# Create auto installation files for the Ubuntu VM...
	system::make_preseed_cfg --role ${_role} --saveto ${_saveto} --desktop_environment ${_UserDesktopEnvironmentSelection}
	: ${ubuntu_iso_url=$(system::rtd_oem_find_live_release --version ${_tgt_ubuntu_ver} --distribution ${ubuntu_flavor} --desktop )}
	: ${iso_filename:="$(basename $ubuntu_iso_url)"}

	# # Ensure that the file is available for VM creation... 
	# write_status "Checking if $iso_filename already downloaded..."
	# iso=$(find "$permanent_download_dir" -name "$iso_filename")
	# if [ ! -e "$iso" ]; then
	# 	write_warning "$iso_filename is not in cache, downloading..."
	# 	wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "FATAL Problem: Failure to download ISO file $ubuntu_iso_url"
	# 	iso="$permanent_download_dir/$iso_filename"
	# else
	# 	write_information "💿 - $iso_filename already in cache, using it for VM greenfield creation..."
	# fi

	# ensure local media:    [/where/to/look/first] 
	system::get_ubuntu_media /var/lib/libvirt/boot

	# Prepare the summary message for the VM creation...
	_summary_message="
	The virtual machine (${vm_name}) \n
	📋 - Using the instructions in: ${_preseed_file} \n
	🔧 - Using this source for the packages and files to download: \n
	🌎 - ISO from ${permanent_download_dir} or \n
	💿 - URL: https://ftp.halifax.rwth-aachen.de/ubuntu/dists/trusty/main/installer-amd64/  \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n 
	
	NOTE: You may connect to the VM and see the progress at IP: $(hostname -I) \n
	      After the build is complete you may reseal the VM and use it as a template for future VMs. \n"

	# Check the version of Ubuntu and use the appropriate installer...
	# Ubuntu is migration installers and methods, so we need to check the version and use the appropriate installer...

	case "${_role}" in
		workstation | desktop | VDI )
			write_status "🖥️ 	- Using a desktop environment: ${_UserDesktopEnvironmentSelection}"
			if [[ ${_tgt_ubuntu_ver::2} -lt 16 ]] ; then

				# for really old Ubuntu builds (less than 16) use the debian installer (d-i) and using DVD ISO but still PRESEED.cfg...
				# Ubuntu 14* look for the kernel called vmlinuz.efi and initrd called initrd instead of vmlinuz and initrd.gz, so 
				# we use a different option to install the VM.
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: is less than 16, so using debian installer (d-i) and desktop media..."
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: Running install options for debian installer (d-i)..."
				{
				"${bin_virt_install}" --name ${vm_name} \
					--vcpus "${_cpu}" \
					--memory "${_mem}" \
					--network "${virt_net}" \
					--disk size="${_dsk}" \
					--os-variant="ubuntu${_tgt_ubuntu_ver::5}" \
					--video "qxl" --channel "spicevmc" \
					--location="${iso},kernel=casper/vmlinuz.efi,initrd=casper/initrd" \
					--extra-args="ks=file:/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=${Preference_InitialKeyboardLayout} \
					netcfg/get_hostname=${vm_name} console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US \
					localechooser/supported-locales=en_US.UTF-8 ubiquity/use_nonfree=true boot=casper automatic-ubiquity splash noprompt " \
					--initrd-inject="${_saveto}/preseed.cfg" \
					--initrd-inject="${_saveto}/ks.cfg" \
					--noautoconsole || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )  
				} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

			elif [[ ${_tgt_ubuntu_ver::2} -lt 23 ]] ; then

				# for interim Ubuntu builds (less than 23) use the debian installer (d-i) using DVD ISO but still PRESEED.cfg...
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: is less than 23, so using debian installer (d-i) and desktop media..."
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: Running install options for debian installer (d-i)..."
				{
				"${bin_virt_install}" --name ${vm_name} \
					--vcpus "${_cpu}" \
					--memory "${_mem}" \
					--network "${virt_net}" \
					--disk size="${_dsk}" \
					--os-variant="ubuntu${_tgt_ubuntu_ver::5}" \
					--video "virtio" --channel "spicevmc" \
					--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
					--extra-args="ks=file:/preseed.cfg auto=true priority=critical debconf/frontend=noninteractive debian-installer/locale=en_US keyboard-configuration/layoutcode=${Preference_InitialKeyboardLayout} \
					netcfg/get_hostname=RTD-VDI console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US \
					localechooser/supported-locales=en_US.UTF-8 ubiquity/use_nonfree=true boot=casper automatic-ubiquity splash noprompt " \
					--initrd-inject="${_saveto}/preseed.cfg" \
					--initrd-inject="${_saveto}/ks.cfg" \
					--noautoconsole || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )  
				} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

			elif [[ ${_tgt_ubuntu_ver::2} -ge 23 && ${_tgt_ubuntu_ver::2} -lt 24 ]] ; then

				# For interim Ubuntu builds (greater than 23 but less than 24) there is no way to automate the install.
				# Only the server media supports automation... This is not a supported version of Ubuntu.
				dialog::display_notice "🐧 Ubuntu version ${_tgt_ubuntu_ver} no longer supports Debian preseed and not yet 
				CloudCOnfig thus it is an unsupported version of Ubuntu. \n\n
				\n Please consider using a supported version instead: ${all_lts_versions[*]} \n\n"
				return 1

			elif [[ ${_tgt_ubuntu_ver::2} -ge 24 ]] ; then

				# For modern Ubuntu builds (greater than 24) use the cloud config and desktop media to build desktop...
				# However, this seems to be half baked... Hope it actually works for you...
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: Using MODERN installer..."
				system::generate_cloudconfig --CloudConfigDir "${CloudConfigDir}" --flavor ${_flavor:-"ubuntu-desktop"} 

				system::log_item "Ubuntu version ${_tgt_ubuntu_ver}: is greated than 24, so using cloud config and desktop media to build desktop..."
				{
				 "${bin_virt_install}" --name ${vm_name} \
					--vcpus "${_cpu}" \
					--memory "${_mem}" \
					--network "${virt_net}" \
					--disk size="${_dsk}" \
					--os-variant="ubuntu24.04" \
					--video "virtio" --channel "spicevmc" \
					--disk path="${CloudConfigDir}/CIDATA.iso,device=cdrom" \
					--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
					--extra-args "autoinstall" \
					--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
				} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"
			fi
		;;
		* )
				system::log_item "🐧 Ubuntu version ${_tgt_ubuntu_ver}: Using SERVER installer..."
				system::generate_cloudconfig --CloudConfigDir "${CloudConfigDir}" --flavor ubuntu-server

				: ${ubuntu_iso_url=$(system::rtd_oem_find_live_release --version ${_tgt_ubuntu_ver} --distribution ${ubuntu_flavor} --server )}
				: ${iso_filename:="$(basename $ubuntu_iso_url)"}

				# Ensure that the file is available for VM creation... 
				write_status "Checking if $iso_filename already downloaded..."
				iso=$(find "$permanent_download_dir" -name "$iso_filename")
				if [ ! -e "$iso" ]; then
					write_warning "$iso_filename is not in cache, downloading..."
					wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || { read -p "FATAL Problem: Failure to download ISO file $ubuntu_iso_url" && return 1 ; }
					iso="$permanent_download_dir/$iso_filename"
				else
					write_information "💿 - $iso_filename already in cache, using it for VM greenfield creation..."
				fi
				
				system::log_item "Ubuntu version ${_tgt_ubuntu_ver}: is greater than 23, so using cloud config and server media to build server..."
				{
				"${bin_virt_install}" --name ${vm_name} \
					--vcpus "${_cpu}" \
					--memory "${_mem}" \
					--network "${virt_net}" \
					--disk size="${_dsk}" \
					--os-variant="ubuntu21.10" \
					--video "virtio" --channel "spicevmc" \
					--disk path="${CloudConfigDir}/CIDATA.iso,device=cdrom" \
					--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
					--extra-args "autoinstall" \
					--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
				} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"
		;;
	esac

	# Clean up residual variables...
	for i in  PRESEED_FILE vm_kernel vm_initrd source_url _task _role _cpu _dsk _mem _tgt_ubuntu_ver ubuntu_iso_url iso_filename CloudConfig _summary_message ; do unset $i ; done
}










kvm::make_vm_template_now_from_microsoft() {
# Description:
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on. In the future
# scripting will be added to allow for acting on remote machines directly...
# At this time this functio takes no arguments but will prompt for what it needs if it is not available.
#
# Globals:
# Arguments: [ win11 | win10 | win8 | win7 ]
# Outputs: One VM running windows
# Returns:
# Usage: "kvm::make_vm_template_now_from_microsoft --winver target_winver"
#
#
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation

	# Check for optional default T-Shirts size overrides... 
	local _cpu _mem _dsk _saveto AutoUnattend PostTasks WindowsMedia _uefi_option _virt_net

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-4098}"}
	: ${_dsk="${_dsk:-100}"}
	: ${target_winver="${target_winver:-"win10"}"}
	: ${BIN_VIRT_INSTALL:="$(type -p virt-install)"}
	: ${CONFIG:="Workstation"}
	: ${WindowsInstructions:="/var/lib/libvirt/boot/win$(date +%Y-%m-%d-%H-%M-%S-%s).img"}
	: ${virt_net="$(system::find_vm_bridge)"}
	: ${_saveto="$( mktemp -d /tmp/WinConfig.XXXXXX )"}
	: ${AutoUnattend="${_saveto}/autounattend.xml"}
	: ${PostTasks="${_saveto}/rtd-me-sh.cmd"}
	: ${preferred_video="${5:-"qxl"}"}
	: ${RTD_GUI:="dialog"}
	: ${_TLA:="$(basename "$0" | cut -c1-3)"}

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Set specific options for Debian...
	kvm::util::read_distro_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Select the appropriate Windows ISO and UEFI boot option based on requested Windows version...
	case ${target_winver} in
		win12 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win11_English_x64.iso"} 
			: ${uefi_option="--boot uefi"} 
			;;
		win11 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win11_English_x64.iso"} 
			: ${uefi_option="--boot uefi"} 
			;;
		win10 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win10_English_x64.iso"} 
			;;
		win8 )  : ${WindowsMedia="/var/lib/libvirt/boot/Win8_English_x64.iso"}  
			;;
		win7 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win7_English_x64v1.iso"} 
			;;
	esac

	# Check for the needed ISO file and request it if not found...
	if [[ ! -e "${WindowsMedia}" ]]; then
		if ( $RTD_GUI --backtitle "..$BRANDING" --title "💿 Windows Install Media Needed" \
			--no-button "NO: Just Cancel" \
			--yes-button "OK: I am done upploading" \
			--yesno "Windows install media was not found where expected ${WindowsMedia} \n It is not possible to automatically download the media due to restrictions from Microsoft. Please place a copy of it in 📂 /home/$SUDO_USER/ and press [ OK ] \n Please name it Win**something**.iso NOTE: you can download Windows from Microsoft for free" 20 90 );
		then
			if ls /home/$SUDO_USER/Win*.iso ; then
				mv -v /home/$SUDO_USER/Win*.iso ${WindowsMedia} || rtd_oem_pause 1S
			else
				write_error "Could not find the file: /home/$SUDO_USER/Downloads/Win*.iso "
				rtd_oem_pause 1
				return
			fi
		else
			return
		fi
	fi

	if [[ ! -f "${WindowsInstructions}" ]]; then
		write_information "Generate Windows Instruction media requested..."

		# Ensure mkfs.msdos is available
		if ! hash mkfs.msdos && ! check_dependencies dosfstools; then
			write_error "Failed to install or find dosfstools. mkfs.msdos required to create the floppy disk."
			rtd_oem_pause 1 "Install will not be fully automatic: Please press [ENTER] to continue..."
		fi

		command -v mkfs.msdos > /dev/null  && \
		{
		# Create virtual floppy disk, skipp if some optional tasks above failed...
		if ! mkfs.msdos -C "${WindowsInstructions}" 1440; then
			write_error "Failed to create the virtual floppy disk..."
			rtd_oem_pause 1 "Install will not be fully automatic: Please press [ENTER] to continue..."
		fi
		}

		# Generate autounattend.xml
		write_information "Generate installations instructions for Windows ${AutoUnattend}..."
		if ! template::autounattend_xml --write "${AutoUnattend}" --winver ${target_winver} ; then
			write_error "Failed to create the autounattend.xml file..."
			rtd_oem_pause 1 "Install will not be fully automatic: Please press [ENTER] to continue..."
		fi

		# Generate rtd-me-sh.cmd
		write_information "Generate post install bootstrap script ${PostTasks}..."
		if ! template::rtd_me_sh_cmd --write "${PostTasks}"; then
			write_error "Failed to create the rtd-me-sh.cmd file..."
			rtd_oem_pause 1 "Install will not be fully automatic: Please press [ENTER] to continue..."
		fi

		# Ensure mcopy is available
		if ! hash mcopy && ! check_dependencies mtools; then
			write_warning "No mcopy found in mtools (unable to install?) to copy the post-install script to the floppy disk..."
			rtd_oem_pause 1 "Install will not be fully automatic: Please press [ENTER] to continue..."
		fi

		# Copy files to the floppy disk but skipp if some optional tasks above failed...
		command -v mcopy > /dev/null  && \
		{
		mcopy -i "${WindowsInstructions}" "${PostTasks}" ::/ || rtd_oem_pause 1 
		mcopy -i "${WindowsInstructions}" "${AutoUnattend}" ::/ || rtd_oem_pause 1 

		write_information "Copy the Windows.mod files files to the floppy disk..."
		for i in $(find /opt/${_TLA,,} -type d -name "windows.mod")/_* ; do
			if [[ -e "${i}" ]]; then
				command -v mcopy > /dev/null  && { mcopy -i "${WindowsInstructions}" "${i}" ::/ || rtd_oem_pause 1 ; }
				write_status "Copied ${i} to the floppy disk..."
			else
				write_warning "No files found in ${i} to copy to the floppy disk..."
			fi
		done
		}
	fi


	local vm_name="Template_Windows${target_winver:(-2)}_${CONFIG}_${RANDOM}"

	_summary_message="The virtual machine (${vm_name}) \n
	📋 - Using the instructions in: ${AutoUnattend} \n
	🔧 - And Using this source for the packages and files to download: \n
	🌎 - ${WindowsMedia} \n
	🌎 - ${WindowsInstructions} \n
	🌎 - ${PostTasks} \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n 
	
	NOTE: You may connecct to the VM and see the progress at IP: $(hostname -I) \n
	      After the build is complete you may reseal the VM and use it as a template for future VMs. \n"

	write_status "Creating and starting Virtual machine... "
	{
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--video ${preferred_video} \
		--os-variant="$( if osinfo-query -s -f os |grep ${target_winver} &>/dev/null ; then echo ${target_winver} ; else echo win10 ; fi )" \
		--cdrom "${WindowsMedia}" \
		--disk "${WindowsInstructions}",device=floppy \
		--livecd \
		--tpm backend.type=emulator,backend.version=2.0,model=tpm-crb  \
		${uefi_option} \
		--noautoconsole  || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 ) 
	} 2>&1 |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"

	rm -f "${PostTasks}" || system::log_item "Failed to remove ${PostTasks}..."
	for i in WindowsInstructions CONFIG WindowsMedia AutoUnattend PostTasks target_winver mem_size uefi_option cpu_count disk_size preferred_video ; do unset $i ; done
}







make_kvm_virtual_machine_now_from_iso() {
# Description: Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into Linux®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Set default values for VM T-Shirts sizes...
	kvm::util::read_common_options ${*}

	# Check that virtualization is supported on the host
	dependency::virtualization

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: "${target_iso:="/var/lib/libvirt/boot/ubuntu-21.04-desktop-amd64.iso"}"

	#Verify ISO presesnce
	if [[ ! -f "$target_iso" ]]; then
		$RTD_GUI --backtitle "${BRANDING:-"rtd"}" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
		clear
	fi

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	: ${virt_net="$(system::find_vm_bridge)"}
	_summary_message="
	The virtual machine (${vm_name}) \n
	🖥️ - Using the network: ${virt_net:=default} \n
	🖥️ - Memory: ${_mem} \n
	🖥️ - CPU's: ${_cpu} \n
	🖥️ - Disk Size: ${_dsk} \n "
	
	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Ubuntu_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${virt_net}" \
		--disk size="${4:-30}" \
		--os-variant="${1:-debian10}" \
		--cdrom="${target_iso}" \
		--livecd \
		--tpm backend.type=emulator,backend.version=2.0,model=tpm-crb  \
		--video "qxl" \
		--channel "spicevmc" || ( read -p "💥 - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
}





backup_running_vm() {
# Description:
# Function to back up all running virtual machines on the host it is being run on.
# This function should be called from within this script and does not require any
# arguments passed.
#
# Globals: ${VM_BACKUP_TARGET} (defaults to /mnt/vmdsk/VM_BACKUP)
# Arguments: None
# Outputs: Backups of running vm's.
# Returns:
# Usage:
#
# backup_running_vm
#
# End of documentation

	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=$(date +%Y-%m-%d.%H:%M:%S)
		LOG="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=$(virsh list --all | grep $DOMAIN | awk '{print $3}')
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if [[ ! -d $BACKUPFOLDER ]] ; then
				$RTD_GUI
			fi
			mkdir -p "$BACKUPFOLDER"
			TARGETS="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $3}')"
			IMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain "$DOMAIN" --name "backup-$DOMAIN" --no-metadata --atomic --disk-only "$DISKSPEC" >> "$LOG"
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > "$LOG"
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > "$LOG"
				rsync -apvz --inplace "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				else
				echo "Backup does not exist, creating a full sparse copy" > "$LOG"
				rsync -apvz --sparse "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				fi
			done

			BACKUPIMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			for TARGET in $TARGETS; do
				if virsh blockcommit "$DOMAIN" "$TARGET" --active --pivot >> "$LOG"; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > "$LOG"
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > "$LOG"
				rm -f "$BACKUP"
				fi
			done

			virsh dumpxml "$DOMAIN" > "$BACKUPFOLDER"/"$DOMAIN".xml
			echo "-----------WORKER END $DOMAIN-----------" >> "$LOG"
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> "$LOG"
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}












#                        ---
#                     -        --
#                 --( /     \ )XXXXXXXXXXXXX
#             --XXX(   O   O  )XXXXXXXXXXXXXXX-
#            /XXX(       U     )        XXXXXXX\
#          /XXXXX(              )--   XXXXXXXXXXX\
#         /XXXXX/ (      O     )   XXXXXX   \XXXXX\
#         XXXXX/   /            XXXXXX   \   \XXXXX----
#         XXXXXX  /          XXXXXX         \  ----  -
# ---     XXX  /          XXXXXX      \           ---
#   --  --  /      /\  XXXXXX            /     ---=
#     -        /    XXXXXX              '--- XXXXXX
#       --\/XXX\ XXXXXX                      /XXXXX
#         \XXXXXXXXX                        /XXXXX/
#          \XXXXXX                         /XXXXX/
#            \XXXXX--  /                -- XXXX/
#             --XXXXXXX---------------  XXXXX--
#                \XXXXXXXXXXXXXXXXXXXXXXXX-
#                  --XXXXXXXXXXXXXXXXXX-
#
###########################################################################################
#
# 8888888          888                                      888                                          
#   888            888                                      888                                          
#   888            888                                      888                                          
#   888   88888b.  888888 .d88b.  888d888 88888b.   8888b.  888                                          
#   888   888 "88b 888   d8P  Y8b 888P"   888 "88b     "88b 888                                          
#   888   888  888 888   88888888 888     888  888 .d888888 888                                          
#   888   888  888 Y88b. Y8b.     888     888  888 888  888 888                                          
# 8888888 888  888  "Y888 "Y8888  888     888  888 "Y888888 888                                          
#                                                                                                      
#                                                                                                      
#                                                                                                      
#  .d8888b.                     .d888 d8b                                   888    d8b                   
# d88P  Y88b                   d88P"  Y8P                                   888    Y8P                   
# 888    888                   888                                          888                          
# 888         .d88b.  88888b.  888888 888  .d88b.  888  888 888d888 8888b.  888888 888  .d88b.  88888b.  
# 888        d88""88b 888 "88b 888    888 d88P"88b 888  888 888P"      "88b 888    888 d88""88b 888 "88b 
# 888    888 888  888 888  888 888    888 888  888 888  888 888    .d888888 888    888 888  888 888  888 
# Y88b  d88P Y88..88P 888  888 888    888 Y88b 888 Y88b 888 888    888  888 Y88b.  888 Y88..88P 888  888 
#  "Y8888P"   "Y88P"  888  888 888    888  "Y88888  "Y88888 888    "Y888888  "Y888 888  "Y88P"  888  888 
#                                              888                                                       
#                                         Y8b d88P                                                       
#                                          "Y88P"                                                        
# 8888888b.                                     d8b 888                                                  
# 888   Y88b                                    Y8P 888                                                  
# 888    888                                        888                                                  
# 888   d88P .d88b.  88888b.   .d88b.  .d8888b  888 888888 .d88b.  888d888 888  888                      
# 8888888P" d8P  Y8b 888 "88b d88""88b 88K      888 888   d88""88b 888P"   888  888                      
# 888 T88b  88888888 888  888 888  888 "Y8888b. 888 888   888  888 888     888  888                      
# 888  T88b Y8b.     888 d88P Y88..88P      X88 888 Y88b. Y88..88P 888     Y88b 888                      
# 888   T88b "Y8888  88888P"   "Y88P"   88888P' 888  "Y888 "Y88P"  888      "Y88888                      
#                    888                                                        888                      
#                    888                                                   Y8b d88P                      
#                    888                                                    "Y88P"    
#
###########################################################################################
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.





template::preseed_cfg::early_command() {
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	# Write out the preseed file header with 'EOF' to prevent variable expansion:
	cat >> ${1} <<-'EOF'
		# --------------------------------------------------- #
		# C.4.1. Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string \
		# 	USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
		# 	BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
		# 	debconf-set partman-auto/disk $BOOTDEV;\
		# 	debconf-set grub-installer/bootdev $BOOTDEV;
                d-i partman/early_command string \
                        USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/"); \
                        BOOTDEV=$(list-devices disk | grep -v \$USBDEV | while read -r DEV; do \
                                if [ $(cat /sys/block/${DEV##*/}/queue/rotational) -eq 0 ]; then \
                                echo $DEV; break; \
                                fi; \
                        done); \
                        if [ -z "$BOOTDEV" ]; then \
                                BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1); \
                        fi; \
                        debconf-set partman-auto/disk $BOOTDEV; \
                        debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #
	EOF
}




template::preseed_cfg::main() {
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	cat >> ${1} <<-EOF

		# --------------------------------------------------- #
		# C.4.2. Unattended Installation $(date)
		# --------------------------------------------------- #
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.3. Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or DHCP.
		# The RTD default preferred config is to rely on DHCP,
		# and for wireless networks (systems with only wireless cards)
		# default to an SSID named "loader" and the guest wpa string
		# "letmein1234". This allows supported systems to be
		# installed directly over WiFi with no user input.

		# Configure network automatically if a wired connection is available
		d-i netcfg/enable boolean true
		d-i netcfg/choose_interface select auto
		d-i netcfg/dhcp_options select Configure network automatically

		# Set DHCP timeout to handle slow networks
		d-i netcfg/dhcp_timeout string 30
		d-i netcfg/link_wait_timeout string 30

		# Prompt for wireless setup if no wired connection is found
		d-i netcfg/wireless_show_essids select manual
		# d-i netcfg/wireless_essid string ${Preference_Wireless_ID}
		# d-i netcfg/wireless_essid_again string ${Preference_Wireless_ID}
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa2
		d-i netcfg/wireless_wpa string ${Preference_Wireless_Password}

		# Fallback to manual configuration if DHCP fails
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually

		# Ensure firmware is loaded for wireless cards
		d-i hw-detect/load_firmware boolean true

		# Set hostname and domain
		d-i netcfg/get_hostname string RTD-Client
		d-i netcfg/get_domain string unassigned-domain
		# --------------------------------------------------- #




		# --------------------------------------------------- #
		# C.4.4. Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string ${Preference_InitialUser}
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password ${Preference_InitialUserPassword}
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.5. Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to
		# the MUI in Microsoft environments.
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, ${Preference_InitialLanguage}.UTF-8
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.6. Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select ${Preference_InitialKeyboardLayout}
		d-i keyboard-configuration/layoutcode string ${Preference_InitialKeyboardLayout}
		d-i debian-installer/keymap select ${Preference_InitialKeyboardLayout}
		d-i keymap select ${Preference_InitialKeyboardLayout}
		d-i console-setup/layoutcode string ${Preference_InitialKeyboardLayout}
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.7. Clock and time zone setup
		# --------------------------------------------------- #
		d-i clock-setup/utc boolean true
		d-i time/zone string ${Preference_InitialTimeZone}
		d-i clock-setup/ntp boolean true
		d-i clock-setup/ntp-server string ntp.ubuntu.com

		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.8. GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it 
		# also finds some other OS, which is more likely to allow 
		# the newly installed Linux OS to boot without issue.
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.9. EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition 
		# is a partition on a data storage device. UEFI provides 
		# backward compatibility with legacy systems by reserving 
		# the first block (sector) of the partition for compatibility 
		# code, effectively creating a legacy boot sector. On 
		# legacy BIOS-based systems, the first sector of a partition 
		# is loaded into memory and execution is transferred to this 
		# code. Here we tell setup to install EFI boot setup if 
		# possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.10. Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like 
		# kde-desktop or as individual packages. Only one "pkgsel/include" 
		# string will be used though! remembder to fit all the 
		# packages you want on one line.
		#
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop,
		# lubuntu-desktop, ubuntu-mate-desktop, gnome-desktop, 
		# kde-desktop, cinnamon-desktop, mate-desktop, lxde-desktop, 
		# web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the 
		# line with a relevant chice of debian role using "sed" or similar.
		tasksel tasksel/first multiselect ${_task}
		#d-i pkgsel/include string ${_task} dialog p7zip-full 

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select none
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the system’s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you don’t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #
	EOF
}



template::preseed_cfg::auto_disk_layout() {
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	cat >> ${1} <<-EOF
		# --------------------------------------------------- #
		#   C.4.11. Disk layout (default plain non crypt disk)
		# --------------------------------------------------- #
		#
		# Set option to encrypt the hard disk:
		# By default the harddisk will not be encrypted 
		# To protect data the disk encrypted and need to be 
		# unlocked with a password when the system is booted. 
		# This configuration is controlled by the "Preference_DiskEncryption"
		# variable set in a configuration file for user preferences
		# when building VM's. See _rtd_library documentation for more.
		# For Disk layout: 
		# You can choose one of the three predefined partitioning recipes:
		# - atomic: all files in one partition
		# - home:   separate /home partition
		# - multi:  separate /home, /var, and /tmp partitions

		$( if [ "${Preference_DiskEncryption}" = "YES" ] || [ "${Preference_DiskEncryption}" = "yes" ]; then
			echo "
			d-i partman-auto/method string crypto
			d-i partman-crypto/passphrase password ${Preference_Disk_Password}
			d-i partman-crypto/passphrase-again password ${Preference_Disk_Password}
			d-i partman-auto-crypto/erase_disks boolean false
			d-i partman-lvm/confirm boolean true
			d-i partman-auto-lvm/guided_size string max
			d-i partman-auto-lvm/new_vg_name string rtd-crypt
			d-i partman-lvm/device_remove_lvm boolean true
			d-i partman-lvm/device_remove_lvm_span boolean true
			d-i partman-auto/purge_lvm_from_device boolean true
			d-i partman-md/device_remove_md boolean true
			d-i partman-md/confirm boolean true
			d-i partman-basicfilesystems/no_mount_point boolean false
			d-i partman-partitioning/confirm_write_new_label boolean true
			d-i partman/choose_partition select finish
			d-i partman/confirm boolean true
			d-i partman-auto/choose_recipe select atomic
			d-i partman/confirm_nooverwrite boolean true
			"
		else
			echo "
			# Setup a simple disk layout with all files in one partition:
			d-i partman-auto/method string regular
			d-i partman-auto/choose_recipe select atomic
			d-i partman-partitioning/confirm_write_new_label boolean true
			d-i partman/choose_partition select finish
			d-i partman/confirm boolean true
			d-i partman/confirm_nooverwrite boolean true

			# For Ubuntu:
			ubiquity partman-auto/method string regular
			ubiquity partman-lvm/device_remove_lvm boolean true
			ubiquity partman-md/device_remove_md boolean true
			ubiquity partman-auto/choose_recipe select atomic
			"
		fi )

	EOF
}



template::preseed_cfg::expert_recipe() {
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi
	
	cat >> ${1} <<-'EOF'
		d-i partman-auto/expert_recipe string                   \
		multi-cnx ::                                            \
			538 538 1075 free                               \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			3500 3500 3500 ext3                             \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
			.                                               \
			200% 25000 200% linux-swap                      \
				$lvmok{ } lv_name{ swap }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ swap } format{ }                \
			.                                               \
			500 1000 1000000000 ext4                        \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.

		# --------------------------------------------------- #
	EOF
}



template::preseed_cfg::late_command() {
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	# write out conditional elements of the preseed file:
	case $_role in
		minecraft-server | minecraft | Minecraft | MINECRAFT | minecraft_server | Minecraft-server)
			# Generate the minecraft server launcher script:
			template::minecraft_server_launcher --write "${_saveto}"/task.sh

			# Write out the preseed file:
			cat >> ${1} <<-EOF
			# --------------------------------------------------- #
			# C.4.12. Addon Tasks for Minecraft Server
			# --------------------------------------------------- #
			${_d_i_post_statment_ubunto_or_deb} \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			cp /*.cfg /target/opt/rtd/ ; cp /task.sh /home/${Preference_InitialUser}/minecraft.server ;\
			in-target echo "bash /home/${Preference_InitialUser}/minecraft.server" >> /home/${Preference_InitialUser}/.bashrc ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			reboot; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to greacefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
		kvm_server | Kvm | KVM | kvm | kvm-server )
			cat >> ${1} <<-EOF
			# --------------------------------------------------- #
			# C.4.12. Addon Tasks for KVM Server
			# --------------------------------------------------- #
			${_d_i_post_statment_ubunto_or_deb} \
			in-target apt-get -y install qemu-system libvirt-daemon-system ; \
			in-target apt-get -y install git ; \
			in-target git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to gracefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
		* )
			cat >> ${1} <<-EOF

			# --------------------------------------------------- #
			# C.4.12. Default preseed Addon Tasks
			# --------------------------------------------------- #
			# for Debian to work (ignored by Ubuntu)...
			${_d_i_post_statment_ubunto_or_deb} \
			in-target apt-get -y install git ; \
			in-target apt-get -y install ${_task} ; \
			in-target apt-get -y install dialog p7zip-full virt-what curl wget ; \
			in-target apt-get -y install spice-vdagent qemu-guest-agent ; \
			in-target apt-get -y install neofetch ; \
			in-target /bin/sh -c echo "LC_ALL=${Preference_InitialLanguage}.UTF-8" >> /etc/default/locale ; \
			in-target locale-gen en_US.UTF-8; in-target update-locale LANG=en_US.UTF-8; \
			in-target /usr/bin/git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "chown -R ${Preference_InitialUser} /home/${Preference_InitialUser}/.ssh"  ; \
			cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to gracefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
	esac
}



template::kickstart_cfg() {
	# make sure the output file is provided
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	# Generate the kickstart file
	case ${_role} in
	server )
		write_information "Selected configuration is ${_role}:${_UserServerEnvironemtSelection}"
		cat >> "${_ks_file}" <<-KS_EOF
		# Generated by: system::generate_ks_cfg_file by RTD Power Tools
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		# text
		# url --mirrorlist="${_repo_url}"
		url --url "${_repo_url}"
		firstboot --enable
		keyboard --vckeymap=${Preference_InitialKeyboardLayout:-"us"} --xlayouts="${Preference_InitialKeyboardLayout:-"us"}"
		lang en_US.UTF-8
		timezone ${Preference_InitialTimeZone:-"Etc/UTC"} --utc 
		network --onboot=yes --bootproto=dhcp
		rootpw ${Preference_InitialUserPassword} --iscrypted
		user --groups=wheel --name=tangarora --password=${Preference_InitialUserPassword} --iscrypted
		zerombr
		clearpart --all
		autopart --nohome ${Preference_DiskEncryption_RH}
		reboot

		%packages --retries 5 --timeout 20
		@server-product-environment
		@guest-agents
		openssh-server
		spice-vdagent
		git
		curl
		dialog
		yad
		neofetch
		ansible
		vim-ansible
		vim-syntastic-ansible
		${_UserServerEnvironemtSelection}
		%end

		# Post-installation Script
		%post --interpreter=/bin/bash
		git clone --depth 1 https://github.com/vonschutter/RTD-Setup.git /opt/rtd
		chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
		bash /opt/rtd/core/rtd-oem-enable-config.sh
		systemctl enable sshd
		%end
		KS_EOF
		return
	;;
	workstation )
		write_information "Selected configuration is ${_role}:${_UserDesktopEnvironmentSelection}"
		cat >> "${_ks_file}" <<-KS_EOF
		# Generated by: system::generate_ks_cfg_file by RTD Power Tools
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		graphical
		# url --mirrorlist="${_repo_url}"
		url --url "${_repo_url}"
		firstboot --disable
		keyboard --vckeymap=${Preference_InitialKeyboardLayout} --xlayouts="${Preference_InitialKeyboardLayout}"
		lang en_US.UTF-8
		timezone ${Preference_InitialTimeZone:-"Etc/UTC"} --utc 
		network --onboot=yes --bootproto=dhcp
		rootpw ${Preference_InitialUserPassword} --iscrypted
		user --groups=wheel --name=tangarora --password=${Preference_InitialUserPassword} --iscrypted
		zerombr
		clearpart --all
		autopart --nohome ${Preference_DiskEncryption_RH}
		reboot

		%packages --retries 5 --timeout 20
		${_UserDesktopEnvironmentSelection}
		@system-tools
		openssh-server
		spice-vdagent
		git
		curl
		dialog
		neofetch
		%end

		# Post-installation Script
		%post --interpreter=/bin/bash
		git clone --depth 1 https://github.com/vonschutter/RTD-Setup.git /opt/rtd
		chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
		bash /opt/rtd/core/rtd-oem-enable-config.sh
		systemctl enable sshd
		%end
		KS_EOF
		return
	;;
	* )
		write_information ": No valid OS configuration requested: 
		Valid requests are: workstation, ssh-server, ansible-server
		skipping..."
		return 1
	;;
	esac
}


template::rtd_me_sh_cmd() {
	# Template for the rtd_me.sh.cmd script
	local outfile=${2}
	write_information "Writing out the rtd_me.sh.cmd script to ${outfile}"
	
cat >> ${outfile} <<'EOF'

:INIT
	:::::::::::::::::::::::::::::::::::::::::::::::::::
	::	Script startup components; tasks that always
	::	need to be done when the initializes.
	::
        @echo off
	echo Welcome to %COMSPEC%
	echo This is a windows script!
	setlocal &  pushd %~dp0
	:: %debug%

:SETINGS
	::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::  ***             Settings               ***      ::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::

	:: gather some info...
	setlocal EnableDelayedExpansion
		set "ScriptName=%~nx0"
		set "ScriptPath=%~dp0"
		set "_tla=%ScriptName:~0,3%"
		set "lowercase=abcdefghijklmnopqrstuvwxyz"
		set "uppercase=ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		set "Result="
		for /L %%i in (0,1,2) do (
			set "char=!_tla:~%%i,1!"
			for /L %%j in (0,1,25) do (
				if "!char!"=="!lowercase:~%%j,1!" set "char=!uppercase:~%%j,1!"
			)
			set "Result=!Result!!char!"
		)
		set _TLA=%Result%
	endlocal
	::set _TLA=%Result%
	set _TLA=RTD
	set TEMP=C:\%_TLA%\temp
	set LOG_DIR=C:\%_TLA%\log
	set WALLPAPER_DIR=C:\%_TLA%\wallpaper
	set CACHE_DIR=C:\%_TLA%\cache
	set CORE_DIR=C:\%_TLA%\core
        set WALLPAPER_URL=https://raw.githubusercontent.com/vonschutter/RTD-Setup/main/wallpaper/Wayland.jpg
        set VIRTIO_URL=https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-virtio/virtio-win-0.1.240-1/virtio-win-guest-tools.exe
	set _STAGE2LOC=https://raw.githubusercontent.com/vonschutter/RTD-Setup/main/core/
	set _STAGE2FILE=rtd-oem-win10-config.ps1

	md %TEMP%
	md %LOG_DIR%
	md %WALLPAPER_DIR%
        md %CACHE_DIR%
	md %CORE_DIR%

	@title "Stage 2 file is located at: %_STAGE2LOC%\%_STAGE2FILE%"

        set >>%LOG_DIR%\%_TLA%.log
        ver >>%LOG_DIR%\%_TLA%.log
    
:GetInterestingThigsToDoOnThisSystem
	:: Given that Microsoft Windows has been detected and the CMD shell portion of this script is executed,
	:: the second stage script must be downloaded from an online location. Depending on the version of windows
	:: there are different methods available to get and run remote files. All versions of windows do not necessarily
	:: support power-shell scripting. Therefore the base of this activity is coded in simple command CMD.EXE shell scripting
	::
	:: Table of evaluating version of windows and calling the appropriate action given the version of windows found.
	:: In this case it is easier to manage a straight table than a for loop or array:

	:: DOS Based versions of Windows:
	:: ver | find "4.0" > nul && goto CMD1 	rem Windows 95
	:: ver | find "4.10" > nul && goto CMD1 rem Windows 98
	:: ver | find "4.90" > nul && goto CMD1	rem Windows ME

	:: Windows 32 and 64 Bit versions:
	ver | find "NT 4.0" > nul && call :CMD1 Windows NT 4.0
	ver | find "5.0" > nul && call :CMD1 Windows 2000
	ver | find "5.1" > nul && call :CMD1 Windows XP
	ver | find "5.2" > nul && call :CMD1 Windows XP 64 Bit
	ver | find "6.0" > nul && call :DispErr Vista is not supported!!!
	ver | find "6.1" > nul && call :PS1 Windows 7
	ver | find "6.2" > nul && call :PS2 Windows 8
	ver | find "6.3" > nul && call :PS2 Windows 8
	ver | find "6.3" > nul && call :PS2 Windows 8
	ver | find "10.0" > nul && call :PS2 Windows 10

	:: Windows Server OS Versions:
	ver | find "NT 6.2" > nul && call :PS2 Windows Server 2012
	ver | find "NT 6.3" > nul && call :PS2 Windows Server 2012 R2
	ver | find "NT 10.0" > nul && call :PS2 Windows Server 2016 and up...

	goto end


:PS1
	:: Procedure to get the second stage in Windows 7. Windows 7, by default has a different version of
	:: PowerShell installed. Therefore a slightly different syntax must be used.
	:: get stage 2 and run it...
	@title Found %* >>%LOG_DIR%\rtd.log
	echo Please wait...
	if exist A:\autounattend.xml copy /y A:\*.* %CORE_DIR%\

	@title: "Download and install virtio-drivers"
	powershell -Command "(New-Object Net.WebClient).DownloadFile('%VIRTIO_URL%', '%CACHE_DIR%\virtio-win-gt-x64.msi')"
        msiexec /i %CACHE_DIR%\virtio-win-gt-x64.msii /passive /norestart /l*v %LOG_DIR%\virtio_log.txt

        @title "Fetch Wallpaper for default background"
        powershell -Command "(New-Object Net.WebClient).DownloadFile('%WALLPAPER_URL%', '%WALLPAPER_DIR%\Default.jpg')"

	@title "Set network profiles to Private"
        powershell -Command "& {Get-ChildItem -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles' | ForEach-Object {Set-ItemProperty -Path $_.PSParentPath -Name 'Category' -Value 1}}"
 
	if exist %CORE_DIR%\%_STAGE2FILE% (
		echo File found locally...
		powershell -ExecutionPolicy UnRestricted -File %CORE_DIR%\%_STAGE2FILE%
		) else (
		echo Fetching %_STAGE2FILE% from the internet...
		powershell -Command "(New-Object Net.WebClient).DownloadFile('%_STAGE2LOC%/%_STAGE2FILE%', '%CACHE_DIR%\%_STAGE2FILE%')"
		powershell -ExecutionPolicy UnRestricted -File %CACHE_DIR%\%_STAGE2FILE%
	)

	if exist %CORE_DIR%\_Chris-Titus-Post-Windows-Install-App.ps1 (
		@title "CMD: _Chris-Titus-Post-Windows-Install-App.ps1 File found locally..."
		powershell -ExecutionPolicy UnRestricted -File %CORE_DIR%\_Chris-Titus-Post-Windows-Install-App.ps1
		) else (
		@title "CMD: Fetching _Chris-Titus-Post-Windows-Install-App.ps1 from the internet..."
		powershell -Command "iwr -useb https://raw.githubusercontent.com/ChrisTitusTech/winutil/main/winutil.ps1 | iex"
	)
	goto end


:PS2
	:: Procedure to get the second stage configuration script in all version of windows after 7.
	:: These version of windows have a more modern version of PowerShell.
	:: get stage 2 and run it...
	echo Found %*
	if exist A:\autounattend.xml copy /y A:\*.* %CORE_DIR%\
	@title "POWERSHELL: seting NETWORK Config"
        powershell -Command "& {Get-ChildItem -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles' | ForEach-Object {Set-ItemProperty -Path $_.PSParentPath -Name 'Category' -Value 1}}"

        @title "POWERSHELL: Fetch Wallpaper for default background"
        powershell -Command "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;Invoke-WebRequest %WALLPAPER_URL% -OutFile %WALLPAPER_DIR%\Default.jpg"

        @title "POWERSHELL: Download and install virtio-drivers"
        powershell -Command "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;Invoke-WebRequest %VIRTIO_URL% -OutFile %CACHE_DIR%\virtio-win-guest-tools.exe"
        %CACHE_DIR%\virtio-win-guest-tools.exe /passive /norestart /log %LOG_DIR%\virtio_log.txt
    
	if exist %CORE_DIR%\%_STAGE2FILE% (
		@title "CMD: %_STAGE2FILE%File found locally..."
		powershell -ExecutionPolicy UnRestricted -File %CORE_DIR%\%_STAGE2FILE%
		) else (
		@title "CMD: Fetching %_STAGE2FILE% from the internet..."
		powershell -Command "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;Invoke-WebRequest %_STAGE2LOC%/%_STAGE2FILE% -OutFile %CACHE_DIR%\%_STAGE2FILE%"
		powershell -ExecutionPolicy UnRestricted -File %CACHE_DIR%\%_STAGE2FILE%
	)

	if exist %CORE_DIR%\_Chris-Titus-Post-Windows-Install-App.ps1 (
		@title "CMD: _Chris-Titus-Post-Windows-Install-App.ps1 File found locally..."
		powershell -ExecutionPolicy UnRestricted -File %CORE_DIR%\_Chris-Titus-Post-Windows-Install-App.ps1
		) else (
		@title "CMD: Fetching _Chris-Titus-Post-Windows-Install-App.ps1 from the internet..."
		powershell -Command "iwr -useb https://raw.githubusercontent.com/ChrisTitusTech/winutil/main/winutil.ps1 | iex"
	)
	goto end


:CMD1
	:: Pre windows 7 instruction go here (except vista)...
	:: Windows NT, XP, and 2000 etc. do not have powershell and must find a different way to
	:: fetch a script over the internet and execute it.

	echo Detected %* ...
	echo executing PRE Windows 7 instructions...
	:: Assuming wget is in teh path...
	wget -O %TEMP%\%_STAGE2FILE% %_STAGE2LOC%/%_STAGE2FILE%
	powershell -ExecutionPolicy UnRestricted -File %TEMP%\%_STAGE2FILE%

	goto end


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::                                          ::::::::::::::::::::::
::::::::::::::            ERROR handling Below          ::::::::::::::::::::::
::::::::::::::                                          ::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



:DispErr
	set _ERRMSG=%*
	@title %0 -- !!%_ERRMSG%!!
	echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	echo ::                            Message                                          ::
	echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	echo.
	echo.
	echo        %_ERRMSG%
	echo        Presently I know what to do for Linux, and Windows 7 and beyond...
	echo.
	echo ::                                                                             ::
	echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	pause
goto end

:end
EOF
}



template::autounattend_xml() {
	# Generate the autounattend file
	system::get_vm_config
	: ${_TLA:="RTD"}

	local target_file target_winver
	while  [[ $# -gt 0 ]] ; do
		case "$1" in
			--write)
				target_file="$2"
				write_information "Requested to write out instructions to: ${target_file}"
				shift 2
			;;
			--winver )
				target_winver="$2"
				write_information "Requested to write out instructions for ${target_winver}"
				shift 2
			;;
			*)
				write_error "Incorrect sytax provided, use: ${FUNCNAME[0]} --write </path/to/filename> --winver <win10|win11|win7>"
				return 1
			;;
		esac
	done
	system::check_required_variables target_winver target_file 

	# Write out the autounattend file
	case ${target_winver} in
		win11 | Win11 )
cat >> ${target_file} <<-EOF
<?xml version="1.0" encoding="utf-8"?>
    <unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
        <settings pass="offlineServicing" />
        <settings pass="windowsPE">
        <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <SetupUILanguage>
                <UILanguage>en-US</UILanguage>
            </SetupUILanguage>
            <InputLocale>0409:00000409</InputLocale>
            <SystemLocale>en-US</SystemLocale>
            <UILanguage>en-US</UILanguage>
            <UserLocale>en-US</UserLocale>
        </component>
        <component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
        <ImageInstall>
            <OSImage>
            <InstallTo>
            <DiskID>0</DiskID>
            <PartitionID>3</PartitionID>
            </InstallTo>
            </OSImage>
        </ImageInstall>
        <UserData>
            <ProductKey>
                <Key>VK7JG-NPHTM-C97JM-9MPGT-3V66T</Key>
            </ProductKey>
            <AcceptEula>true</AcceptEula>
        </UserData>
        <RunSynchronous>
            <RunSynchronousCommand>
                <Order>1</Order>
                <Path>cmd.exe /c echo SELECT DISK=0 &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>2</Order>
                <Path>cmd.exe /c echo CLEAN &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>3</Order>
                <Path>cmd.exe /c echo CONVERT GPT &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>4</Order>
                <Path>cmd.exe /c echo CREATE PARTITION EFI SIZE=100 &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>5</Order>
                <Path>cmd.exe /c echo FORMAT QUICK FS=FAT32 LABEL="System" &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>6</Order>
                <Path>cmd.exe /c echo CREATE PARTITION MSR SIZE=16 &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>7</Order>
                <Path>cmd.exe /c echo CREATE PARTITION PRIMARY &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>8</Order>
                <Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="Windows" &gt;&gt; X:\diskpart.txt</Path>
            </RunSynchronousCommand>
            <RunSynchronousCommand>
                <Order>9</Order>
                <Path>cmd.exe /c diskpart /s X:\diskpart.txt &gt;&gt; X:\diskpart.log</Path>
            </RunSynchronousCommand>
            </RunSynchronous>
            </component>
            </settings>
            <settings pass="generalize" />
            <settings pass="specialize" />
            <settings pass="auditSystem" />
            <settings pass="auditUser" />
            <settings pass="oobeSystem">
            <component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
                <InputLocale>${Preference_InitialKeyboardLayout//_/-}</InputLocale>
                <SystemLocale>${Preference_InitialKeyboardLayout//_/-}</SystemLocale>
                <UILanguage>en-US</UILanguage>
                <UserLocale>${Preference_InitialKeyboardLayout//_/-}</UserLocale>
            </component>

            <component name="Microsoft-Windows-LUA-Settings" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                <EnableLUA>false</EnableLUA>
            </component>

            <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <UserAccounts>
                <LocalAccounts>
                <LocalAccount wcm:action="add">
                    <Name>tangarora</Name>
                    <Group>Administrators</Group>
                    <Password>
                    <Value>${Preference_Wireless_Password}</Value>
                    <PlainText>true</PlainText>
                    </Password>
                </LocalAccount>
                <LocalAccount wcm:action="add">
                    <Name>RTDUser</Name>
                    <Group>Users</Group>
                    <Password>
                    <Value>${Preference_Wireless_Password}</Value>
                    <PlainText>true</PlainText>
                    </Password>
                </LocalAccount>
                </LocalAccounts>
            </UserAccounts>

            <OOBE>
                <ProtectYourPC>3</ProtectYourPC>
                <HideEULAPage>true</HideEULAPage>
                <HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
            </OOBE>

            <AutoLogon>
                <Enabled>true</Enabled>
                <LogonCount>1</LogonCount>
                <Username>tangarora</Username>
                <Password>
                <Value>${Preference_Wireless_Password}</Value>
                <PlainText>true</PlainText>
                </Password>
            </AutoLogon>

                <FirstLogonCommands>
                    <SynchronousCommand wcm:action="add">
                        <Order>1</Order>
                        <CommandLine>reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoLogonCount /t REG_DWORD /d 0 /f</CommandLine>
                    </SynchronousCommand>
                    <SynchronousCommand wcm:action="add">
                        <Order>2</Order>
                        <CommandLine>powershell.exe -NoProfile -Command "Disable-ComputerRestore -Drive 'C:';"</CommandLine>
                    </SynchronousCommand>
                    <SynchronousCommand wcm:action="add">
                        <Order>3</Order>
                        <CommandLine>powershell.exe -NoProfile -Command "Set-ItemProperty -Path 'HKLM:\Software\Policies\Microsoft\Windows NT\Driver Signing' -Name 'BehaviorOnFailedVerify' -Value 0"</CommandLine>
                    </SynchronousCommand>
                    <SynchronousCommand wcm:action="add">
                        <Order>4</Order>
                        <CommandLine>cmd.exe /c "gpupdate /target:computer /force"</CommandLine>
                    </SynchronousCommand>
                    <SynchronousCommand wcm:action="add">
                        <Order>5</Order>
                        <CommandLine>cmd.exe /c A:\rtd-me-sh.cmd</CommandLine>
                    </SynchronousCommand>
                    <SynchronousCommand wcm:action="add">
                        <Order>6</Order>
                        <Description>Set password age policy</Description>
                        <CommandLine>cmd.exe /c net accounts /maxpwage:1</CommandLine>
                    </SynchronousCommand>
                </FirstLogonCommands>
            </component>
            </settings>
            </unattend>
EOF
		;;
		win10 | Win10 | win7 | Win7 )
cat > ${target_file} <<EOF
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
    <settings pass="offlineServicing"></settings>
    <settings pass="windowsPE">
        <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <SetupUILanguage>
                <UILanguage>en-US</UILanguage>
            </SetupUILanguage>
            <InputLocale>0409:00000409</InputLocale>
            <SystemLocale>en-US</SystemLocale>
            <UILanguage>en-US</UILanguage>
            <UserLocale>en-US</UserLocale>
        </component>
        <component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <ImageInstall>
                <OSImage>
                    <InstallTo>
                        <DiskID>0</DiskID>
                        <PartitionID>2</PartitionID>
                    </InstallTo>
                </OSImage>
            </ImageInstall>
            <UserData>
                <ProductKey>
                    <Key>DXG7C-N36C4-C4HTG-X4T3X-2YV77</Key>
                </ProductKey>
                <AcceptEula>true</AcceptEula>
            </UserData>
            <RunSynchronous>
                <RunSynchronousCommand>
                <Order>1</Order>
                <Path>cmd.exe /c echo SELECT DISK=0 &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>2</Order>
                <Path>cmd.exe /c echo CLEAN &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>3</Order>
                <Path>cmd.exe /c echo CREATE PARTITION PRIMARY SIZE=100 &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>4</Order>
                <Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="System Reserved" &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>5</Order>
                <Path>cmd.exe /c echo ACTIVE &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>6</Order>
                <Path>cmd.exe /c echo CREATE PARTITION PRIMARY &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>7</Order>
                <Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="Windows" &gt;&gt; X:\diskpart.txt</Path>
                </RunSynchronousCommand>
                <RunSynchronousCommand>
                <Order>8</Order>
                <Path>cmd.exe /c diskpart /s X:\diskpart.txt &gt;&gt; X:\diskpart.log</Path>
                </RunSynchronousCommand>
            </RunSynchronous>
        </component>
    </settings>
    <settings pass="generalize"></settings>
    <settings pass="specialize"></settings>
    <settings pass="auditSystem"></settings>
    <settings pass="auditUser"></settings>
    <settings pass="oobeSystem">
        <component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <InputLocale>${Preference_InitialKeyboardLayout//_/-}</InputLocale>
            <SystemLocale>${Preference_InitialKeyboardLayout//_/-}</SystemLocale>
            <UILanguage>en-US</UILanguage>
            <UserLocale>${Preference_InitialKeyboardLayout//_/-}</UserLocale>
        </component>
        <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
            <UserAccounts>
                <LocalAccounts>
                    <LocalAccount wcm:action="add">
                        <Name>tangarora</Name>
                        <Group>Administrators</Group>
                        <Password>
                            <Value>${Preference_Wireless_Password}</Value>
                            <PlainText>true</PlainText>
                        </Password>
                    </LocalAccount>
                    <LocalAccount wcm:action="add">
                        <Name>RTD-User</Name>
                        <Group>Users</Group>
                        <Password>
                            <Value>${Preference_Wireless_Password}</Value>
                            <PlainText>true</PlainText>
                        </Password>
                    </LocalAccount>
                </LocalAccounts>
            </UserAccounts>
            <AutoLogon>
                <Username>tangarora</Username>
                <Enabled>true</Enabled>
                <LogonCount>1</LogonCount>
                <Password>
                    <Value>${Preference_Wireless_Password}</Value>
                    <PlainText>true</PlainText>
                </Password>
            </AutoLogon>
            <OOBE>
                <HideEULAPage>true</HideEULAPage>
                <HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
                <NetworkLocation>Work</NetworkLocation>
                <ProtectYourPC>1</ProtectYourPC>
                <SkipMachineOOBE>true</SkipMachineOOBE>
                <SkipUserOOBE>true</SkipUserOOBE>
            </OOBE>
            <FirstLogonCommands>
                <SynchronousCommand wcm:action="add">
                    <Order>1</Order>
                    <CommandLine>reg.exe add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoLogonCount /t REG_DWORD /d 0 /f</CommandLine>
                </SynchronousCommand>
                <SynchronousCommand wcm:action="add">
                    <Order>2</Order>
                    <CommandLine>powershell.exe -NoProfile -Command "Disable-ComputerRestore -Drive 'C:';"</CommandLine>
                </SynchronousCommand>
                <SynchronousCommand wcm:action="add">
                    <Order>3</Order>
		    <CommandLine>powershell.exe -NoProfile -Command "Set-ItemProperty -Path 'HKLM:\Software\Policies\Microsoft\Windows NT\Driver Signing' -Name 'BehaviorOnFailedVerify' -Value 0"</CommandLine>
                </SynchronousCommand>
                <SynchronousCommand wcm:action="add">
                    <Order>4</Order>
                    <CommandLine>cmd.exe /c "gpupdate /target:computer /force"</CommandLine>
                </SynchronousCommand>
                <SynchronousCommand wcm:action="add">
                    <Order>7</Order>
                    <CommandLine>cmd.exe /c "A:\rtd-me-sh.cmd" </CommandLine>
                </SynchronousCommand>
            </FirstLogonCommands>
        </component>
    </settings>
</unattend>
EOF
		;;
		* )
			write_error "No valid Windows version provided, use: win7, win10, win11"
		;;
	esac
}



template::AutoYast_xml() {

	# make sure the output file is provided
	if [[ -z ${1} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} </path/to/filename>" ; return 1 ; } ; fi

	cat >> ${_autoyast_filename} <<-AUTOYAST_EOF
	<?xml version="1.0"?>
	<!DOCTYPE profile>
	<profile
	xmlns="http://www.suse.com/1.0/yast2ns"
	xmlns:config="http://www.suse.com/1.0/configns" >
	<general>
		<mode>
		<confirm config:type="boolean">false</confirm>
		<final_reboot config:type="boolean">true</final_reboot>
		<final_halt config:type="boolean">false</final_halt>
		<halt config:type="boolean">false</halt>
		<second_stage config:type="boolean">false</second_stage>
		<forceboot config:type="boolean">true</forceboot>
		</mode>
	</general>

	<storage>
		<proposal>
		<confirm config:type="boolean">false</confirm>
		<lvm config:type="boolean">true</lvm>
		<windows_delete_mode config:type="symbol">all</windows_delete_mode>
		<linux_delete_mode config:type="symbol">all</linux_delete_mode>
		<other_delete_mode config:type="symbol">all</other_delete_mode>
		${Preference_DiskEncryption_SUSE}
		</proposal>
	</storage>

	<networking>
		<keep_install_network config:type="boolean">true</keep_install_network>
	</networking>

	<deploy_image>
		<image_installation config:type="boolean">true</image_installation>
	</deploy_image>

	<software>
		<install_recommended config:type="boolean">true</install_recommended>
		<patterns config:type="list">
		<pattern>base</pattern>
		<pattern>${_UserDesktopEnvironmentSelection:-"kde"}</pattern>
		<pattern>${_UserServerEnvironemtSelection:-"file_server"}</pattern>
		</patterns>

		<packages config:type="list">
		<package>wget</package>
		<package>curl</package>
		<package>dialog</package>
		<package>vim</package>
		<package>spice-vdagent</package>
		<package>git</package>
		<package>pkexec</package>
		<package>zip</package>
		<package>zenity</package>
		<package>acpi</package>
		<package>pciutils</package>
		<package>jq</package>
		<package>p7zip-full</package>
		<package>xhost</package>
		</packages>

		<products config:type="list">
		<product>${_UserProductSelection:-"Leap"}</product>
		</products>

	</software>

	<firstboot>
		<firstboot_enabled config:type="boolean">false</firstboot_enabled>
	</firstboot>

	<users config:type="list">
		<user>
		<encrypted config:type="boolean">true</encrypted>
		<fullname>root</fullname>
		<gid>0</gid>
		<home>/root</home>
		<shell>/bin/bash</shell>
		<uid>0</uid>
		<user_password>${Preference_InitialUserPassword}</user_password>
		<username>root</username>
		</user>
		<user>
		<encrypted config:type="boolean">true</encrypted>
		<fullname>RTD User</fullname>
		<shell>/bin/bash</shell>
		<user_password>${Preference_InitialUserPassword}</user_password>
		<username>${Preference_InitialUser:-"tangarora"}</username>
		</user>
	</users>

	<keyboard>
		<keymap>${Preference_InitialKeyboardLayout}</keymap>
	</keyboard>

	<timezone>
		<hwclock>UTC</hwclock>
		<timezone>Europe/Berlin</timezone>
	</timezone>

	<login_settings>
		<autologin_user>${Preference_InitialUser:-"tangarora"}</autologin_user>
		<password_less_login config:type="boolean">true</password_less_login>
	</login_settings>

	<services-manager>
		<default_target>graphical</default_target>
		<services>
		<enable config:type="list">
			<service>sshd</service>
		</enable>
		</services>
	</services-manager>

	<scripts>
		<init-scripts config:type="list">
		<script>
		<source><![CDATA[
	#!/bin/bash
	git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd
	chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
	/opt/rtd/core/rtd-oem-enable-config.sh
	cp *.xml /opt/rtd/
	sudo zypper ar -cfp 90 ${_SUSE_PACKMAN_LEAP} packman
	zypper --gpg-auto-import-keys refresh
	zypper dup --from packman -y --force-resolution
	]]>
		</source>
		</script>
		</init-scripts>
	</scripts>

	<security>
		<displaymanager_remote_access>no</displaymanager_remote_access>
		<fail_delay>3</fail_delay>
		<faillog_enab>yes</faillog_enab>
		<gid_max>60000</gid_max>
		<gid_min>101</gid_min>
		<lastlog_enab>yes</lastlog_enab>
		<obscure_checks_enab>no</obscure_checks_enab>
		<permission_security>secure</permission_security>
		<run_updatedb_as>nobody</run_updatedb_as>
		<uid_max>60000</uid_max>
		<uid_min>500</uid_min>
		<selinux_mode>permissive</selinux_mode>
		<lsm_select>selinux</lsm_select>
	</security>
	</profile>

AUTOYAST_EOF
}



template::cloud_config() {

	# make sure the output file is provided
	if [[ -z ${2} ]] ; then { write_error "No output file provided, use: ${FUNCNAME[0]} --write </path/to/filename>" ; return 1 ; } ; fi

# Generate the cloud config file:

# -----------------------------------------------------------------------------------------
# Add COMMON section to the cloud config file based on preferences
# -----------------------------------------------------------------------------------------


cat >> ${2} << EOF
#cloud-config
autoinstall:
    version: 1
    shutdown: reboot
    timezone: geoip
    drivers:
        install: true
    ssh:
        allow-pw: true
        install-server: true
        authorized-keys:
            $([[ -n ${Preference_ssh_pub_key} ]] && echo - ) ${Preference_ssh_pub_key}
    keyboard:
        layout: ${Preference_InitialKeyboardLayout}
    identity:
        hostname: "${vm_name}"
        username: "${Preference_InitialUser}"
        password: "${Preference_InitialUserPassword}"
    storage:
        layout:
            name: lvm
            sizing-policy: all
            # password: "${Preference_Disk_Password}"
EOF

# -----------------------------------------------------------------------------------------
# End COMMON section to the cloud config file
# -----------------------------------------------------------------------------------------


# -----------------------------------------------------------------------------------------
# Add CUSTOM section to the cloud config file based on the role of the VM
# -----------------------------------------------------------------------------------------

case ${Preference_Role} in
ubuntu-desktop )
system::log_item "Generating cloud-config for the role: ubuntu-desktop"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - curl
        - wget
        - zip
        - p7zip-full
        - byobu
        - dialog
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - curtin in-target --target=/target -- bash -c mkdir -p /opt/rtd
        - curtin in-target --target=/target -- bash -c git clone --depth=1 ${_git_src_url} /opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
EOF
;;
kubuntu-desktop )
system::log_item "Generating cloud-config for the role: kubuntu-desktop"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
  snaps:
    - name: nvim
      channel: latest/stable
      classic: true
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
    - kubuntu-desktop
  late-commands:
    - >-
      curtin in-target --
      sed -i /etc/default/grub -e
      's/GRUB_CMDLINE_LINUX_DEFAULT=".*/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"/'
    - curtin in-target -- update-grub
    - rm /target/etc/netplan/00-installer-config*yaml
    - >-
      printf "network:\n  version: 2\n  renderer: NetworkManager" 
      > /target/etc/netplan/01-network-manager-all.yaml
    - mkdir /target/opt/rtd
    - git clone --depth=1 ${_git_src_url} /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
EOF
;;
ubuntu-server | ubuntu-server-minimal )
system::log_item "Generating cloud-config for ubuntu-server"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - curl
        - wget
        - zip
        - p7zip-full
        - byobu
        - dialog
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - git clone --depth=1 ${_git_src_url} /target/opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
EOF
;;
ssh-server )
system::log_item "Generating cloud-config for ubuntu-ssh-server"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - curl
        - wget
        - zip
        - p7zip-full
        - byobu
        - dialog
        - vim
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - git clone --depth=1 ${_git_src_url} /target/opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
EOF
;;
xubuntu-core )
system::log_item "Generating cloud-config for ${2}"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - curl
        - wget
        - zip
        - p7zip-full
        - ansible
        - byobu
        - xubuntu-core
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - git clone --depth=1 ${_git_src_url} /target/opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
EOF
;;
ansible-server )
system::log_item "Generating cloud-config for ubuntu-ssh-server"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - curl
        - wget
        - zip
        - p7zip-full
        - ansible
        - byobu
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - git clone --depth=1 ${_git_src_url} /target/opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
EOF
;;
minecraft-server )
system::log_item "Generating cloud-config for minecraft-server"
# -----------------------------------------------------------------------------------------
cat >> ${2} << EOF
    packages:
        - dialog
        - git
        - wget
        - ansible
    late-commands:
        - echo "******************* ${Preference_Role} Config ********************"
        - git clone --depth=1 ${_git_src_url} /target/opt/rtd
        - curtin in-target --target=/target -- bash -c /opt/rtd/core/rtd-oem-enable-config.sh
        - mkdir -p /target/etc/systemd/system/getty@tty1.service.d
        - touch /target/etc/systemd/system/getty@tty1.service.d/override.conf
        - echo [Service] > /target/etc/systemd/system/getty@tty1.service.d/override.conf
        - echo ExecStart=  >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
        - echo 'ExecStart=-/sbin/agetty --noissue --autologin tangarora %I \$TERM' >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
        - echo Type=idle >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
        - echo NAutoVTs=1 >> /etc/systemd/logind.conf
        - echo "Please run rtd-minecraft-server to start the Minecraft Server!" >> /target/etc/update-motd.d/00-header
        - echo rtd-minecraft-server >> /target/etc/profile
EOF
;;
* )
	system::log_item "Got: ${Preference_Role} No valid task selected, skipping late commands..."
;;
esac
# -----------------------------------------------------------------------------------------

}





template::minecraft_server_launcher() {


	case ${1} in 
		--write )
cat >> ${2} <<'EOF'
#!/bin/bash
#::             RTD System System Managment Script
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author:     RTD Library
#:: Version:	1.03
#::
#::
#:: Purpose: The purpose of the script is to perform managment tasks on Linux systems
#::
#:: This is a script that will start Minecraft Server on an Ubuntu or Debian (Ubuntu) based server. It will start
#:: multiple panes using "byobu", and start the server etc there...
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Settings                 ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Variables that govern the behavior or the script and location of files are
# set here. There should be no reason to change any of this to setup and
# get a working Minecraft server on Ubuntu. However, if you have updated scripts
# and need to download yours from someplace else you only need to change these
# setings.

# Your Minecraft version (this is a preference only), script will always
# get the latest Minecraft if it does not find a local server.
MINECRAFT_VERSION=Latest

# Your local Minecraft directory.
MINECRAFT_HOME=~/bin/minecraft.server/Minecraft.$MINECRAFT_VERSION
MINECRAFT_JAR=server.jar





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Functions                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#

function check_dependencies (){
	# Simple function to check if software is available and take action
	# if it is not. Software name must match command to envoke it.
	#---------------------------------------------------------------
	echo "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	if hash "$1" 2>/dev/null; then
		echo "I found that $1 is present on this system... thankyou for that! "
	else
		echo "You seem to have no $1... I will try to get it... "
		install_software "$1"
		if [ $? != 0 ];
		then
			echo "That install didn't work out so well."
			echo "Please manually try to add the software since I couldn't do it."
			exit
		fi
		echo "OK Done! Continuing..."
	fi
}

function install_software (){
	# Simple function to help installing software on several linux distributions
	# Should work on Fedora, SUSE, RedHat, Ubuntu, Debian etc. unless the naming
	# convention of the software package is different between distributions.
	if hash pkcon 2>/dev/null; then
		sudo pkcon -y  install "$@"
	elif hash yum 2>/dev/null; then
		sudo yum -y  install "$@"
	elif hash zypper 2>/dev/null; then
		sudo zypper install -y "$@"
	elif hash apt-get 2>/dev/null; then
		export DEBIAN_FRONTEND=noninteractive
		sudo apt-get -y -qq --allow-change-held-packages --ignore-missing install "$@"
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		_cleanup
		exit 1
	fi
}

function setup_minecraft_root (){
	# Setup and initiate the location of the mincraft server.
	# For us i likes to live in /home/$USER/bin/minecraft.server/Minecraft.$VERSION
	# This tests if the script files are available and downloades them if not.
	mkdir -p $MINECRAFT_HOME

	for i in start.sh announce.py server.properties eula.txt
	do
		if [ ! -f "$MINECRAFT_HOME/$i" ]; then
		$i $MINECRAFT_HOME
		fi
	done

	if [ ! -f "$MINECRAFT_HOME/$MINECRAFT_JAR" ]; then
		minecraft_update
	fi
}


function run_minecraft_server_manager (){

	# Start byobu multi screen app...
	byobu new-session -d -s $USER

	# status screen
	byobu rename-window -t $USER:0 'Minecraft Server Manager'
	byobu send-keys "bash $MINECRAFT_HOME/start.sh" C-m

	# Create new pane vertically and display htop
	byobu split-window -v
	byobu send-keys "htop " C-m

	# Split the "htop" window in 2, and start spedometer there.
	byobu split-window -h
	byobu send-keys "speedometer -r $NETINT  -t $NETINT" C-m

	# Create new window...
	byobu new-window -t $USER:1 -n 'Anouncing on Network (Press F4 to switch between windows)'
	byobu send-keys "python3 $MINECRAFT_HOME/announce.py" C-m

	# Set default window as the dev split plane
	byobu select-window -t $USER:0
	byobu-tmux select-pane -t 0

	# Attach to the session you just created
	byobu attach-session -t $USER
}


function check_java (){
	~/bin/java/bin/java --version >/dev/null
	if [ $? -eq 0 ]; then
		echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
	else
		echo Java is not present where expected... will now download:
		wget https://download.oracle.com/java/20/latest/jdk-20_linux-x64_bin.tar.gz
		mkdir ~/bin/java && tar xzvf jdk-20_linux-x64_bin.tar.gz --directory ~/bin/java/ --strip 1
		#check_dependencies default-jre
	fi
}


function find_active_newtork_interface (){
	# Detect the name of the active network interface.
	NETINT=$(ip addr | awk '/state UP/ {print $2}' |grep -v "br*" |grep -v "wlp*" | head --bytes -2 )
	echo "Active network interface is: $NETINT"
	export NETINT
}


function minecraft_update() {
    # Ensure the Minecraft home directory exists
    if [ ! -d "$MINECRAFT_HOME" ]; then
        echo "Minecraft directory not found: $MINECRAFT_HOME"
        exit 1
    fi

    # Download the version manifest
    VERSION_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
    VERSION_MANIFEST_FILE="$MINECRAFT_HOME/version_manifest.json"
    if ! wget -q -O "$VERSION_MANIFEST_FILE" --no-check-certificate "$VERSION_MANIFEST_URL"; then
        echo "Failed to download version manifest."
        exit 1
    fi

    # Use Python to extract the server URL from the manifest
    MC_SERVER_URL=$(python3 -c "
import json
with open('$VERSION_MANIFEST_FILE') as file:
    data = json.load(file)
    version = data['latest']['release']
    version_info = next(item for item in data['versions'] if item['id'] == version)
    print(version_info['url'])
" | xargs wget -q -O - --no-check-certificate | python3 -c "
import json, sys
data = json.load(sys.stdin)
print(data['downloads']['server']['url'])
")

    # Clean up the version manifest file
    rm "$VERSION_MANIFEST_FILE"

    # Download the latest Minecraft server jar
    UPDATED_JAR="$MINECRAFT_HOME/minecraft_server.jar.update"
    if ! wget -q -O "$UPDATED_JAR" --no-check-certificate "$MC_SERVER_URL"; then
        dialog --title 'Minecraft Update' --msgbox "Minecraft update could not be downloaded." 0 0
        exit 1
    fi

    # Compare with the existing server jar
    if [ -f "$MINECRAFT_HOME/$MINECRAFT_JAR" ] && diff "$MINECRAFT_HOME/$MINECRAFT_JAR" "$UPDATED_JAR" > /dev/null; then
        dialog --title 'Minecraft Update' --msgbox "You are already running the latest version of $MINECRAFT_JAR." 0 0
        rm "$UPDATED_JAR"
    else
        # Backup the old jar and update
        if [ -f "$MINECRAFT_HOME/$MINECRAFT_JAR" ]; then
            mv "$MINECRAFT_HOME/$MINECRAFT_JAR" "$MINECRAFT_HOME/$MINECRAFT_JAR.previous"
        fi
        mv "$UPDATED_JAR" "$MINECRAFT_HOME/$MINECRAFT_JAR"
        dialog --title 'Minecraft Update' --msgbox "Minecraft successfully updated." 0 0
    fi
}



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Script internal config repository     ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# This section contains content to written out to several configuration
# files and external scripts.


announce.py () {
	cat >> $1/announce.py <<-'EOF_PY'
#!/bin/python3
#              RTD System System Managment Script
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :: Author:     generated by minecraft.server
# :: Version 1.02
# ::
# ::
# :: Purpose: The purpose of the script is to:
# ::          1 - Broadcast service availability to the local network.
# ::              This script is used to broadcast the minecraft server on the
# ::              same machine (see "servers"). You may have as many minecraft
# ::              servers running and broadcast as you like.
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

import socket
import time
import sys
import os
import urllib.request

servers = [
["Local Network - Minecraft Server", 25565],
]

BROADCAST_IP = "255.255.255.255"
BROADCAST_PORT = 4445

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

print("Broadcasting Minecraft servers to LAN on: " + os.environ['NETINT'])
print("Local IP adress: ")
print((([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")] or [[(s.connect(("8.8.8.8", 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]]) + ["no IP found"])[0])

print("External IP address visible on the internet: ")
external_ip = urllib.request.urlopen('https://ident.me').read().decode('utf8')
print(external_ip)

while True:
for server in servers:
	msg = "[MOTD]%s[/MOTD][AD]%d[/AD]" % (server[0], server[1])
	encode = str.encode(msg)
	sock.sendto(encode, (BROADCAST_IP, BROADCAST_PORT))
time.sleep(3)
	EOF_PY
}


start.sh () {
	cat >> $1/start.sh <<-'EOF_SH'
#!/bin/bash
#::             RTD System System Managment Script
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author:     generated by minecraft.server
#:: Version 1.00
#::
#::
#:: Purpose: The purpose of the script is to:
#::          1 - Launch Minecraft
#::          2 - Check that Minecraft runs for at least one minute
#::          3 - If Minecraft crashes or quits after one minute, restart Minecraft
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

pushd $(dirname "$0")

MC_SERVER_NAME=`cat server.properties |grep "motd=.*" `
export $MC_SERVER_NAME

while true; do

start_epoch=$(date +%s)
echo Starting Minecraft server $MC_SERVER_NAME ....
~/bin/java/bin/java -Xmx2048M -Xms2048M -jar $(dirname "$0")/server.jar noggui broadcast

# Abort if the application exited too quickly
duration=$(( $(date +%s) - $start_epoch ))
if [[ "$duration" < 60 ]]; then
	echo "Program exited too quickly! Aborting Minecraft Launcher...."
	exit
fi

done

exit
EOF_SH
}


server.properties () {
	cat >> $1/server.properties <<-'EOF_CFG'
# Minecraft server properties
# generated by minecraft.server
broadcast-rcon-to-ops=true
view-distance=6
max-build-height=256
server-ip=
rcon.port=25575
level-seed=
allow-nether=true
gamemode=survival
enable-command-block=true
server-port=25565
enable-rcon=false
enable-query=true
op-permission-level=3
prevent-proxy-connections=false
generator-settings=
resource-pack=
player-idle-timeout=0
level-name=world
rcon.password=
motd=\u00A7d CuteWorld
query.port=25565
force-gamemode=true
debug=false
hardcore=false
white-list=false
broadcast-console-to-ops=true
pvp=true
spawn-npcs=true
spawn-animals=true
generate-structures=true
snooper-enabled=false
difficulty=normal
network-compression-threshold=256
level-type=default
max-tick-time=-1
spawn-monsters=true
enforce-whitelist=false
max-players=10
use-native-transport=true
spawn-protection=16
resource-pack-sha1=
online-mode=true
allow-flight=false
max-world-size=29999984
	EOF_CFG
}

eula.txt () {
	cat >> $1/eula.txt <<-'EOF_ULA'
#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://account.mojang.com/documents/minecraft_eula).
#Sun Feb 26 16:57:58 CET 2017
eula=true
	EOF_ULA
}

}

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Executive                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


# Check that the software components of this script are available.
# iff they are not, attempt to install them.
for i in byobu speedometer htop python3 dialog
do
	check_dependencies $i
done

if echo "$@" | grep "update" ;then
	dialog --title "Update to latest Minecraft?"  --yesno "You have requested that I try to get the latest verion of Minecraft from Mojang. This means that the people playing in the server also will need the latest version. Is this OK?" 0 0
		case $? in
		0)
		minecraft_update ;;
		1)
		echo "Proceeding without update...";;
		255)
		echo "ESC pressed.";;
		esac
fi

# Basic check to see that the Minecraft folder is present and
# if not crate it and download the scripts and the server jar file
# to enable the server.
setup_minecraft_root
check_java

# Start the server and monitor the server performance
find_active_newtork_interface
run_minecraft_server_manager

EOF
	;;
	* )
		{ write_error "No output file provided, use: ${FUNCNAME[0]} --write </path/to/filename>" ; return 1 ; }
	;;
	esac

}












##########################################################################################
#                 __
#               .'  '.
#              :      :
#              | _  _ |
#           .-.|(o)(o)|.-.        _._          _._
#          ( ( | .--. | ) )     .',_ '.      .' _,'.
#           '-/ (    ) \-'     / /' `\ \ __ / /' `\ \
#            /   '--'   \     / /     \.'  './     \ \
#            \ `"===="` /     `-`     : _  _ :      `-`
#             `\      /'              |(o)(o)|
#               `\  /'                |      |
#               /`-.-`\_             /        \
#         _..:;\._/V\_./:;.._       /   .--.   \
#       .'/;:;:;\ /^\ /:;:;:\'.     |  (    )  |
#      / /;:;:;:;\| |/:;:;:;:\ \    _\  '--'  /__
#     / /;:;:;:;:;\_/:;:;:;:;:\ \ .'  '-.__.-'   `-.

##########################################################################################
#  .d8888b.                   d8b          888                             
# d88P  Y88b                  Y8P          888                             
# Y88b.                                    888                             
#  "Y888b.    .d8888b 888d888 888 88888b.  888888                          
#     "Y88b. d88P"    888P"   888 888 "88b 888                             
#       "888 888      888     888 888  888 888                             
# Y88b  d88P Y88b.    888     888 888 d88P Y88b.                           
#  "Y8888P"   "Y8888P 888     888 88888P"   "Y888                          
#                                 888                                      
#                                 888                                      
#                                 888                                      
# 8888888          888                                      888            
#   888            888                                      888            
#   888            888                                      888            
#   888   88888b.  888888 .d88b.  888d888 88888b.   8888b.  888            
#   888   888 "88b 888   d8P  Y8b 888P"   888 "88b     "88b 888            
#   888   888  888 888   88888888 888     888  888 .d888888 888            
#   888   888  888 Y88b. Y8b.     888     888  888 888  888 888            
# 8888888 888  888  "Y888 "Y8888  888     888  888 "Y888888 888            
#                                                                        
#                                                                        
#                                                                        
# 8888888888                         888    d8b                            
# 888                                888    Y8P                            
# 888                                888                                   
# 8888888 888  888 88888b.   .d8888b 888888 888  .d88b.  88888b.  .d8888b  
# 888     888  888 888 "88b d88P"    888    888 d88""88b 888 "88b 88K      
# 888     888  888 888  888 888      888    888 888  888 888  888 "Y8888b. 
# 888     Y88b 888 888  888 Y88b.    Y88b.  888 Y88..88P 888  888      X88 
# 888      "Y88888 888  888  "Y8888P  "Y888 888  "Y88P"  888  888  88888P' 
# 
##########################################################################################









set_colors() {
# Description: Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message.
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# Usage:
#	Simply call this function by stating its name:
# 	set_colors
#
# Globals:
# Arguments: None
# Outputs: Sets usable variables: $picachu $music $chess $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# as well as: $[yellow, darkyellow, red, darkred, endcolor, green, darkgreen, blue, darkblue, cyan, darkcyan, gray, purple, darkpurple]
# Returns:
# Usage: echo -e $yellow "text to display" or echo -e $picachu
#
# "🔴  🔵 "
# The function will not return any sucess or failure codes. It will do its best and exit.
#
# Num  Colour    #define         R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1
# End of documentation

# Foreground & background colour commands: (uncomment to use)
#
# tput setab [1-7] # Set the background colour using ANSI escape
# tput setaf [1-7] # Set the foreground colour using ANSI escape
#
#
# Black        0;30     Dark Gray     1;30
# Red          0;31     Light Red     1;31
# Green        0;32     Light Green   1;32
# Brown/Orange 0;33     Yellow        1;33
# Blue         0;34     Light Blue    1;34
# Purple       0;35     Light Purple  1;35
# Cyan         0;36     Light Cyan    1;36
# Light Gray   0;37     White         1;37
#
#
# Text mode commands
#
# tput bold    # Select bold mode
# tput dim     # Select dim (half-bright) mode
# tput smul    # Enable underline mode
# tput rmul    # Disable underline mode
# tput rev     # Turn on reverse video mode
# tput smso    # Enter standout (bold) mode
# tput rmso    # Exit standout mode
#
# Cursor movement commands
#
# tput cup Y X # Move cursor to screen postion X,Y (top left is 0,0)
# tput cuf N   # Move N characters forward (right)
# tput cub N   # Move N characters back (left)
# tput cuu N   # Move N lines up
# tput ll      # Move to last line, first column (if no cup)
# tput sc      # Save the cursor position
# tput rc      # Restore the cursor position
# tput lines   # Output the number of lines of the terminal
# tput cols    # Output the number of columns of the terminal
#
# Clear and insert commands
#
# tput ech N   # Erase N characters
# tput clear   # Clear screen and move the cursor to 0,0
# tput el 1    # Clear to beginning of line
# tput el      # Clear to end of line
# tput ed      # Clear to end of screen
# tput ich N   # Insert N characters (moves rest of line forward!)
# tput il N    # Insert N lines
#
# Other commands
#
# tput sgr0    # Reset text format to the terminal's default
# tput bel     # Play a bell
#
# Reset
Color_Off='\033[0m'       # Text Reset

# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White

# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White

# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White

# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White




  	local ecode="\033["

	yellow="${ecode}1;33m"
	darkyellow="${ecode}0;33m"
	red="${ecode}1;31m"
	darkred="${ecode}0;31m"
	endcolor="${ecode}0m"
	green="${ecode}1;32m"
	darkgreen="${ecode}1;32m"
	blue="${ecode}1;34m"
	darkblue="${ecode}0;34m"
	cyan="${ecode}0;36"
	darkcyan="${ecode}0;36"
	gray="${ecode}0;37"
	purple="${ecode}1;35"
	darkpurple="${ecode}0;35"

	# Back compatability w. old scripts
	export YELLOW="$yellow"
	export RED="$red"
	export ENDCOLOR="$endcolor"
	export GREEN="$green"
	export BLUE="$blue"

	anim=(
	"${blue}•${green}•${red}•${magenta}•    "
	" ${green}•${red}•${magenta}•${blue}•   "
	"  ${red}•${magenta}•${blue}•${green}•  "
	"   ${magenta}•${blue}•${green}•${red}• "
	"    ${blue}•${green}•${red}•${magenta}•"
	)

	echo -e " 🎨 $yellow * $darkyellow * $red * $darkred * $green * $darkgreen * $blue * $darkblue * $cyan * $darkcyan * $gray * $darkgray * $purple * $darkpurple * $endcolor"
}





term::start_animation() {
# Description:
# A simple function to display and animation during a silent acton
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::start_animation "Display text"
# term::stop_animation
#
# End of documentation

	setterm -cursor off
	export ANIM_PID="0"
	PAD="---------------------------------------------------------"
	LINE=$(printf "%s %s" "${@}" "$PAD" | cut -c 1-${#PAD})
	(
	while true; do
		for i in {0..4}; do
			printf "$LINE  \r\033[2K ${anim[i]}"
			sleep 0.1
		done

		for i in {4..0}; do
			printf "\r\033[2K $LINE  ${anim[i]}"
			sleep 0.1
		done
	done
	) & 

	export ANIM_PID="${!}" 
}







term::stop_animation() {
# Description:
# A simple function to STOP display and animation during a silent acton
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::stop_animation
#
# End of documentation
	[[ -e "/proc/${ANIM_PID}" ]]  && kill -SIGPIPE "${ANIM_PID}"
	printf "${erace_line}$LINE [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n"
	unset LINE
	setterm -cursor on
}







rtd_oem_pause() {
# Description:
# A simple function to pause and wait for end user input.
# The function expects a non zero (0) argument to execute the pause
# and wait for the end user to press ENTER to continue execution.
#
# Globals:
# Arguments: 0 - !0 "[error message]"
# Outputs: Standard out
# Returns:
# Usage:  suggestion stop on execution error:
# EXPRESSION  || rtd_oem_pause 1
# or
# EXPRESSION ; rtd_oem_pause $?
#
# In both of these cases script execution will halt and wait for confirmation
# before continuing.
#
# Calling the function with no parameters will cause the function to simply continue. 
# This is useful in scripts when using with a captured return variable: $?
#
# EXPRESSION ; rtd_oem_pause $?
#
# in this case the script will continue if the EXPRESSION was successful, but will
# pause if the EXPRESSION failed.
#
# End of documentation
	ERRMSG=$@

	if [ ! $1 -eq 0 ]; then
		read -p "$ERRMSG: Press  [ ENTER ] to continue:"
	fi
}




pause_a_given_time() {
# Description:
# Simple function to pause for a given number of seconds whle showing a count down
# in seconds. If only a pause and no output is needed then it would be simpler to
# use the 'pause' built in command.
#
# Globals: OPTIND
# Arguments: -t -m -e where -t 'seconds' is mandatory.
# Outputs: STDOUT
# Returns: STDERR
# Usage: [-t <seconds> ] [-e <word> *completion message* ] [-m <word> *start message* ]
#
# EXAMPLE:
#
# pause_a_given_time -t 10 -m Waiting... -e Done!
#
# End of documentation
        local OPTIND o a
        while getopts ':t:m:e:' OPTION; do
                case "$OPTION" in
                t )
                        local _time="${OPTARG}"
                ;;
                e )
                        local _end_message="${OPTARG}"
                ;;
                m )
                        local _message="${OPTARG}"
                ;;
                ? )
                        write_host --cyan  "Usage: ${FUNCNAME[0]} [-t <seconds> ] [-e <word> *completion message* ] [-m <word> *start message* ]"
                        return 1
                ;;
                esac
        done
        unset OPTIND

        if [[ -z $_time ]] ; then
		write_error "Specifying time is required! [-t <seconds> ] Optional arguments are: [-e <word> *completion message* ] [-m <word> *start message* ]"
		return 1
	else
		write_status "$_message"
		while [ $_time -ge 1 ]; do
			echo -ne "One Moment please $_time ... \r"
			sleep 1
			_time=$[$_time-1]
		done
		echo
		write_status "$_end_message"
	fi
}





write_host() {
# Description:
# This is a simplified and consistent way to write output to the screen.
# This function will print a message to the standard out in a color specified.
# Specified colors can be colord defined in the function "set_colors"
# If no color option is specified this cunctio simply works like the echo command.
#
# Globals:
# Arguments: [color option]
# Outputs:
# Returns:
# Usage: write_host [option] [String]
#
# where [option] is a supported color:
# --yellow            Prints message in YELLOW
# --darkyellow        Prints message in DARK YELLOW
# --red               Prints message in RED
# --darkred           Prints message in DARK RED
# --endcolor          DEFAULT color as in terminal.
# --green             Prints message in GREEN
# --darkgreen         Prints message in DARK GREEN
# --blue              Prints message in BLUE
# --darkblue          Prints message in BLUE
# --cyan              Prints message in CYAN
# --darkcyan          Prints message in DARK CYAN
# --gray              Prints message in GRAY
# --purple            Prints message in PURPLE
# --darkpurple        Prints message in  DARK PURPLE
#
# NOTE: this function uses the "tput" mechanisms to set colors, and gice a convenient
# and simple uman way to access them. The target system must have "tput" aavailable.
#
#
# End of documentation
	_option=$1

	case ${_option} in
		--yellow ) color="$(tput bold; tput setaf 3)" ;;
		--darkyellow ) color="$(tput dim; tput setaf 3)" ;;
		--red ) color="$(tput bold; tput setaf 1)" ;;
		--darkred ) color="$(tput setaf 3)" ;;
		--endcolor ) color="$(tput sgr0)" ;;
		--green ) color="$(tput bold; tput setaf 2)" ;;
		--darkgreen ) color="$(tput dim; tput setaf 2)" ;;
		--blue ) color="$(tput bold; tput setaf 4)" ;;
		--darkblue ) color="$(tput dim; tput setaf 4)" ;;
		--cyan ) color="$(tput bold; tput setaf 6)" ;;
		--darkcyan ) color="$(tput dim; tput setaf 6)" ;;
		--gray ) color="$(tput dim; tput setaf 7)" ;;
		--purple ) color="$(tput bold; tput setaf 5)" ;;
		--darkpurple ) color="$(tput dim; tput setaf 5)" ;;
		*) local _text="$1" ;;
	esac
	[[ -z "${_text}" ]] && local _text="${color} 💻 $2 $(tput sgr0)"
	echo -e "${_text} "

	# Tell the loging function to log the message requested...
	system::log_item "${FUNCNAME[0]}: 💻 ${FUNCNAME[1]}: ${_text}"

}



write_error() {
# Description:
# is a simplified and consistent way to write output to the screen.
# write_error will print a message to the standard out in RED.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_error "[String]"
#
# End of documentation
	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]]; then
		if [[ -n "${text}" ]]; then
			echo "💥 ${FUNCNAME[1]}: ${text}"
		fi
	else
		if [[ -n "${text}" ]]; then
			echo -e "$(tput bold; tput setaf 1)💥 ${FUNCNAME[1]}: ${text}$(tput sgr0)"
		fi
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "${FUNCNAME[0]}: 💥 ${FUNCNAME[1]}: ${text}"

}


write_warning() {
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_warning will print a message to the standard out in Yellow.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_warning "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]]; then
		[ -n "${text}" ] && echo "⚠ ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "$(tput bold; tput setaf 3)⚠  ${FUNCNAME[1]}: ${text}$(tput sgr0)"
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "${FUNCNAME[0]}: ⚠ ${FUNCNAME[1]}: ${text}"
	
}


write_status() {
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_status will print a message to the standard out in GREEN.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_status "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]] ; then
		[ -n "${text}" ] && echo "✓ ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "$(tput bold; tput setaf 2)✓ ${FUNCNAME[1]}: ${text}$(tput sgr0)"
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "${FUNCNAME[0]}: ✓ ${FUNCNAME[1]}: ${text}"
	
}


write_information() {
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_information will print a message to the standard out in BLUE.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_information "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]] ; then
		[ -n "${text}" ] && echo -e "ℹ ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "$(tput bold; tput setaf 4)ℹ ${FUNCNAME[1]}: ${text}$(tput sgr0)"
	fi

	# Tell the loging function to log the message requested...
	system::log_item "${FUNCNAME[0]}: ℹ ${FUNCNAME[1]}: ${text}"
	
}





list_loaded_internal_functions() {
# Description: Function to list all internal library functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--zformat]
# Outputs: Standard out, list of functions either formatted for zenity or not. Output may be used to populate a zenity menu or dialog.
# Returns:
# Usage: list_loaded_software_functions [] [--zformat]
# End of documentation

	if [[ "$1" == "--zformat" ]]; then
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			Description=$( head -200 $0 |grep "${index}" | head -1 |cut -f2 -d';' )
			echo -e "$i \n ${index} \n ${Description} \n"
			((i=i+1))
		done
	elif [[ "${1}" == "--make-doc" ]] ; then
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			Description=$( head -300 $0 |grep "${index}" | head -1 |cut -f2 -d';' )
			printf "%-5s %-50s ; %s\n" "${i}" "${index}" "${Description}"
			((i=i+1))
		done
	elif [[ "$1" == "--hformat" ]]; then
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			echo "#$i:	$index "
			((i=i+1))
		done
	else
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			echo "$index #$i "
			((i=i+1))
		done
	fi
}


software::list_bundles() {
# Description: Function to list all software bundles defined in _rtd_recipes that are either installable or removable.
# Globals:
# Arguments: none or [--zformat]
# Outputs: Standard out, list of functions either formatted for zenity or not. Output may be used to populate a zenity menu or dialog.
# Returns:
# Usage: software::list_bundles [] [--zformat-installable | --zformat-removable]
# End of documentation

	if [[ ! -f ${completed_bundles_list} ]] ; then
		mkdir -p ${completed_bundles_list%/*}
		touch ${completed_bundles_list}
	fi

	case "$1" in
		--zformat-installable )
			# List software bundles for use with zenity
			for _bundle in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_" |grep -v "Single_Install" )
			do
				# Build each line to be displayed in the bundle installer...
				Description=$(grep -A 1 "$_bundle ()" "${_OEM_DIR}/core/${_rtd_recipies_info}" |tail -1)
				Description="${Description/"# "/": "}"
				Description="${Description/"	"/""}"
				cat ${completed_bundles_list} |grep "${_bundle/recipe_Bundle:_/}" &>/dev/null || echo -en "true \n ${_bundle/recipe_Bundle:_/} \n ${Description} \n"
			done
		;;
		--zformat-removable )
			# List software bundles for use with zenity
			completed_bundles_list="$(cat ${completed_bundles_list} )"
			for _installed_bundle in ${completed_bundles_list} ; do
				# Build each line to be displayed in the bundle installer...
				Description=$(grep -A 1 "recipe_Bundle:_$_installed_bundle ()" "${_OEM_DIR}/core/${_rtd_recipies_info}" |tail -1)
				Description="${Description/"# "/": "}"
				Description="${Description/"	"/""}"
				echo -e "true \n ${_installed_bundle} \n ${Description} \n"
			done
		;;
		* )
			# Default list format
			i=1
			for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_" |grep -v "Single_Install" )
			do
				echo "$index #$i"
				((i=i+1))
			done
		;;
	esac
}


list_loaded_software_functions() {
# Description: Function to list all software (_rtd_recipes) functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--nonum]
# Outputs: Standard out, list of functions either numerated or not.
# Returns:
# Usage: list_loaded_software_functions [] [--nonum]
# End of documentation

	if [[ "$1" == "--nonum" ]]; then
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo false ${index/recipe_/}
		done
	else
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo "$i	${index/recipe_/}"
			((i=i+1))
		done
	fi
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Executive                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# The following section launches the internal functions if given arguments
# request this. If no arguments are provided, then all the functions in this
# library will simply be loaded in to memory.

# Load base color sheme for use in the library...
#set_colors

# If $LOGFILE is not set, then set it to a default location...
if [[ -z $_LOGFILE ]] ; then
	# Set log location and name...
	if [[ $EUID -ne 0 ]]; then
		: ${_LOG_DIR:="${HOME}/.config/${_RTD:-"rtd"}/logs"}
		mkdir -p ${_LOG_DIR}
	else
		: ${_LOG_DIR:="/var/log/${_RTD:-"rtd"}"}
		mkdir -p ${_LOG_DIR}
	fi

	# Set the log file to be used by the library...
	: ${_SCRIPTNAME:=$(basename "${BASH_SOURCE[0]}")}
	: ${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}
	# initialize logging and provide process details...
	export _LOGFILE
fi

# Check if library is loaded from a terminal or another script (behavior may differ)...
if (return 0 2>/dev/null) ; then
	sourced=0
else
	sourced=1
	echo clear > /dev/null
fi

if [[ $sourced -eq 0  ]] ; then 
	if [[ "$(basename $0)" == "bash" ]] ; then
		write_host --cyan "Script is sourced from bash in a terminal: $0 $*"
	else
		write_host --cyan "Script is being sourced from a script: $(basename $0) : |${FUNCNAME[3]}|${FUNCNAME[2]}|${FUNCNAME[1]}|${FUNCNAME[0]}|${FUNCNAME[-1]}: $*"
	fi
else 
	write_host --yellow "Library is run directly as an executable! This does nothing by itself."
	write_host --cyan "Use (bash $0 --help) to se how to use this library."
fi

# Find and load all dependant files for this library... 
dependency::file _branding.info && system::log_item "✅ _branding.info Loaded without errors..." || system::log_item "👾 _branding.info Loaded with errors..." 
dependency::file _locations.info && system::log_item "✅ _locations.info Loaded without errors..." || system::log_item "👾 _locations.info Loaded with errors..."
dependency::file _rtd_recipies.info && system::log_item "✅ _rtd_recipies.info Loaded without errors..." || system::log_item "👾 _rtd_recipies.info Loaded with errors..."

write_host --green " 📚 RTD Power Library $RTD_VERSION loaded OK"
export RTDFUNCTIONS="${RTD_VERSION}"

# log variables for support reasons...
system::log_item "Library Loaded Variables: 
RTD Functions Version: ${RTDFUNCTIONS}
.........................................
_LOG_DIR=${_LOG_DIR}
_LOGFILE=${_LOGFILE}
_SCRIPTNAME=${_SCRIPTNAME}
.........................................
"

# Log the environment and how the library was launched...
system::log_item " ***  : $(basename ${BASH_SOURCE[0]}) loaded by $(basename "${0}") on $HOSTNAME  :  ***"
system::log_item "💻 Basic System Information: 
$(hostnamectl)"



eval_params() {
case $1 in
	--help | -? )
		clear
		set_colors
		echo -e " 📚 ${UWhite}${0##*/} ${red}::${BICyan} RunTime Data Library HELP ${endcolor}${red}${UWhite}::${endcolor}

		${blue}Usage${red}:${endcolor}
		${IYellow}source ${IGreen}${0##*/} ${endcolor}(to load the library into memory and use its functions.)
		
		${blue}Alternate usage${red}:${endcolor}
		${green}"${0##*/}" ${red} [OPTIONS]${endcolor}

		${blue}valid option are ${red}: ${endcolor}
		--help		        ${red}: ${endcolor}Show this help text
		--list [software|internal|all]
                ${blue}Where${red}:${endcolor}		
		--list software         ${red}: ${endcolor}(list) software install bundles available
		--list internal         ${red}: ${endcolor}(list) internal functions loaded
		--list internal package ${red}: ${endcolor}(list) filter by package name (requires combination with --list internal|--list all)
		--list internal make-doc${red}: ${endcolor}(list) print documentation for all functions in the library
		--list all              ${red}: ${endcolor}(list) all library functions including software

		--devhelp	        ${red}: ${endcolor}diplay script developer's help
		--devhelp-gtk	        ${red}: ${endcolor}diplay script developer's help in a GTK window
		--clean		        ${red}: ${endcolor}clean up the environment
		--version	        ${red}: ${endcolor}display version information
		--V		        ${red}: ${endcolor}display version information number only (short version)
		--envcheck	        ${red}: ${endcolor}check the environment and how library was launched
		--selfcheck	        ${red}: ${endcolor}check the library for syntax errors

		${blue}EXAMPLES${red}:${endcolor}
		${0##*/} --list internal
		${0##*/} --list internal kvm::
		${0##*/} --list all
		${0##*/} --devhelp
		${0##*/} --devhelp-gtk"
		return
	;;
	--list )
		case $2 in
		software )
			list_loaded_software_functions 
		;;
		internal )
			case $3 in
				make-doc )
				list_loaded_internal_functions --make-doc
				;;
				* )
				echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR"
				echo ".........................................."
				echo "Number	Function"
				echo ".........................................."
				list_loaded_internal_functions --hformat |grep "${3:-""}"
				;;
			esac

		;;
		all ) ( echo -e $YELLOW "Software Recipies: $ENDCOLOR" && list_loaded_software_functions && echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR" && list_loaded_internal_functions ) ;;
		* ) echo "USAGE: The --list option requires a (what option). Valid option are: software, internal, all." ;;
		esac
		return
	;;
	--devhelp )
		while true; do
			exec 3>&1
			selection=$(dialog --clear --no-collapse --backtitle "${BRANDING:-" RunTime Data : Function library : Script Development Support"}" --title "RTD Library Loaded Functions:" --menu "\n Chose a function below to see more details about the function." "${HEIGHT:-0}" "${WIDTH:-90}" "${LIST_HEIGHT:-0}" $(list_loaded_internal_functions) 2>&1 1>&3)
			exit_status=$?
			exec 3>&-

			case $exit_status in
				1) clear && echo [Cancel] && exit ;;
				255) clear && echo [ESC] && exit ;;
			esac

			case $selection in
				$selection )
					result=$(while IFS= read -r 'line'; do
						[[ "$line" == "$selection() {" ]]		&& printline="yes"
						[[ "$line" == "$selection() { " ]]		&& printline="no"
						[[ "$line" == "# End of documentation"* ]]	&& printline="no"
						[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
						[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
						[[ "$printline" == "yes" ]]			&& echo "$line" | grep -E '(^|\s*)#\s*' | sed 's/#//'
					done < $0 )
					dialog --clear --no-collapse --backtitle "${0##*/} :: RunTime Data Library HELP ::" --title "RTD Functon: $selection" --msgbox "$result" "${HEIGHT:-25}" "${WIDTH:-110}"
				;;
				* ) exit ;;
			esac
		done
		return
	;;
	--devhelp-gtk )
		while true; do
			exec 3>&1
			DisplayList=$(list_loaded_internal_functions --zformat)
			IFS_SAV=$IFS
			IFS=$(echo -en "\n\b")
			selection=$(zenity --list --modal --text="Select a function below, to see the function's documentation \n and usage:" --height="${ZHEIGHT:-600}" --width="${ZWIDTH:-1000}" --print-column=2 --column="Number" --column="Function" --column="Description" ${DisplayList} 2>/dev/null )
			exit_status=$?
			IFS=$IFS_SAV
			exec 3>&-
			case $exit_status in
				1) clear && echo [Cancel] && exit ;;
				255) clear && echo [ESC] && exit ;;
			esac

			case "$selection" in
				"$selection" )
					result=$(while IFS= read -r 'line'; do
						# if echo "$line" |grep "$selection ()" ; then printline="yes" ; fi
						[[ "$line" == "${selection/ /}()" ]]		&& printline="yes"
						[[ "$line" =~ ?"$selection ()" ]]		&& printline="yes"
						[[ "$line" == *"$selection ()"* ]]		&& printline="yes"
						[[ "$line" == "# End of documentation"* ]]	&& printline="no"
						[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
						[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
						[[ "$line" == "# End of Documentation" ]]	&& printline="no"
						[[ "$printline" == "yes" ]]			&& echo "$line" | grep -E '(^|\s*)#\s*'
					done < $0 )
					zenity --info --modal --ok-label=BACK --title "RTD Functon: $selection" --text="$result" --height="${ZHEIGHT:-600}" --width="${ZWIDTH:-1000}"
				;;
				* )
				# Trap unknown exit code...
				exit
				;;
			esac
		done
		return
	;;
	--clean )
		# Clean up the environment just in case...
		for var in $(compgen -v | grep '^_'); do
			unset "$var"
		done
		write_host --cyan "Environment cleaned up!"
		return 0
	;;
	--version )
		write_host --cyan "RTD Library Version: $RTD_VERSION"
		return 0
	;;
	--envcheck )
		# Check if the library is loaded from a terminal or another script (behavior may differ)...
		# This may be useful to log for support reasons.
		if [[ $sourced -eq 0  ]] ; then 
			if [[ "$(basename $0)" == "bash" ]] ; then
				write_host --cyan "Script is sourced from bash in a terminal: $0 $*"
			else
				write_host --cyan "Script is being sourced from a script: $(basename $0) $*"
			fi
		else 
			write_host --yellow "Library is run directly as an executable! This does nothing by itself."
		fi
		return
	;;
	--selfcheck )
		write_host --cyan "Checking library syntax..."
		if dependency::command_exists "shellcheck" ; then
			if shellcheck -S error $0 ; then 
				write_host --cyan "Library sytax OK!"
			else
				write_host --red "Library has a syntax error!"
			fi
		else
			write_host --red "shellcheck command not found! Please install it to use this function."
		fi 
	;;
	--V )
		echo "$RTD_VERSION"
		return 0
	;;
	* )
		write_host --cyan "Unknown option! Please use --help for valid options."
		write_host --cyan "CALL: ${0##*/} $*"
		return 0
	;;
esac
}

# If the library is asked to do something, evaluate the parameters...
if [[ -n $1 ]] ; then
	eval_params $*
fi

