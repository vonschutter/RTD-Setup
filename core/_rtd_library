#!/bin/bash
if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi
export RTD_VERSION=2.02
<<Library_Documentation
::              R T D   F u n c t i o n   L i b r a r y
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::// Linux //:::::::
::  Author(s):    SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
::  Version:    2.01
::
::
::  Purpose:    To collect and enable the use of code snippets in other scripts.
::          To document these thoroughly so that they may be useful for learning BASH.
::  Usage:      call this file using the "source" statement in bash.
::
::  This script is shared in the hopes that
::  someone will find it useful.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---  To see options to use this library type "bash _rtd_library --help"
---  To see usefull documentation on each function in this library in a Terminal or remote ssh: "bash _rtd_library --devhelp"
---  To see usefull documentation on each function in this library in GTK (local desktop): "bash _rtd_library --devhelp-gtk"


	Functions defined in this library:

	Function Name:                  Description:
	----------------------------------------------------------------------------------------------------------------
        add_gnome3_favorite_app                         ; Adds a new favorite app to the gnome favorites bar
        backup_running_vm                               ; Backs up all running virtual machines on the local computer
        check_dependencies                              ; Checks that software requirements are met so scripts do not fail
        check_if_password_pOwned                        ; Allows user to check if an intended password is already in well known dictionaries
        check_menu_availability                         ; Checks if it is possible to display graphical menus in a terminal
        cleanup_and_finish                              ; Cleans and clears variables and temp files used by the media creations functions
        compress_all_items_here                         ; Compress all folders and files in pwd using 7z (optionally encrypt)
        compress_provided_items                         ; Compress and optionally encrypt discrete contents
        create_iso_image                                ; Creates an OS iso image
        create_iso_image_debian                         ; Creates a Debian iso image
        create_physical_media_from_iso                  ; Create physical media thumb drive from an ISO file
        create_swapfile                                 ; Create a new swapfile
        debug_list_loaded_functions                     ; Lists all loaded RTD functions in the environment
        dependency::desktop                             ; Check if you are running a given desktop (kde, gnome, xfce)
        dependency::file                                ; Find and source an external script of a any name provided
        dependency::os_linux                            ; Verify if we are running bash in a linux session
        dependency::search_local                        ; Internal function to search defined paths for a given files name...
        dependency::virtualization                      ; Check that Virtualization is supported and handle deviations
        dialog::copy_file_progress                      ; Display a progressbox in terminal while copying files from one place to another
        dialog::display_error                           ; Display a supplied string as an ERROR box for a terminal user
        dialog::display_summary_message                 ; Display all text in _summary_message with automatic/manual width
        dialog::display_cmd_output                      ; Display a command output in a dialog box
        dialog::display_notice                          ; Display a supplied string as an OK box for a terminal user
        display_result                                  ; Displays command results in a pretty terminal box
        display_software_installation_choices_gtk       ; Show software installation options defined in recipe file (external)
        display_software_installation_choices_term      ; Show software installation options defined in recipe file (external)
        enable_firewall                                 ; Will turn on UFW and add the Allow SSH rule
        ensure_admin                                    ; Elevates privileges to admin root for the whole script asks for password
        ensure_flatpak_package_managment                ; Ensure that the flatpak software management is available
        ensure_snap_package_managment                   ; Ensure that the snap software management system is installed
        err_no_menu_system_found                        ; Function to handle what to do if it is not possible to currently display menus in a terminal
        generate_autounattend_xml                       ; Creates an autounattend.xml for Windows setup
        generate_autoyast_file                          ; Generates an installation configuration file for SUSE builds.
        generate_minecraft_server_launcher              ; Creates a minecraft server launcher, w. automatic dependeny resolutions
	generate_report_disk_space_used_by_directory    ; Generate a disk usage report
	generate_rtd_me_sh_cmd                          ; Creates a rtd bootstrap script for system/software install for Windows, Linux, MAC OS, BSD etc.
	github::clone_repo_user                         ; Clone all repositories for a given user at github.com
	github::list_all_user_repositories              ; List all repositories for a given user
	InstallSoftwareFromRepo                         ; Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	io_on_notify_wait                               ; Wait for a disk change and then execute a command
	is_software_package_available                   ; Checks to see if a software package is available in a repository
	is_software_package_installed                   ; Checks to see if a software package already is installed
	kvm::make_vm_template_now_from_debian_org       ; Generate a Debian virtual machine template directly from debian.org
	kvm::make_vm_template_now_from_redhat_com       ; Generate a RedHat (or compatible) vm template to be cloned later
	kvm::make_vm_template_now_from_ubuntu_com       ; Immediately create a virtual machine from ubuntu.com
	kvm::make_vm_template_now_from_opensuse_com     ; Immediately create a virtual machine directly from oensuse.org
	list_loaded_internal_functions                  ; List all internal library functions loaded... for debugging/support purposes.
	list_loaded_software_functions                  ; List all software (_rtd_recipes) functions loaded... for debugging/support purposes.
	make_kvm_virtual_machine_now_from_fedora_org    ; Generate a Fedora virtual machine template directly from Fedora.org
	make_kvm_virtual_machine_now_from_iso           ; Make a virtual machine from a generated ISO image
	make_kvm_virtual_machine_now_from_microsoft     ; Make a virtual machine running Windows
        make_kvm_virtual_machine_now_from_opensuse_org  ; Generate an OpenSUSE virtual machine template directly from opensuse.org
	make_system_recovery_partition                  ; Build a system recovery partition
	notice_rtd_loaded                               ; Notifies a script that RTD functions are loaded
	oem::check_boot_splash_screen_enable            ; Check if the boot splash screen should be anabled
	oem::deploy_themes                              ; Deploy themes to the system supplied by OEM (see RTD-Setup/themes)
	oem::register_all_tools                         ; Register all OEM scripts so that they are accessible by terminal
	oem::register_wallpapers_for_gnome              ; Register wallpapers for Gnome (so they show up in the appearance tool)
	oem::rtd_tools_make_launchers                   ; Creates a default set of pre-defined launchers
	pause_a_given_time                              ; Pause while showing a count down in seconds
	rtd_oem_cfg_Account_Setup                       ; Generates a preseed section [Account setup] (d-i passwd string)
	rtd_oem_check_inet_access                       ; Verifies that the internet is accessible
	rtd_oem_cloud-config_ubuntu_cfg_KS_CFG_Options  ; TO DO (incomplete)
	rtd_oem_find_live_release                       ; locate and download live media for debian and ubuntu
	rtd_oem_kde_set_wallpaper                       ; Sets wallpaper in the plasma workspace
	rtd_oem_pause                                   ; Pause function; will only pause if a non zero integet is passed
	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options       ; MODULE  sets optional elements for a kickstart file normally not needed
	rtd_oem_release_upgrade                         ; Attempt to perform a release upgrade for supported systems
	rtd_oem_remove_non_western_latin_fonts          ; Remove all non-latin fonts from a distribution. for the western world these are not needed and slow the system
	rtd_oem_remove_software                         ; Removes the software title requested on all supported distributions
	rtd_oem_reseal                                  ; Reseals the system for delivery to a new user user will be asked for password and locale etc.
	rtd_oem_reset_default_environment_config        ; Removes previously configured auto-login and running of setup scripts
	rtd_oem_setup_brand_splash_screen               ; Brands splash screens on a bootable distribution install media
	rtd_oem_turn_on_gui_network_management          ; Set network managers to manage network interfaces if not set
	rtd_oem_ubuntu_auto_install_iso_builder         ; Creates automatic install media for Ubuntu
	rtd_ppa_checker                                 ; Checks PPA archives on supported distributions
	rtd_server_setup_choices_productivity           ; Builtin Server terminal productivity software install options
	rtd_server_setup_choices_services               ; Builtin Server software options
	rtd_setup_choices_for_preseed                   ; Write out a Debian pre-defined preeseed file to a location requested
	rtd_setup_choices_preseed                       ; Allows for user specified choices to be added to a preseed file
	rtd_setup_choices_server                        ; Software installation choices for servers (over remote ssh)
	rtd_setup_choices_term_fallback                 ; For server setup, displays a menu where you may chose CLI productivity software
	rtd_update_system                               ; Performs a software update/refresh on supported distributions
	rtd_wait_for_internet_availability              ; Checks that the internet is reachable and waits until it is...
	scan_for_malware                                ; Scan location for malware
	set_colors                                      ; Set colors for prompting on screen in human usable variables; '$RED', '$GEEN' etc.
	set_enable_oem_elevated_privelege               ; Set automatic privilege escalation for scripts
	set_gnome_ui_common_tweaks_for_user             ; Set common UI usability tweaks
	set_gnome_ui_corprate_crisp_tweaks_for_user     ; Set corporate/business friendly UI tweaks
	set_gnome_ui_mac_tweaks_for_user                ; Set MAC UI usability tweaks
	set_gnome_ui_moca_tweaks_for_user               ; Set eye strain friendly flat theme UI tweaks
	set_gnome_ui_tweak_no_media_error               ; Funciton to handle missing themes for gnome
	set_gnome_ui_win10_tweaks_for_user              ; Set Windows 10 UI usability tweaks
	set_install_command                             ; Determines what install command should be used to install packages from repositories
	set_oem_elevated_privilege_gui                  ; Set x-authority toallow root GUI
	software::add_software_task                     ; Wrapper function to execute a command and display pretty terminal OK or FAIL
	software::add_native_package                    ; Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	software::add_native_package_dependency         ; Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc. if not already present
	software::check_native_package_dependency       ; Checks to see if a software package already is installed
	software::display_bundle_install_choices_gtk    ; Show a menu of all installable software bundles defined in _rtd_recipes
	software::display_bundle_removal_choices_gtk    ; Show a menu of installed softwrae bundles that may be removed
	software::ensure_software_store_available       ; Ensure that the appropriate software store is available with Flatpak & Snap support
	software::ensure_restricted_codecs              ; Ensure that restricted codecs are installed
	software::from_flathub.org                      ; Install software from flathub.org
	software::from_snapcraft.io                     ; Install software from snapcraft.io automatically adjusting for classic or restricted access.
	software::is_native_package_available           ; Checks to see if a software package is available in a repository
	software::is_native_package_installed           ; Checks to see if a software package already is installed
	software::list_bundles                          ; Lists software bundles defined in _rtd_recipes
	software::native_managment_availability_check   ; Checks to see that the native software managment system is not busy
	software::package_kit::add_package              ; Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	software::package_kit::remove_package           ; Removes a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	software::remove_native_software_package        ; Removes a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	software::update_all_ui                         ; Updates all software on the system using the native package manager, snap and flatpak
	software::update_system_txt                     ; Updates all software on the system using the native package manager, snap and flatpak with no UI
	software::vendor_download_and_install           ; Downloads and installs a package from the internet
	SoftwareManagmentAvailabilityCHK                ; Checks to see that the software managment system is not busy
	system_config::tune_system_power_profile        ; Tune the system power profile based on detected Laptop or PC or VM
	system::change_disk_pass                        ; Allows user to change password of the system partition encrypted disk
	system::create_physical_media_from_ubuntu_iso   ; Create physical media thumb drive from an Ubuntu ISO file
	system::display_spinner                         ; Display a spinner in the terminal
        system::download_and_manipulate_iso_debian      ; Download and modify a debian iso to automatically install OEM addons
	system::find_download_ubuntu_iso                ; Find and download an Ubuntu ISO file
	system::find_vm_bridge                          ; Echo back the name of the bridge device and if one is not found then echo default (nat)
	system::generate_cloudconfig                    ; Function to generate a cloud config file for use in deploying servers
	system::generate_ks_cfg_file                    ; Creates a kickstart file for fedora
	system::get_Windows_Product_Key                 ; Retrieves a Microsoft Windows product key if it is stored in BIOS (common for OEM)
        system::get_vm_config                           ; Get the configuration for a virtual machine
	system::log_item                                ; Log an item to the log file prefferring '$_LOGFILE' if it is defined
	system::make_preseed_cfg                        ; Generate a debian + derivatives preseed file for fully automated installs
	system::oem_autounlock_disk                     ; To DO (Incomplete) to setup automatic unloc of system disk... maybe using TPM
	system::process_vm_opt_args                     ; Process optional arguments for virtual machine creation
        system::prepare_environment_for_iso_creation    ; Prepare the environment for ISO creation
        system::read_config                             ; Read the configuration for a virtual machine
        system::update_config                           ; Update the configuration for a virtual machine
	system::remove_old_kernel                       ; Removes all old linux kernels
	system::restart_sound                           ; Restart sound service in user session on system...
	system::run_command_in_gnome_user_session       ; Running with elevated privileges; will allow to switch back to user who started process to execute script in that environment
	term::animate_while_command                     ; Display terminal output during a silent task execution
	term::start_animation                           ; Start simple animation to let user know a silent action is currently executing
	term::stop_animation                            ; Stop simple animation to let user know a silent action is done executing
	test_iso_boot_media                             ; Test bootable media using QEMU
	toggle_oem_auto_login                           ; Toggle the auto login option for the user
	toggle_oem_run_once                             ; Toggle the oem run once of a script at login
	up_2_date                                       ; Older universal software update function
	yad::display_cmd_output                         ; Display a command output in a progress box
	write_error                                     ; Prints an error message to terminal in RED
	write_host                                      ; Prints a message to the terminal w. a choice of color
	write_information                               ; Prints a message to the terminal in BLUE
	write_status                                    ; Prints a message to the terminal in GREEN
	write_warning                                   ; Prints a message to the terminal in YELLOW
	zenity::display_info                            ; Displays any string passed in a GUI information box
	zenity::display_url                             ; Display the contents of a URL passed to the function in a box
	zenity::display_file                            ; Display the contents of a file passed to the function in a box



Use Google Coding standards:
In general any function that is not both obvious and short must be commented. Any function in a library must be commented regardless of
length or complexity. It should be possible for someone else to learn how to use your program or to use a function in your library
by reading the comments (and self-help, if provided) without reading the code.

All function comments should describe the intended API behaviour using:

1	Description of the function.
2	Globals: List of global variables used and modified.
3	Arguments: Arguments taken.
4	Outputs: Output to STDOUT or STDERR.
5	Returns: Returned values other than the default exit status of the last command run.

Advice: As a "best practice" working with this file, given the size and complexities, it is better to write a new function in an external script and
use the "source" statement to include this library in said script, so that all the other functions here are available to use in the new
function.

Library_Documentation









#              .--.           .---.        .-.
#          .---|--|   .-.     | A |  .---. |~|    .--.
#       .--|===|Ch|---|_|--.__| S |--|:::| |~|-==-|==|---.
#       |%%|NT2|oc|===| |~~|%%| C |--|   |_|~|CATS|  |___|-.
#       |  |   |ah|===| |==|  | I |  |:::|=| |    |GB|---|=|
#       |  |   |ol|   |_|__|  | I |__|   | | |    |  |___| |
#       |~~|===|--|===|~|~~|%%|~~~|--|:::|=|~|----|==|---|=|
#       ^--^---'--^---^-^--^--^---'--^---^-^-^-==-^--^---^-'
###########################################################################
##                                                                       ##
##                        Library Settings                               ##
##                                                                       ##
###########################################################################
# shellcheck disable=SC1090

# Online source for scripts and configuraions
_src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"

# load branding informaton:
_OEM_dependencies="_branding _locations _rtd_recipies"

















#     |>>>                                                      |>>>
#     |                     |>>>          |>>>                  |
#     *                     |             |                     *
#    / \                    *             *                    / \
#   /___\                 _/ \           / \_                 /___\
#   [   ]                |/   \_________/   \|                [   ]
#   [ I ]                /     \       /     \                [ I ]
#   [   ]_ _ _          /       \     /       \          _ _ _[   ]
#   [   ] U U |        {#########}   {#########}        | U U [   ]
#   [   ]====/          \=======/     \=======/          \====[   ]
#   [   ]    |           |   I |_ _ _ _| I   |           |    [   ]
#   [___]    |_ _ _ _ _ _|     | U U U |     |_ _ _ _ _ _|    [___]
#   \===/  I | U U U U U |     |=======|     | U U U U U | I  \===/
#    \=/     |===========| I   | + W + |   I |===========|     \=/
#     |  I   |           |     |_______|     |           |   I  |
#     |      |           |     |||||||||     |           |      |
#     |      |           |   I ||vvvvv|| I   |           |      |
# _-_-|______|-----------|_____||     ||_____|-----------|______|-_-_
#    /________\         /______||     ||______\         /________\
#   |__________|-------|________\_____/________|-------|__________|

###########################################################################
##                                                                       ##
##                       Library Functions                               ##
##                                                                       ##
###########################################################################

# All library functions are listed below in a few sections:
# - Standard Interactions
# - System Managment
# - Software Management
# - Virtual Machine Management
# - Internal Configuration Repository
# - Script Internal Functions







#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#---------------------------------------------------------------------------------------
#
# 	. -------------------------------------------------------------------.
# 	| [Esc] [F1][F2][F3][F4][F5][F6][F7][F8][F9][F0][F10][F11][F12] o o o|
# 	|                                                                    |
# 	| [`][1][2][3][4][5][6][7][8][9][0][-][=][_<_] [I][H][U] [N][/][*][-]|
# 	| [|-][Q][W][E][R][T][Y][U][I][O][P][{][}] | | [D][E][D] [7][8][9]|+||
# 	| [CAP][A][S][D][F][G][H][J][K][L][;]['][#]|_|           [4][5][6]|_||
# 	| [^][\][Z][X][C][V][B][N][M][,][.][/] [__^__]    [^]    [1][2][3]| ||
# 	| [c]   [a][________________________][a]   [c] [<][V][>] [ 0  ][.]|_||
# 	`--------------------------------------------------------------------'
#	  ___  _                   _                _
#	 / __|| |_  __ _  _ _   __| | __ _  _ _  __| |
#	 \__ \|  _|/ _` || ' \ / _` |/ _` || '_|/ _` |
#	 |___/ \__|\__/_||_||_|\__/_|\__/_||_|  \__/_|
#
#	  ___        _                        _    _
#	 |_ _| _ _  | |_  ___  _ _  __ _  __ | |_ (_) ___  _ _   ___
#	  | | | ' \ |  _|/ -_)| '_|/ _` |/ _||  _|| |/ _ \| ' \ (_-/
#	 |___||_||_| \__|\___||_|  \__/_|\__| \__||_|\___/|_||_|/__/
#
#--------------------------------------------------------------------------------------


dialog::display_cmd_output ()
{
# Description: Function to display a command output in a dialog box. 
# 
# Globals: dialog 
# Arguments: ["String to execute"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
#
# dialog::display_cmd_output apt -y upgrade
#
# End of Documentation
	_cmd="$*"


	${_cmd} | ${RTD_GUI:-dialog} --backtitle "\Zb$PUBLICATION             $VERSION\ZB"  --progressbox "RUNNING: ${_cmd}" 25 120


}





dialog::copy_file_progress ()
{
# Description: Function to display a file copy dialog. 
# This is a simple way to show a progress bar while copying a set of files from one destination
# in a nice way. To use this function simply call it passing source and destination.
# 
# Globals: dialog 
# Arguments: ["String to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# dialog::copy_file_progress source destination
#
# Example:
# dialog::copy_file_progress "/path/to/source" "/path/to/destination"
#
# This function takes two arguments: the source directory containing the files to be copied,
# and the destination directory where the files will be copied to. It creates a progress bar
# dialog using the 'dialog' command and updates it as each file is copied. The progress bar
# shows the percentage of files copied and the name of the current file being copied.
# The function returns 0 if the copying process completes successfully, or ESC if the user
# cancels the operation.
#
# Note: The 'dialog' command must be installed for this function to work.
#
# End of Documentation
	# Source
	_dirs=(${1}/* )

	# Destination directory
	_dest="${2}"

	[ ! -d "${_dest}" ] && mkdir -p "${_dest}"

	dialog --title "Copying files" --gauge "Copying file..." 10 75 < <(
	# Get total number of files in array
	n=${#_dirs[*]}; 
	i=0

	for f in "${_dirs[@]}" ; do
		# calculate progress
		_pct=$(( 100*(++i)/n ))

		# update dialog box 
		cat <<EOF
XXX
${_pct}
Copying file "${f}"...
XXX
EOF
		# copy file $f to $_dest 
		/bin/cp "${f}" "${_dest}" &>/dev/null
	done
	)

	unset _dirs
	unset _dest
	unset _pct

}







dialog::display_notice ()
{
# Description: Function to display an information notice. The purpose of this function
# is simply to make it easy and convenient to display a message to an end user in a terminal
# in a nice way. To use this function, simply call it passing whatever string you want displayed
# using dialog.
# Globals: "${RTD_GUI}" (will default to dialog), "${PUBLICATION}" (optional)
# Arguments: ["String to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:

#
# dialog::display_notice "The message that you want to display"
#
# End of Documentation

	hash dialog &>/dev/null || check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1

	dialog --backtitle "${PUBLICATION:-"Notice"}" --colors --no-collapse --title "Notice" --msgbox "\n ${*} \n" 15 78
	clear
}




dialog::display_error ()
{
# Description: Function to display an error notice. The purpose of this function
# is simply to make it easy and convenient to display an ERROR message to an end user in a terminal
# in a nice way. To use this function, simply call it passing whatever string you want displayed
# using dialog.
# Globals: "${RTD_GUI}" (will default to dialog), "${PUBLICATION}" (optional)
# Arguments: ["String to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# dialog::display_error "The message that you want to display"
#
# End of Documentation

	hash dialog &>/dev/null || check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1

	dialog --backtitle "${PUBLICATION:-"ERROR"}" --colors --no-collapse --title "ERROR" --msgbox "\n ${*} \n" 15 78
	clear
}





dialog::display_summary_message ()
{
# Description: Function to read a variable "result" and display its contents. The purpose of this function
# is simply to make it easy and convenient to display a message to an end user in a terminal
# in a nice way. To use this function, simply call it after populating the variable result.
# 
# Globals: ${result}, ${BRANDING}
# 
# Arguments: ["Title to display"]
# 
# Outputs: Message in dialog box
# 
# Returns: 0 or ESC
# 
# Usage:
# 
# result=$( command with output)
# display_result "title of the message"
# 
# End of Documentation

	if ! hash dialog &>/dev/null ; then	
		system::log_item "dialog not found..."
		check_dependencies dialog &>/dev/null || return 1
	else
		system::log_item "dialog found..."
	fi

	system::log_item "Displaying summary message TITLE: $1 and the message: ${_summary_message}"
	if echo "${FUNCNAME[1]}" | grep "make_kvm_virtual_machine" ; then 
		dialog --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "\n ${_summary_message} \n" 0 0
	else 
		dialog --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "${_summary_message}" "${HEIGHT:-"20"}" "${WIDTH:-"80"}"
	fi
	clear
}




display_result ()
{
# Description: Function to read a variable "result" and display its contents. The purpose of this function
# is simply to make it easy and convenient to display a message to an end user in a terminal
# in a nice way. To use this function, simply call it after populating the variable result.
# Globals: ${result}, ${BRANDING}
# Arguments: ["Title to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# result=$( command with output)
# display_result "title of the message"
#
# End of Documentation
	system::log_item "checking for dialog..."
	if ! hash "${RTD_GUI:-dialog}" &>/dev/null ; then
		system::log_item "${RTD_GUI:-dialog} not found..."
		check_dependencies "${RTD_GUI:-dialog}" &>/dev/null || return 1
	else
		system::log_item "${RTD_GUI:-dialog} found..."
	fi

	system::log_item "Displaying result: $1 "
	${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "$result" "${HEIGHT:-"20"}" "${WIDTH:-"80"}"
	clear
}






yad::display_cmd_output ()
{
# Description: Function to display a command output in a yad box. 
# 
# Globals: dialog 
# Arguments: ["String to execute"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# This function takes a command as an argument and executes it. The output of the command is displayed in a yad dialog box.
# Any error messages are also displayed in the dialog box.
# The function returns 0 if the command execution is successful or if the dialog box is closed with the "Close" button.
# If the dialog box is closed with the "ESC" key, the function returns "ESC".
#
# Example usage:
# yad::display_cmd_output "apt -y upgrade"
#
# End of Documentation
	# Command to execute
	local cmd=$@

	# Execute the command and pipe its output to yad
	( 
		# Ensure any error messages are sent to standard output so yad can display them
		exec 2>&1 
		
		# Execute the command
		echo "Executing: $cmd"
		$cmd
		
		echo "Command completed. You can close this window."
	) | yad --text-info --width=700 --height=400 --title "Command Output"
}




yad::display_progressbar_pulsating ()
{
# Description: Function to display a command output in a progress box. 
# 
# Globals: yad 
# Arguments: ["String to execute"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# This function takes a command as an argument and executes it. The command output is displayed in a progress box using the 'yad' command.
# The progress box shows a pulsating animatsystem::prepare_environment_for_iso_creationion and automatically closes when the command execution is complete.
#
# Example usage:
# yad::display_cmd_output "apt -y upgrade"
#
# End of Documentation
	_cmd="$*"


	${_cmd} | yad --title="$PUBLICATION $VERSION" --progress --pulsate --auto-close --auto-kill --text="RUNNING: ${_cmd}" --width=300 --height=100

}





zenity::display_info ()
{
# Description: Function to display an information notice.
# The purpose of this function is to make it easy and convenient to display a message to an end user in a GUI in a nice way.
# To use this function, simply call it passing whatever string you want displayed.
#
# Globals: "$_TITLE" (optional), "$selection" (optional)
# Arguments: ["String to display"]
# Outputs: Message in zenity info box
# Returns: None
# Usage: zenity::display_info "The message that you want to display"
#
# End of Documentation

	_text="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --info --text --title="${_TITLE:="Notice"}: $selection" --text="$_text" --ellipsize --height=600 --width=800 2>/dev/null
}






zenity::display_url ()
{
# Description: to display the content of a URL in a GUI using zenity.
# This function makes it easy and convenient to display web content to an end user in a nice way.
# To use this function, simply call it passing the URL as an argument.
#
# Globals: $_TITLE (optional)
# Arguments: ["URL"]
# Outputs: Formatted HTML message in a zenity window
# Returns: None
# Usage:
#
# zenity::display_url "https://www.someplace.com/index.html"
#
# End of Documentation

	_url="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --text-info --html --title="${_TITLE:="$_url"}:" --url="$_url" --width=800 --height=600 &>/dev/null
}




zenity::display_file ()
{
# Description: Function to display the content of a text file. The purpose of this function
# is simply to make it easy and convenient to display text content to an end user in a GUI
# in a nice way. To use this function simply call it passing whatever file path you need.
#
# Globals: $_TITLE (optional)
# Arguments: ["/path/to/file.txt"]
# Outputs: Message in zenity window
# Returns:
# Usage:
#
#   zenity::display_file  "/path/to/file.txt"
#
# End of Documentation

	_filename="${*}"
	hash zenity &>/dev/null || check_dependencies zenity &>/dev/null || return 1
	zenity --text-info --title="${_TITLE:="$_filename"}:" --filename="$_filename" --width=800 --height=600 &>/dev/null

}



term::animate_while_command ()
{
# Description:
# A simple function to display and animation during a silent acton.
# This is useful for uning anoter functiona that may take some time. 
# Note that this works best if the function doe not print to terminal.
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::animate_while_command ; EXPRESSION of COMMAND or FUNCTION 
# 
#
# End of documentation

	
        if [[ -z ${1} ]] ; then
		write_error "Specifying a command to wait for is required! "
		return 1
	else
		term::start_animation "${@}" ; "${@}" &>/dev/null; term::stop_animation 
	fi

}





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#              ________________________________________________
#             /                                                \
#            |    _________________________________________     |
#            |   |                                         |    |
#            |   |  user@host:\> _                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |_________________________________________|    |
#            |                                                  |
#             \_________________________________________________/
#                    \___________________________________/
#                 ___________________________________________
#              _-'    .-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.  --- `-_
#           _-'.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--.  .-.-.`-_
#        _-'.-.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-`__`. .-.-.-.`-_
#     _-'.-.-.-.-. .-----.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-----. .-.-.-.-.`-_
#  _-'.-.-.-.-.-. .---.-. .-------------------------. .-.---. .---.-.-.-.`-_
# :-------------------------------------------------------------------------:
# `---._.-------------------------------------------------------------._.---'
# ----------------------------------------------------------------
#  ____            _
# / ___| _   _ ___| |_ ___ _ __ ___
# \___ \| | | / __| __/ _ \ '_ ` _ \
#  ___) | |_| \__ \ ||  __/ | | | | |
# |____/ \__, |___/\__\___|_| |_| |_|
#        |___/
#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
# ----------------------------------------------------------------



dependency::desktop ()
{
# Description: This function simplifies identifying the currently running desktop.
#
# The main problem with checking the DESKTOP_SESSION is that it is set by the display
# manager rather than the desktop session and is subject to inconsistencies.
# For lightdm on Debian, the values come from the names of files under /usr/share/xsessions/.
# DESKTOP_SESSION reflects the desktop environment if a specific selection is made at log in,
# however the lightdm-xsession is always used the default session.
#
# GDMSESSION is another option, but seems to have a similar predicament
# (it is often the same value as DESKTOP_SESSION).
#
# XDG_CURRENT_DESKTOP looks like a good choice, however it is currently not in the XDG
# standard and thus not always implemented. See here for a discussion of this. This
# answer shows its values for different distros/desktops.
#
# The reasonable fallback for XDG_CURRENT_DESKTOP not existing would be to try
# XDG_DATA_DIRS. Provided the data files for the desktop environment are installed
# in a directory bearing its name, this approach should work. This will hopefully
# be the case for all distros/desktops!
#
# Globals:    None
# Arguments:  None
# Outputs:    Standard error 1/0
# Returns:    0 = desktop is what you are searching for. 1 = is not what you are searching for.
# Usage:      dependency::desktop gnome|kde|xfce|mate
# 
# This function checks if there is a running desktop session that matches the specified desktop environment.
# It attempts to find the currently running desktop environment reliably by checking various environment variables
# and processes. If the specified desktop environment is found, it returns 0; otherwise, it returns 1.
#
# Example usage:
#   dependency::desktop gnome   # Check if there is a running GNOME desktop session
#   dependency::desktop kde     # Check if there is a running KDE desktop session
#   dependency::desktop xfce    # Check if there is a running Xfce desktop session
#   dependency::desktop mate    # Check if there is a running MATE desktop session
#
# End of documentation
	local _sought="${1,,}"
	system::log_item "checking if there is a running $_sought desktop session..."
	local _desktop

	# Try to find the currently running desktop environment reliably...
	if [[ "$XDG_CURRENT_DESKTOP" == "" ]] ; then
		system::log_item "XDG_CURRENT_DESKTOP appears to be unset, attempting to search processes for desktop match... "
	elif  pgrep -f "plasmashell" ; then
		local _desktop="kde"
	elif  pgrep -f "gnome-shell"; then
		local _desktop="gnome"
	elif  pgrep -f "mate"; then
		local _desktop="mate"
	elif  pgrep -f "xfce"; then
		local _desktop="xfce"
	else
		local _desktop="$XDG_CURRENT_DESKTOP"
	fi

	# Check what we found...
	system::log_item "Found: _desktop=$_desktop"
	local _desktop="${_desktop,,}"
	if [[ "$_desktop" == *"$_sought"* ]]; then
		return 0
	else
		return 1
	fi
}




dependency::os_linux ()
{
# Description: This function simplifies checking if the currently OS is Linux or not. 
#  
# Globals:	None
# Arguments:	None
# Outputs:	Standard error 1/0
# Returns:	0 = Running in Linux. 1 = is not running in Linux.
# Usage: 	dependency::os_linux
# End of documentation

       	if echo "$OSTYPE" |grep -q "linux" ; then
		return 0
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported ..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported ... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported... " ; return 1
	else
		echo "I have no Idea what this OS is" ; return 1
	fi
}






dependency::file () 
{
# Description: Function to check for a bash library or script file and source it.
#
# This function searches a predetermined set of paths for a given file and sources it if found.
# It first searches for the file locally in a set of predefined paths. If the file is found, it is sourced.
# If the file is not found locally, the function attempts to download it from a specified URL and source it.
# If the download is successful, the file is sourced. If the download fails, the function logs an error and exits.
#
# Globals:
#   _GIT_PROFILE: The GitHub profile to use for downloading the file (default: vonschutter)
# Arguments:
#   Filename: The name of the file to search for and source
# Outputs:
#   None
# Returns:
#   Standard error level
# Usage:
#   dependency::file <filename>
#   Example: dependency::file _config.ini
#
# Dependencies:
#   This function depends on the following functions:
#   - system::log_item: A function to log messages
#
# End of documentation


	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"
	
	dependency::search_local () {
		# Description: Internal function!
		# It may not be useful to call this directly. This function searches 
		# a predetermined set of paths for a given file, and source it if found.
		# it is part of the function dependency::file -- use this instead.
		# End of Documentation

		system::log_item "Requested dependency file: ${1} ..."

		local paths=(
			"./${1}"
			"../core/${1}"
			"../../core/${1}"
			"${0%/*}/../core/${1}"
			"${0%/*}/../../core/${1}"
			"$(dirname "$(find /opt -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			"$(dirname "$(find ${HOME}/GIT -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			"$(dirname "$(find ${HOME}/bin -name ${1} 2>/dev/null | head -n 1 )")/${1}"
			)

		for path in "${paths[@]}"; do 
			system::log_item "Searching for ${path} ..."
			if [[ -e "${path}" ]]; then
				system::log_item "Found ${path}"
				source "${path}" ""
				return 0
			fi
		done

		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		system::log_item "$(date) failure to find $1 on the local computer, now searching online..."
		local tmpdir=$(mktemp -d)
		if curl -sL "$_src_url" -o "${tmpdir}/${1}" ; then 
			system::log_item "Using: ${_src_url} directly from URL..."
			source "${tmpdir}/${1}"
		elif wget "${_src_url}" -O "${tmpdir}/${1}" &>/dev/null ; then
			source "${tmpdir}/${1}"
			system::log_item "Using: ${_src_url} downloaded..."
		else 
			system::log_item "Failed to find  ${1} "
			exit 1
		fi
		rm -rf "${tmpdir}"
	fi 
}




# shellcheck disable=SC2120
oem::deploy_themes () {
# Description: Function to download and deploy themes from Github.
#              The github location is defined in the _locations file for consistency.
#
# Globals:
# Arguments: None
# Outputs:
# Returns: Standard error level.
# Usage: simply call function in a script, or override the default location in _locations:
#        oem::deploy_themes https://www.github.com/myuser/myrepo.git
# End of documentation

	local GIT_Theme_URL="${1:-"$GIT_Theme_URL"}"
	local _THEME_DIR="${_THEME_DIR:-"/opt/${_TLA:-rtd}/themes"}"

	if ! mkdir -p "${_THEME_DIR}"; then
		write_error "Failed to create directory ${_THEME_DIR}"
		return 1
	fi

	if [[ -z "${GIT_Theme_URL}" ]]; then
		write_error "No theme URL found! It needs to be set in the _locations file or passed as an argument."
		return 1
	fi
	
	if git clone --depth=1 "${GIT_Theme_URL}" "${_THEME_DIR}"; then
		write_status "Cloned ${GIT_Theme_URL} successfully."
	else
		write_error "An error occurred while cloning ${GIT_Theme_URL}."
		return 1
	fi
}




dependency::virtualization ()
{
# Description: Common function to check on the required components for making virtual machines. 
#
# Globals:
# Arguments: None
# Outputs:
# Returns: nothing
# Usage: simply call function in a script
# End of documentation


	write_status "${FUNCNAME[0]}: Checking for virtualization software..."
	local _os_name
	_os_name=$(hostnamectl |grep "Operating System" |cut -d' ' -f3)

	case $_os_name in
	openSUSE )
		write_status "Verrifying/Installing virtualization software for openSUSE..."
		zypper install -y --recommends -t pattern "kvm_server"  "kvm_tools" | tee -a "${_LOGFILE}"
	;;
	Tumbleweed )
		write_status "Verryfying/Installing virtualization software for Tumbleweed..."
		zypper install -y --recommends -t pattern "kvm_server"  "kvm_tools" | tee -a "${_LOGFILE}"
	;;
	Fedora ) 
		local _probable_dependencies="bridge-utils libvirt virt-install qemu-kvm virt-top libguestfs-tools guestfs-tools" 
	;;
	Debian | Ubuntu) 
		local _probable_dependencies="bridge-utils cpu-checker libvirt-clients libvirt-daemon qemu qemu-kvm virtinst" 
	;;
	* ) 
		local _probable_dependencies="bridge-utils cpu-checker libvirt-clients libvirt-daemon qemu qemu-kvm virtinst" 
	;;
	esac

	if [[ -n ${_probable_dependencies} ]] ; then
		count=1
		for i in  ${_probable_dependencies} ; do
			write_status "${count}	- Verifying dependencies if relevant( ${i} )..."
			software::check_native_package_dependency $i &>/dev/null
			count=$((count + 1))
		done
	fi
}





system::find_vm_bridge ()
{
# Description: Common function to find the default bridge network device. 
#              If there is no br/bridge we likely have a nat device "default"
# Globals:
# Arguments: None
# Outputs:
# Returns: br0 | bridge0 | default
# Usage: simply call function in a script
# End of documentation

	if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi
}




system::restart_sound ()
{
# Description: Function to check for PipeWire or Pulse Audio and attempt to restart sound.
#
# This function checks if the system has PipeWire or Pulse Audio installed. If PipeWire is 
# installed, it restarts the pipewire.service. If Pulse Audio is installed, it kills the pulseaudio 
# process and reloads the ALSA sound driver. If neither PipeWire nor Pulse Audio is found, 
# it displays an error message.
#
# Globals: None
# Arguments: None
# Outputs: None
# Returns: Standard error level.
# Usage: Simply call this function in a script.
# End of documentation

	if hash pw-cli ; then 
		systemctl --user restart pipewire.service
	elif hash pactl ; then
		pulseaudio -k && sudo alsa force-reload
	else 
		write_error "Pulse Audio or PipeWire sound software was not found..." 
	fi
}






system::remove_old_kernel ()
{
# Description: Function to remove all old linux kernels.
#
#
# Globals:
# Arguments: None
# Outputs:
# Returns: Standard error level.
# Usage: simply call function in a script
# End of documentation

        if echo "$OSTYPE" |grep -q "linux" &>/dev/null ; then
                # these tests focus on the latest versions of the distros evaluated...
		ensure_admin
                if hash apt-get &>/dev/null ; then
                        dialog::display_notice "ðŸ§© ${FUNCNAME[0]}: An apt based system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                dpkg -l linux-* | awk '/^ii/{print $2}' | grep -E "[0-9]" | sort -t- -k3,4 --version-sort -r | sed -e "1,/$(uname -r | cut -f1,2 -d"-")/d" | grep -v -e "$(uname -r | cut -f1,2 -d"-")" | xargs apt-get -y purge
                                return $?
                        else
                                return 1
                        fi
                elif hash zypper &>/dev/null ; then
                        dialog::display_notice "ðŸ§© ${FUNCNAME[0]}: An Zypper based package management system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                zypper purge-kernels
                                return $?
                        else
                                return 1
                        fi
                elif hash dnf &>/dev/null ; then
                        dialog::display_notice "ðŸ§© ${FUNCNAME[0]}: An DNF based package management system has been found... proceeding... "
                        if [[ $? -eq 0 ]] ; then
                                dnf remove "$(dnf repoquery --installonly --latest-limit 2 -q)" 
                                return $?
                        else
                                return 1
                        fi
                else
                        dialog::display_notice "${FUNCNAME[0]}: a supported package manager was not found for this action..."
                        return 1
                fi
        elif [[ "$OSTYPE" == "darwin"* ]]; then
                write_error "${FUNCNAME[0]}: Mac OSX is currently not supported!"  ; return 1
        elif [[ "$OSTYPE" == "cygwin" ]]; then
                write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported!"  ; return 1
        elif [[ "$OSTYPE" == "msys" ]]; then
                write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported! "  ; return 1
        elif [[ "$OSTYPE" == "freebsd"* ]]; then
                write_error "${FUNCNAME[0]}: Free BSD is currently unsupported! " ; return 1
        else
                echo "I have no Idea what this system is" ; return 1
        fi

}





system::change_disk_pass ()
{
# Description: Function to change the passphrase fo an encrypted storage device.
# It will offer to change the first encrypted volume found by blockid.
# It is unclear how this will work if there are multiple encrypted volumes found.
# The function does not expect an argument. It will prompt for a password.
#
# Globals:
# Arguments: None accepted
# Outputs: Interactive
# Returns: default exit status of the last command run.
# Usage: change_disk_pass
#
#
# End of Documentation

	clear
	write_host --red "Changing the disk encryption password for your hard drive:"
	cryptsetup luksChangeKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)"
	read -p "Press  [ ENTER ] to continue:"
}




system::oem_autounlock_disk ()
{
# Setup automatic unlocking of the encrypted system disk.
# NOTE: This will render the encryption useless since the key to unlock the encrypted
# volume will be located on an unencrypted location on the same system as the encrypted volume.
# This is the same as locking your door and leaving the key by the door outside.
#
# The intention behind this is to be able to complete all build activites without manual intervention
# of any kind. The intention is to remove the key file after all administrative tasks are complete.
#
# 1. Back up your initramfs disk
#
# Globals:
# Arguments: None accepted
# Outputs:
# Returns: default exit status of the last command run.
# Usage: oem_autounlock_disk
#
# End of Documentation
	local _pass="$1"
	cp  /boot/initrd.img-$(uname -r)  /boot/initrd.img-$(uname -r).bak

	cat > /boot/grub/grub.cfg <<- OEM_CRYPTLOCK_OPTION
	### BEGIN /etc/grub.d/10_linux ###

	menuentry 'Debian GNU/Linux, with Linux $(uname -r) (crypto safe)' --class debian --class gnu-linux --class gnu --class os {
		load_video
		insmod gzio
		insmod part_msdos
		insmod ext2
		set root='hd0,msdos1'
		search --no-floppy --fs-uuid --set=root 2a5e9b7f-2128-4a50-83b6-d1c285410145
		echo    'Loading Linux $(uname -r) ...'
		linux   /vmlinuz-$(uname -r) root=/dev/mapper/dradispro-root ro  quiet
		echo    'Loading initial ramdisk ...'
		initrd  /initrd.img-$(uname -r).safe
	}
	...
	## END /etc/grub.d/10_linux ###
	OEM_CRYPTLOCK_OPTION

	# 2. Create the key file in the unencrypted /boot partition
	dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4

	# 3. Set permissions
	chmod 0400 /boot/keyfile

	# 4. Add the new file as unlock key to the encrypted volume
	echo ${_pass} | cryptsetup -v luksAddKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)" /boot/keyfile -

	# 6. Edit /etc/crypttab
	chmod 0777 /etc/crypttab
	cp /etc/crypttab /etc/crypttab.temporary
	sed -i /"$(cat /etc/crypttab | cut -d " " -f 1 )"/d /etc/crypttab.temporary
	echo "$(cat /etc/crypttab | cut -d " " -f 1-2)"  /"$(udevadm info "$(blkid | grep crypto_LUKS|  cut -d : -f 1)" |grep by-uuid | cut -d : -f 2 | head -1)":/keyfile luks,keyscript=/lib/cryptsetup/scripts/pa$  >> /etc/crypttab.temporary
	mv /etc/crypttab /etc/crypttab.back
	mv /etc/crypttab.temporary /etc/crypttab

	# Restore permissions to crypttab
	chmod 0440 /etc/crypttab

	# Generate new initramfs
	mkinitramfs -o /boot/initrd.img-"$(uname -r)"  "$(uname -r)"

}






github::clone_repo_user ()
{
# Description:
# Function to CLONE all github.com repositories for a specified user.
# simply call the function and pass the username as parameter to clone
# all github repositories in to the current folder.
#
# Globals: None
# Arguments: User-name
# Outputs:
# Returns: a download of all repositories for the given user.
# Usage: ${FUNCNAME[0]} user-name
# End of documentation

	if [ $# -eq 0 ]; then
	    echo "Usage: ${FUNCNAME[0]} <user_name> "
	    exit 1;
	fi

	for repo in $(curl -s https://api.github.com/users/${1}/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/');do
	  git clone --depth=1 "https${repo:3}";
	done

}


github::list_all_user_repositories ()
{
# Description:
# Function to LIST all github.com repositories for a specified user.
# simply call the function and pass the username as parameter to show
# all github repositories the indicated user.
#
# Globals: None
# Arguments: User-name
# Outputs:
# Returns: a LIST of all repositories for the given user.
# Usage: ${FUNCNAME[0]} user-name
# End of documentation

	if [ $# -eq 0 ]
	  then
	    echo "Usage: ${FUNCNAME[0]} <user_name> "
	    return 1;
	fi

	for repo in $(curl -s https://api.github.com/users/${1}/repos?per_page=1000 |grep git_url |awk '{print $2}'| sed 's/"\(.*\)",/\1/'); do
		echo "https${repo:3}"
	done

}






oem::register_all_tools ()
{
# Description: Function to register all OEM scripts on the current device.
# It will find all the ${_TLA} powertools locations and make a link for each script to
# the system /bin directory. This assures that all tools can be easily accessed from any terminal.
#
#
# Globals: ${_MODS_DIR}
# Arguments: None accepted
# Outputs:
# Returns: default exit status of the last command run.
# Usage: oem::register_all_tools
# Dependencies: _locations
#
# End of Documentation
	_bashrc="/home/${_OEM_USER:-"tangarora"}/.bashrc"

	sed -i s/'# session  optional       pam_xauth.so'/'session  optional       pam_xauth.so'/g /etc/pam.d/sudo
	if ! grep "xhost local:root" "${_bashrc}" ; then echo 'xhost local:root >/dev/null' >> "${_bashrc}" ; fi

	if [[ -n "${_MODS_DIR}" ]] ; then
		for d in ${_MODS_DIR}/*/ ; do
			write_status "Creating links to $d"
			for f in $d/${_TLA,,}* ;
			do
				write_status "Processing: ${f}"
				chmod +x "${f}"
				ln -f -s "${f}" -t /bin/
			done
		done
		write_status "Creating links to ${_OEM_DIR}/core/*.sh"
		chmod +x "${_OEM_DIR}"/core/*.sh
		ln -f -s "${_OEM_DIR}"/core/*.sh -t /bin/
		return
	else
		write_error "Location variables not set!"
		return 1
	fi
}












check_menu_availability ()
{
# Description: First discover what menu system is installed. Some systems use "dialog" and
# other systems use whiptail for the terminal to show menus and dialogs.
# If nothing is found, then make sure it is available before continuing.
#
# Globals:
# RTD_GUI respected as default value. If unset it will be set to "dialog" or "whiptail"
# depending on which is present. IF both are present, the dialog is prefferred.
#
# Arguments: 	None accepted
# Outputs: 	Interactive
# Returns: 	Default exit status of the last command run.
# Usage: 	check_menu_availability
#
# End of documentation
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" \
			--title "System Information Menu" \
			--no-button "NO: Use whiptail" \
			--yes-button "YES: Install dialog" \
			--yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " \
			20 90 ); then
			RTD_GUI=dialog
			err_no_menu_system_found
		else
			echo "User selected No, exit status was $?."
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}










oem::rtd_tools_make_launchers ()
{
# Description: Function that creates a default set of launchers for the Linux GUI menu system.
#
# Globals:
# The tools (scripts) located in {_OEM_DIR}/*/ are expected as launchers are created for these.
# ${_MODS_DIR}
#
# Arguments: None accepted
# Outputs: Launcherc created in /usr/share/applications/
# Returns: Default exit status of the last command run.
# Usage: oem::rtd_tool_make_launchers
#
# End of documentation

	if [[ ! $UID -eq 0 ]]; then
		write_error "This function requires elevated privileges. Please elevate privileges prior to calling this function."
		return 1
	else
		write_information "Creating ${_TLA} launchers..."
		# Add launchers for some OEM apps.
		cat > /usr/share/applications/rtd.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD
		Comment=RTD Simple System Support Tool
		Exec=${_MODS_DIR}/simple-support-tool.mod/rtd-simple-support-tool
		Path=${_MODS_DIR}/simple-support-tool.mod
		Icon=${_MODS_DIR}/simple-support-tool.mod/Media_files/sys2.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-user-bakup.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-Backup
		Comment=RTD User home Backup Tool
		Exec=${_MODS_DIR}/system-user-backup.mod/rtd-oem-backup-linux-config
		Path=${_MODS_DIR}/system-user-backup.mod
		Icon=${_MODS_DIR}/system-user-backup.mod/Media_files/sys0.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-nordvpn.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-NordVPN
		Comment=Nord VPN Termnal GUI
		Exec=${_MODS_DIR}/nordvpn-manager.mod/rtd-nordvpn
		Path=${_MODS_DIR}/nordvpn-manager.mod
		Icon=${_MODS_DIR}/nordvpn-manager.mod/Media_files/sys3.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-minercraft-server.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=Minecraft-Server
		Comment=Automatically download and start a Minecraft Server here now!
		Exec=${_MODS_DIR}/minecraft-server-manager.mod/rtd-minecraft-server
		Path=${_MODS_DIR}/minecraft-server-manager.mod
		Icon=${_MODS_DIR}/minecraft-server-manager.mod/Media_files/sys5.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-switch-desktop.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD UI Look Changer
		Comment=Change the overall look and feel of your desktop (be more like Windows or MAC)
		Exec=${_MODS_DIR}/rtd-desktop-look-switcher.mod/rtd-desktop-look-switcher
		Path=${_MODS_DIR}/rtd-desktop-look-switcher.mod
		Icon=${_MODS_DIR}/rtd-desktop-look-switcher.mod/Media_files/sys7.ico
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-software-bundle-manager.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD Software Bundle Manager
		Comment=Add and remove bundles of software by task to your computer.
		Exec=${_MODS_DIR}/oem-bundle-manager/rtd-oem-bundle-manager
		Path=${_MODS_DIR}/oem-bundle-manager
		Icon=${_MODS_DIR}/oem-bundle-manager/image/software.ico
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-hardware-information.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD Hardware Information Viewer
		Comment=Add and remove bundles of software by task to your computer.
		Exec=${_MODS_DIR}/system-hardware-information/rtd-system-hardware-information
		Path=${_MODS_DIR}/system-hardware-information
		Icon=${_MODS_DIR}/system-hardware-information/image/system-information-icon-3.png
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF
		
		cat > /usr/share/applications/rtd-app-runner.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD OEM Special App Runner
		Comment=Run Specialized OEM Applications safely and reliably.
		Exec=${_MODS_DIR}/oem-app-runner/rtd-oem-app-runner
		Path=${_MODS_DIR}/oem-app-runner
		Icon=${_MODS_DIR}/oem-app-runner/image/App-launcher.jpg
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF
	fi
 }






system::get_Windows_Product_Key ()
{
# Description: Function to retrieve a Windows product key from the BIOS. This assumes that the OEM
# has indeed stored the windows key in the BIOS... Doing so is a common practice. It is useful to
# retrieve the key if it is desired to run Windows in a Virtual Machine and Presumably would prefer to
# not run the evaluation version of Windows. This function could also be used to take advantage of the
# ${WinKey} variable and echo it in to the autoinattend.xml file for unattended builds.
#
# Globals: RTD_GUI
# Arguments: None
# Outputs: A variable named: "${WinKey}" and echoing its contents to standard out.
# Returns: default exit status of the last command run.
# Usage: get_Windows_Product_Key
# End of documentation
	WinKey=$(sudo strings /sys/firmware/acpi/tables/MSDM | tail -1)
	echo "${WinKey}"
}







err_no_menu_system_found ()
{
# Description: Function to handle the error condition if a manu system is not found on the system.
# On occasion it may be neede to display dialog boxes and selection menus even in a terminal.
# for these cases; dialog, whiptail (newt), or zenity may be needed.
# This function will attempt to install the desired menu system and if it cannot or the user
# opts out it will error and exit the script.
#
# Globals: RTD_GUI
# Arguments: None
# Outputs: Interactive
# Returns: default exit status of the last command run.
# Usage:
# err_no_menu_system_found
# End of documentation

	write_error " ______________________________________________________________________ \n There is eiter no way to display menus on this system or you have told me \n to install the default  menu system! \n This is required to display the administrative menus... \n \n     Â¯\_( Í¡ðŸ‘ï¸â€¯ÍœÊ– Í¡ðŸ‘ï¸)_/Â¯ \n ______________________________________________________________________ \n"
	write_warning "May I attepmpt to install this ability to your system? \a "
	read -p "Add software: (y/n)?" choice
	case "$choice" in
	y|Y )
		: "${RTD_GUI:=$1}"
		for i in dnf yum zypper apt-get; do
			if hash $i 2>/dev/null; then
				$i install $RTD_GUI -y
				if $? eq 0 ;  then
					echo -e $YELLOW"$RTD_GUI installed... exporting..."
					RTD_GUI="dialog --clear"
					export RTD_GUI
					return 0
				fi
			fi
		done
	;;
	n|N ) err_no_menu_system_available ;;
	* ) read -p  "Invalid Selection" && err_no_menu_system_found || exit 1 ;;
	esac
}








enable_firewall ()
{
# Description:
# Function to enable system firewall and add a given rule. This simple function
# enables Uncomplicated Fire Wall (UFW) and adds a rule to allow SSH to
# pass. This function expects no arguments. However nothing will be done if
# no ufw firewall is present on the system. The cunction will not attempt to add
# the ufw since this may conflict with any firewall present. To use this funciton
# to enable ufw, first any other firewall software must be disabled and ufw added.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo -e $faded_orange "UFW not present on this system: please turn on the firewall and configure it manually!" $ENDCOLOR
	fi
}







rtd_oem_reset_default_environment_config ()
{
# Description: Function to reset temporary configurations to their original setings from the
# distributor. To configure and/or automatically install Linux systems RTD OEM
# load process must make some changes to the system in question that are not
# good security practice or that may be disruptive during normal operations.
# These setings are not limited to bu include "auto login", "auto sudo" and
# "auto running scripts"...
# Globals:
# Arguments: None
# Outputs: removes autostart files and configurations from an OEM state to a default state.
# Returns:
# Usage:
# End of documentation

	# Disable the automatically trying to install OEM software
	mkdir -p ${_OEM_DIR}/cache/
	[[ -f /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ]] && mv /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ${_OEM_DIR}/cache/
	[[ -f /etc/sudoers.d/99_sudo_include_file ]] && mv /etc/sudoers.d/99_sudo_include_file ${_OEM_DIR}/cache/
	cp /home/${SUDO_USER}/.bashrc ${_OEM_DIR}/cache/bashrc
	# Keep ability for root to open dialog boxes for a user.
	sed -i '/xhost\ local:root/d' /home/${SUDO_USER}/.bashrc
	toggle_oem_auto_login
}






rtd_wait_for_internet_availability ()
{
# Description: Function that, when called, will wait for an active internet connection
# to be available before before continuing. Most softwrare install activities
# need an active internet connection to be able to install and update software.
# Naturally, some in house loads use local mirrors, but if you can see the
# internet, you would have access to your own ropositories as well...
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: rtd_wait_for_internet_availability
# End of documentation



	write_status "Waiting for internet access..."
	write_information "NOTE: Free access to the internet is required to continue."
	while ! ping -c 1 -W 1 8.8.8.8 &>/dev/null ; do
		write_status "Waiting..."
		sleep 10
	done
}







io_on_notify_wait ()
{
# Description: Function that, when called, will wait for a disk change
# and then execute the command passed as an argument. This is useful when
# wanting to keep two location in sync with minimal delay, or to scan
# for malware as soon as a change has occurred.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: io_on_notify_wait rsync -avt . host:/remote/dir ...
# End of documentation

	check_dependencies inotify-tools
	EVENTS="CREATE,CLOSE_WRITE,DELETE,MODIFY,MOVED_FROM,MOVED_TO"

	if [ -z "$1" ]; then
		write_error "Usage: $0 rsync -avt . host:/remote/dir ..."
		exit 1;
	fi

	inotifywait -e "$EVENTS" -m -r --format '%:e %f' . | (
		WAITING="";
		while true; do
		LINE="";
		read -t 1 LINE;
		if test -z "$LINE"; then
			if test ! -z "$WAITING"; then
				echo "CHANGE";
				WAITING="";
			fi;
		else
			WAITING=1;
		fi;
		done) | (
		while true; do
		read TMP;
		echo "$@"
		"$@"
		done
	)
}









system::display_spinner ()
{
# Description: Simple function to display a spinner in the terminal.
# Globals:
# Arguments: start/stop
# Outputs:
# Returns:
# Usage:
#
#
#
# End of documentation

	function _spinner() {
	# $1 start/stop
	#
	# on start: $2 display message
	# on stop : $2 process exit status
	#           $3 spinner function pid (supplied from stop_spinner)

	local on_success="DONE"
	local on_fail="FAIL"
	local nc="\e[0m"

	case $1 in
		start)
		# calculate the column where spinner and status msg will be displayed
		let column=$(tput cols)-${#2}-46
		# display message and position the cursor in $column column
		# echo -ne ${2}
		printf "%${column}s"

		# start spinner
		i=1
		sp='\|/-'
		delay=${SPINNER_DELAY:-0.15}

		while :
		do
			printf "${RED}\b[${sp:i++%${#sp}:1}]\b\b${ENDCOLOR}"
			sleep $delay
		done
		;;
		stop)
		if [[ -z ${3} ]]; then
			echo "spinner is not running.."
			exit 1
		fi

		kill $3 > /dev/null 2>&1

		# inform the user uppon success or failure
		echo -en "\b["
		if [[ $2 -eq 0 ]]; then
			echo -en "${green}${on_success}${nc}"
		else
			echo -en "${red}${on_fail}${nc}"
		fi
		echo -e "]"
		;;
		*)
		write_error "invalid argument, try {start/stop}"
		exit 1
		;;
	esac
	}

	function start_spinner {
	# $1 : msg to display
	_spinner "start" "${1}" &
	# set global spinner pid
	export _sp_pid=$!
	disown
	}

	function stop_spinner {
	# $1 : command exit status
	_spinner "stop" $1 $_sp_pid
	unset _sp_pid
	}

	if [[ "$1" == "start" ]] ; then
		start_spinner $2
	elif [[ "$1" == "stop" ]] ; then
		stop_spinner $2
	else
		write_error "invalid argument, try {start/stop}"
	fi

}











toggle_oem_run_once () {
# Task to run the OEM post configuaration on first login.
# the OEM post configuration may allow for interaction if desired and would
# best run on several distributions and in a full graphic environment.
#
# Globals:
# Arguments: [script path] [optional:path to .desktop launcher]
# Outputs:
# Returns:
# Usage:
#
# setup_oem_run_once /path/to/script.sh
# End of documentation
	_FILE=${2:-"/etc/xdg/autostart/oem-run.desktop"}
	# If the launcher exists, delete it, else create it.
	if [[ -e ${_FILE} ]] ; then
		if [[ -w "${_FILE}" ]]
		then
			write_information "Removing execution on login of (${_FILE})"
			rm ${_FILE}
		else
			write_warning "Write permission is NOT granted on ${_FILE}"
			write_status "Requesting elevated privileges..."
			sudo rm ${_FILE}
		fi
	else
		write_information "Adding execution on login of (${_FILE})"
		cat > ${_FILE} <<-CREATE_START_LINK
		# This will automatically start the RuntTime Data OEM config options on
		# the first login. Once run this launcher will be moved to the /opt/rtd folder
		# so that subsequent logins will not be plagued by the OEM setup.
		#
		[Desktop Entry]
		Type=Application
		Exec=sudo -E $1
		Terminal=true
		Hidden=false
		X-GNOME-Autostart-enabled=true
		Name=${_BACK_TITLE} OEM Run
		Comment=OEM
		CREATE_START_LINK
	fi
}









system::update_config ()
{
# Description: This function updates a configuration file with key-value pairs.
# The `system::update_config` function is designed to update a configuration file 
# with key-value pairs. It takes as parameters the path to the configuration
# file and the key-value pairs to be updated or added to the configuration file. 
# If the key already exists in the configuration file, the value is updated.
# If the key does not exist in the configuration file, the key-value pair is added.
# Globals:
# Arguments: config_file key-value pairs
# Outputs: The configuration file with the updated key-value pairs.
# Returns: None
# Usage: system::update_config /home/user/.config/myapp/config.conf key1 value1 key2 value2
#
# Parameters:
#   - config_file: The path to the configuration file.
#   - key-value pairs: The key-value pairs to be updated or added to the configuration file.
# Returns: None
# 
# Example: 
# 
# system::update_config /home/user/.config/myapp/config.conf key1 value1 key2 value2
#
# End of documentation

	local config_file=$1
	shift  # Shift past the first argument (the config file path)
	system::log_item "Updating configuration file with key-value pairs: $@"
	mkdir -p ${config_file%/*}  ; touch $config_file || system::log_item "Failed to create config file: $config_file"
	
	while (( "$#" )); do
		local key=$1
		local value=$2
		shift 2  # Shift past the processed key-value pair

		if grep -q "^$key=" "$config_file"; then
			system::log_item "Update existing entry $key=$value in $config_file"
			sed -i "s|^$key=.*|$key=$value|" "$config_file"
		else
			system::log_item "Add new entry $key=$value to $config_file"
			echo "$key=$value" >> "$config_file"
		fi
	done
}




system::read_config ()
{
# Description: This function reads a configuration file with key-value pairs.
# The configuration file should contain one key-value pair per line, with the
# key and value separated by an equals sign.
# Globals:
# Arguments: config_file (path to configuration file)
# Outputs:
# Returns: standard exit code
# Usage: system::read_config /home/user/.config/myapp/config.conf
#
# Parameters:
#   - config_file: The path to the configuration file.
#   
# Returns: None
# 
# Example:
#   system::read_config "/home/user/.config/myapp/config.conf" 
#
# End of documentation
        # Specify the path to your configuration file
        local config_file=$1

        system::log_item "Reading configuration file: $config_file"
        # Read each line in the configuration file
        while IFS='=' read -r key value; do
                if [[ $key && $value ]]; then
                        # Use declare to safely assign value to the variable named by 'key'
                        declare -g "$key=$value"
                        system::log_item "Read key-value pair: $key=$value"
                fi
        done < "$config_file"
}









toggle_oem_auto_login ()
{
# Description: Function to toggle auto login for admin purposes.
# Call the function once to set auto login and call it again to
# unset auto login. This is usefult to do an administrative login interactively
# and run configuration scripts (like for OEM setup, KVM automatic template generation)
#
# This function will look for all the popular display managers adn common ways to configure
# automatic login and set those. If auto login is already set, this funciton will unset the
# automatic login.
#
# The function will also check and apply SUSE speciffic configurations: it will not edit the
# sddm.conf, gdm.conf, gdm3.conf, or lightdm.conf, instead, it modifies the suse speciffic
# displaymanager file in /etc/sysconfig/.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  toggle_oem_auto_login
#
#
# End of documentation

	# first, do not treat SUSE like the others... It wil complain and not do what you want...
	if ! hostnamectl |grep suse ; then
		# Toggle auto login for Light DM if present (Old Ubuntu, Mint?, Budgie? etc.)
		if [[ -f /etc/lightdm/lightdm.conf ]]; then
			if [[ -f /etc/lightdm/lightdm.conf.rtd-bak ]]; then
				write_status "***** LightDM auto login is enabled: toggeling off... ******"
				rm /etc/lightdm/lightdm.conf && mv /etc/lightdm/lightdm.conf.rtd-bak /etc/lightdm/lightdm.conf
			else
				write_status "***** LightDM auto login is disabled: toggeling on... ******"
				cp /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.rtd-bak
				cat > /etc/lightdm/lightdm.conf <<-OEM_LXDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/lightdm/lightdm.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[SeatDefaults]
				autologin-user=${SUDO_USER:-"tangarora"}
				autologin-user-timeout=0
				OEM_LXDM_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for SDDM if present (Kubuntu, SUSE, KDE Based DE's)
		if [[ -f /etc/sddm.conf ]]; then
			if [[ -f /etc/sddm.conf.rtd-bak ]]; then
				write_status "******* SDDM auto login is enabled: toggeling off... *******"
				rm /etc/sddm.conf && mv /etc/sddm.conf.rtd-bak /etc/sddm.conf
			else
				write_status "******* SDDM auto login is disabled: toggeling on... *******"
				cp /etc/sddm.conf /etc/sddm.conf.rtd-bak
				cat > /etc/sddm.conf <<-OEM_SDDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/sddm.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[Autologin]
				User=${SUDO_USER:-"tangarora"}
				Session=plasma.desktop
				OEM_SDDM_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for GDM3 if present (Ubuntu, Debian default etc.)
		if [[ -f /etc/gdm3/daemon.conf ]]; then
			if [[ -f /etc/gdm3/daemon.conf.rtd-bak ]]; then
				write_status "******* GDM3 auto login is enabled: toggeling off... *******"
				rm /etc/gdm3/daemon.conf && mv /etc/gdm3/daemon.conf.rtd-bak /etc/gdm3/daemon.conf
			else
				write_status "******* GDM3 auto login is disabled: toggeling on... *******"
				cp /etc/gdm3/daemon.conf /etc/gdm3/daemon.conf.rtd-bak
				cat >  /etc/gdm3/daemon.conf <<-OEM_GDM3_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/gdm3/daemon.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[daemon]
				AutomaticLoginEnable=True
				AutomaticLogin=${SUDO_USER:-"tangarora"}
				WaylandEnable=false
				OEM_GDM3_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for GDM per gnome standard (Fedora et. al.)
		if [[ -f /etc/gdm/custom.conf ]]; then
			if [[ -f /etc/gdm/custom.conf.rtd-bak ]]; then
				write_status "******* GDM auto login is enabled: toggeling off... ********"
				rm /etc/gdm/custom.conf && mv /etc/gdm/custom.conf.rtd-bak /etc/gdm/custom.conf
			else
				write_status "******* GDM auto login is disabled: toggeling on... ********"
				cp /etc/gdm/custom.conf /etc/gdm/custom.conf.rtd-bak
				cat >  /etc/gdm/custom.conf <<-OEM_GDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/gdm/custom.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				# GDM configuration storage

				[daemon]
				WaylandEnable=false
				AutomaticLoginEnable=True
				AutomaticLogin=${SUDO_USER:-"tangarora"}

				[security]

				[xdmcp]

				[chooser]

				[debug]
				OEM_GDM_LOGIN_OPTION
			fi
		fi
	fi

	# Special case for SUSE...
	if [[ -e /etc/sysconfig/displaymanager ]] ; then
		if [[ -e /etc/sysconfig/displaymanager.rtd-bak ]]; then
			write_status "****** SUSE auto login is enabled: toggeling off... ********"
			rm /etc/sysconfig/displaymanager && mv /etc/sysconfig/displaymanager.rtd-bak /etc/sysconfig/displaymanager
		else
			write_status "****** SUSE auto login is disabled: toggeling on... ********"
			cp /etc/sysconfig/displaymanager /etc/sysconfig/displaymanager.rtd-bak || write_error "Could not backup: /etc/sysconfig/displaymanager! "
			sed -i 's/DISPLAYMANAGER_AUTOLOGIN=""/DISPLAYMANAGER_AUTOLOGIN="tangarora"/' /etc/sysconfig/displaymanager || write_error "Could not write to file: /etc/sysconfig/displaymanager!"
			#sed -i 's/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="no"/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="yes"/' /etc/sysconfig/displaymanager || write_error "Could not write to file: /etc/sysconfig/displaymanager!"
		fi
	fi

	# Toggle auto login for Terminal target env. (no GUI).
	if [ ! -f /etc/systemd/system/getty@tty1.service.d/override.conf ]; then
		write_status "******* TTY auto login is disabled: toggeling on... ********"
		mkdir -p /etc/systemd/system/getty@tty1.service.d
		cat >  /etc/systemd/system/getty@tty1.service.d/override.conf <<-OEM_TTY_LOGIN_OPTION
		"[Service]"
		"ExecStart="
		"ExecStart=-/sbin/agetty --noissue --autologin ${SUDO_USER:-"tangarora"} %I $TERM"
		"Type=idle"
		OEM_TTY_LOGIN_OPTION
	else
		write_status "******* TTY auto login is enabled: toggeling off... ********"
		rm /etc/systemd/system/getty@tty1.service.d/override.conf
	fi
}









set_oem_elevated_privilege_gui ()
{
# Description: Some Debian and other Linux distribution do not allow gui apps to
# be run when invoked by "sudo" or in a root (system elevated authority)
# environment. To mitigate this some stemp may need to taken.
# Will work on Slackware as well as Debian to give root permission to open X programs.
#
# Globals: $_OEM_USER
# Arguments: None
# Outputs: configures local X environment to allow root to show GUI apps
# Returns:
# Usage: set_oem_elevated_privilege_gui
# End of documentation

	write_information "Editing bashrc: xhost local:root IN /home/${_OEM_USER}/.bashrc"
	touch /home/${_OEM_USER}/.bashrc
	echo "xhost local:root" >> /home/${_OEM_USER:-"tangarora"}/.bashrc

	# Allows runing an X program as root
	write_information "Editing bashrc: XAUTHORITY=/home/${_OEM_USER}/.Xauthority IN /root/.bashrc"
	touch /root/.bashrc
	echo "export XAUTHORITY=/home/${_OEM_USER:-"tangarora"}/.Xauthority" >>/root/.bashrc
}






set_enable_oem_elevated_privelege()
{
# Description: Set no password elevated priviledges.
# This will allow apps to be run when invoked by "sudo" without being prompted
# for a password. This emulates the "UAC" from Microsoft. Please remember to
# turn this off using the function "rtd_oem_reset_default_environment_config"
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	: ${_OEM_USER:="${SUDO_USER}"}
	write_information "Adding instruction to a sudoers include file: ${_OEM_USER} ALL=(ALL) NOPASSWD:ALL"
	# This should be removed when OEM setup is complete as it would represent a back door...
	echo "${_OEM_USER} ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/99_sudo_include_file

	# Check that your sudoers include file passed the visudo syntax checks:
	sudo visudo -cf /etc/sudoers.d/99_sudo_include_file
}






make_system_recovery_partition ()
{
# Description: Incomplete function to build an OEM rescue partition...
# Function to enable system OEM Recovery
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: NOTE: I have yet to figura out how to do this!

# End of documentation

	devlist="$(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep 1 | cut -f1 -d' ')"

	if [[ -z ${devlist} ]]; then
		DIALOGRC="/root/.dialogrc"
		if -e ${DIALOGRC} ; then
			mv ${DIALOGRC} ${DIALOGRC}.bak
		fi
		echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
		dialog --title "Physical Installation Media Creator Error!" --backtitle "OS Media Manger" --msgbox "No removable media could be found!"  14 90
		rm ${DIALOGRC}
		if -e ${DIALOGRC}.bak ; then
			mv ${DIALOGRC}.bak ${DIALOGRC}
		fi
		return 1
	else
		declare -A RemovableMediaList
		key=0
		for i in $(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep 1 | cut -f1 -d' ');
		do
			SuggestedRemovableDevice="${i}"
			element="$(fdisk -l /dev/$i |head -1)"
			RemovableMediaList[$key]=$(echo -e \'"$element"\')
			(( key++ ))
		done

		if [[ 1 -eq ${#RemovableMediaList[@]} ]]; then
			mkdir /boot/iso
			dd if=/dev/${SuggestedRemovableDevice} of=/boot/iso/recovery.iso
			cat >> /etc/grub.d/40_custom <<-'EOF'
			menuentry "Reset to Factory Defaults" {
				set isofile="/boot/iso/recovery.iso"
				loopback loop (hd0,8)$isofile
				linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile noprompt noeject
				initrd (loop)/casper/initrd.lz
			}
			EOF
		else

			ChosenMediaItem="
			Removable media found: \n
			------------------------------------------------------------------------------- \n
			\n
			$(until [ $i -gt ${#RemovableMediaList[@]} ]
			do
				echo -e "Removable Disk $i:   ${RemovableMediaList[$i]}" \n
				((i=i+1))
			done
			)"

			USBTargetDevice=$( dialog --stdout --title "Physical Installation Media Creator" \
			--backtitle "OS Media Manger" \
			--inputbox "\n ${DiscoveredItems}" 0 0 /dev/${SuggestedRemovableDevice} )

			mkdir /boot/iso
			dd if=/dev/${ChosenMediaItem} of=/boot/iso/recovery.iso
			cat >> /etc/grub.d/40_custom <<-'EOF'
			menuentry "Reset to Factory Defaults" {
				set isofile="/boot/iso/recovery.iso"
				loopback loop (hd0,8)$isofile
				linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile noprompt noeject
				initrd (loop)/casper/initrd.lz
			}
			EOF
		fi
	fi
}







rtd_oem_reseal () 
{
# Description: 
# Function to reseal a newly installed system for delivery to end user.
# Globals: The distribution must have an OEM reseal function or software available.
# Arguments: None
# Outputs:
# Returns:
# Usage:

# End of documentation
	if cat /etc/os-release |grep ubuntu ; then
		InstallSoftwareFromRepo oem-config-gtk
		oem-config-prepare
		shutdown -h now
	elif cat /etc/os-release |grep kubuntu ; then
		InstallSoftwareFromRepo oem-config-kde
		oem-config-prepare
		shutdown -h now
	elif cat /etc/os-release |grep suse ; then
		system::log_item "I dont know of any OEM configuration for SuSE"
	elif cat /etc/os-release |grep fedora ; then
		system::log_item "I dont know of any OEM configuration for Fedora"
	else
		system::log_item "I dont know of any OEM configuration for this distribution"
	fi
}








check_if_password_pOwned ()
{
# Description: 
# Function to query a user for a password suggestion and check it against P0wned data base online.
# Globals: $RTD_GUI
# Arguments: None
# Outputs: dialog box
# Returns:
# Usage: check_if_password_pOwned

# End of documentation

	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep "$(echo "${sha1:5:35}" | tr '[:lower:]' '[:upper:]')");
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}








rtd_oem_find_live_release ()
{
# Description: This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
# 3 parameters are required for this function to know what to do: distro_version/distro_flavor/live_or_not
#
# Globals:
# Arguments: None
# Outputs:
# Returns: Return a URL to the desired release ISO of Ubuntu or Debian.
# Usage:
# Example:
# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env (only Debian)
# rtd_oem_find_live_release 	      10              debian         live           kde
# rtd_oem_find_live_release 	      10              debian         live           cinnamon
# rtd_oem_find_live_release 	      10              debian         net            ssh-server
# rtd_oem_find_live_release 	      19.04.2         ubuntu         live
# End of documentation
	local distro_version="${1:-10}"
	local distro_flavor="${2:-debian}"
	local live_or_not="${3:-live}"
	local desktop_env="${4:-standard}"

	case "$distro_flavor" in
	Ubuntu | ubuntu )
		case "$live_or_not" in
		desktop | live)
			system::log_item "Providing requested URL: http://releases.ubuntu.com/${distro_version}/$(curl --silent http://releases.ubuntu.com/${distro_version}/SHA256SUMS | grep -o 'ubuntu-.*-desktop-amd64.iso')"
			echo "http://releases.ubuntu.com/${distro_version}/$(curl --silent http://releases.ubuntu.com/${distro_version}/SHA256SUMS | grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | server-desktop )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			system::log_item "Providing requested URL: http://releases.ubuntu.com/${distro_version}/ubuntu-${distro_version}-live-server-amd64.iso"
			echo "http://releases.ubuntu.com/${distro_version}/ubuntu-${distro_version}-live-server-amd64.iso"

		;;
		* )
			system::log_item "Encountered an error: The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not"
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				system::log_item "Encountered an error: The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not "
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
			system::log_item "Encountered an error: The 2nd parameter netinst  debian is not logical. Please use the kernel params instead."
		;;
		* )
			system::log_item "Encountered an error: The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not"
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
	;;
	esac
}






cleanup_and_finish ()
{
# Description: Function to remove all temporary file locations left over from building
# the new netinstall ISO etc. and clean  up some variables...
# go back to initial directory
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	cd "$current_dir" && echo "returned to $current_dir" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$tmp_download_dir"
	rm -r "$tmp_disc_dir"
	rm -r "$tmp_initrd_dir"
	rm -r "$script_dir/custom"

	if [[  "$1" != "nomessage" ]]; then
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $put_iso_file_here_when_done/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else
		echo "Cleanup..."
	fi

	unset bin_7z
	unset bin_xorriso
	unset bin_cpio
	unset isohdpfx_bin
	unset VOLUME_TITLE
	unset target_iso_file_name
	unset _SOURCE_ISO_URL
	unset ssh_public_key_file
	unset PRESEED_TEMPLATE
	unset CONFIG
	unset PRESEED_FILE
	unset SRVorVDI
	clear
	return
}




generate_report_disk_space_used_by_directory ()
{
# Description: Function to generate a report for folders' disk space use.
# This function requres one argument; what root folder to analyse the directories in.
# This functio will return a report contained in the variable $return that may then be used.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# generate_report_disk_space_used_by_directory /home
#
# This will generate a report on the disk space per directory in the /home folder.
#
# End of documentation

	DIRS=$( ls $1 )
	store=/$tmp/out.ct
	$RTD_GUI --backtitle "$BRANDING" --title "Generating report for: $1" --gauge "Calculating disk space: this may take some time" $HEIGHT $WIDTH < <(
		echo "Storage Utilization Report:" >>$store
		echo "______________________________" >>$store
		n=$(ls $1 | wc -l )
		i=0
		for f in $DIRS
		do
			du -cksh $1/$f 2>/dev/null | grep -v total >>$store
			PCT=$(( 100*(++i)/n ))
			cat <<-EOF
			XXX
			$PCT
			Completed calculation for: "$f"...
			XXX
			EOF
			sleep 1
		done
	)
	total=$(echo ----- >>$store && du -cksh $1 2>/dev/null |grep total >>$store) | $RTD_GUI --backtitle "$BRANDING" --title "Completing report..." --progressbox "Working..." $HEIGHT $WIDTH
	result="$(cat $store )" ; rm $store
}















set_gnome_ui_common_tweaks_for_user ()
{
# Description:
# Configure Gnome for OEM look and feel. This is completely as desired.
# This function takes no arguments. Simply call it to make the changes.
# Howerver, this function must be called as the user it should apply to.
# if it is called in a script with "sudo" priviledges, it will make chages to
# the look and feel for the "root" user.
#
# To run this function as the user who started a script with sudo script content
# could be echoed out ot a temporary file and executed as follows
# sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus temporary_script.sh > /dev/null 2>&1
# or alternatively by calling the function "system::run_command_in_gnome_user_session /path/to/temorary_script.sh".
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# USAGE:
#
# set_gnome_ui_common_tweaks_for_user
#
# End of documentation

	write_status "Seting common OEM tweaks..."
	# Terminal and Tilix Dark Theme
		GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
		# gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'dark'
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency false
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000

	# Better Font Smoothing
		gsettings set org.gnome.settings-daemon.plugins.xsettings antialiasing 'rgba'

	# Usability Improvements
		gsettings set org.gnome.desktop.peripherals.mouse accel-profile 'adaptive'
		gsettings set org.gnome.desktop.sound allow-volume-above-100-percent true
		gsettings set org.gnome.desktop.calendar show-weekdate true
		gsettings set org.gnome.desktop.wm.preferences resize-with-right-button true
		gsettings set org.gnome.desktop.wm.preferences button-layout 'appmenu:minimize,maximize,close'
		gsettings set org.gnome.shell.overrides workspaces-only-on-primary false

	# This indexer is nice, but can be detrimental for laptop users battery life
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery false
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery-first-time false
		gsettings set org.freedesktop.Tracker.Miner.Files throttle 15

	# Configure Dash to Dock
		gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM'
		gsettings set org.gnome.shell.extensions.dash-to-dock apply-custom-theme false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-background-color false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots true
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots-color '#729fcf'
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink true
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true
		gsettings set org.gnome.shell.extensions.dash-to-dock force-straight-corner false
		gsettings set org.gnome.shell.extensions.dash-to-dock icon-size-fixed true
		gsettings set org.gnome.shell.extensions.dash-to-dock intellihide-mode 'ALL_WINDOWS'
		gsettings set org.gnome.shell.extensions.dash-to-dock isolate-workspaces true
		gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true
		gsettings set org.gnome.shell.extensions.dash-to-dock unity-backlit-items false
		gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode 'FIXED'
		gsettings set org.gnome.shell.extensions.dash-to-dock running-indicator-style 'SEGMENTED'
		gsettings set org.gnome.shell.extensions.dash-to-dock background-opacity 0.70000000000000000
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false

	# Configure dash-to-panel
		temporary_script=$(mktemp)
		chmod 777 ${temporary_script}
		cat > ${temporary_script} <<-'EOF_D2P'
		[org/gnome/shell/extensions/dash-to-panel]
		appicon-margin=4
		appicon-padding=4
		available-monitors=[0]
		dot-color-1='#5294e2'
		dot-color-2='#5294e2'
		dot-color-3='#5294e2'
		dot-color-4='#5294e2'
		dot-color-dominant=false
		dot-color-override=true
		dot-color-unfocused-1='#5294e2'
		dot-color-unfocused-2='#5294e2'
		dot-color-unfocused-3='#5294e2'
		dot-color-unfocused-4='#5294e2'
		dot-color-unfocused-different=false
		dot-style-focused='METRO'
		dot-style-unfocused='SEGMENTED'
		focus-highlight-color='#eeeeee'
		focus-highlight-dominant=true
		force-check-update=true
		group-apps=true
		hotkeys-overlay-combo='TEMPORARILY'
		isolate-monitors=false
		isolate-workspaces=false
		panel-element-positions='{"0":[{"element":"showAppsButton","visible":true,"position":"stackedTL"},{"element":"activitiesButton","visible":false,"position":"stackedTL"},{"element":"leftBox","visible":true,"position":"stackedTL"},{"element":"taskbar","visible":true,"position":"stackedTL"},{"element":"centerBox","visible":true,"position":"stackedBR"},{"element":"rightBox","visible":true,"position":"stackedBR"},{"element":"dateMenu","visible":true,"position":"stackedBR"},{"element":"systemMenu","visible":true,"position":"stackedBR"},{"element":"desktopButton","visible":false,"position":"stackedBR"}]}'
		secondarymenu-contains-showdetails=true
		show-appmenu=false
		show-favorites=true
		show-favorites-all-monitors=false
		stockgs-keep-dash=false
		stockgs-keep-top-panel=false
		trans-use-custom-bg=false
		trans-use-custom-opacity=true
		tray-size=0
		EOF_D2P
		dconf load / < ${temporary_script} && rm ${temporary_script}

	# Nautilus (File Manager) Usability
		gsettings set org.gnome.nautilus.icon-view default-zoom-level 'standard'
		gsettings set org.gnome.nautilus.preferences executable-text-activation 'ask'
		gsettings set org.gtk.Settings.FileChooser sort-directories-first true
		gsettings set org.gnome.nautilus.list-view use-tree-view true
		gsettings set org.gnome.nautilus.list-view default-zoom-level 'small'

	# Set the GNOME Shell Apps Dashboard sort app in categories based on the FreeDesktop standard.
		# Set the GNOME Shell Apps Dashboard sort app in categories based on the FreeDesktop standard.
		gsettings set org.gnome.desktop.app-folders folder-children "['accessories', 'chrome-apps', 'games', 'graphics', 'internet', 'office', 'programming', 'science', 'sound---video', 'system-tools', 'universal-access', 'wine', 'OEM', '3D-Printing', 'Cloud']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ name "Accessories"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ categories "['Utility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ name "Chrome Apps"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ categories "['chrome-apps']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ name "Games"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ categories "['Game']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ name "Graphics"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ categories "['Graphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ name "Internet"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ categories "['Network', 'WebBrowser', 'Email']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ name "Office"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ categories "['Office']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ name "Programming"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ categories "['Development']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ name "Science"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ categories "['Science']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ name "Sound & Video"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ categories "['AudioVideo', 'Audio', 'Video']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ name "System Tools"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ categories "['System', 'Settings']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ name "Universal Access"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ categories "['Accessibility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ name "Wine"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ categories "['Wine', 'X-Wine', 'Wine-Programs-Accessories']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ name "OEM"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ categories "['OEM']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ name "3D-Printing"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ categories "['3D-Printing', 'CAD', '3D', '3DGraphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ name "Cloud"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ categories "['Cloud-Management', 'Cloud', 'aws', 'azure', 'gcp']"

	# Add Tilix configuration and shell definitions
		mkdir -p ~/.config/rtd
		cat > ~/.config/rtd/gconf-tilix-settings.ini <<-'EOF_TLX'
		[com/gexperts/Tilix]
		quake-specific-monitor=0
		quake-width-percent=90
		terminal-title-style='small'
		theme-variant='dark'
		warn-vte-config-issue=false

		[com/gexperts/Tilix/profiles]
		list=['2b7c4080-0ddd-46c5-8f23-563fd3ba789d', 'd6401d4b-4b26-42ec-918a-2e7dc977118d', '8000e9d6-6f21-4a4e-a122-ac45607b56f5', '5283b4cf-faa5-4aef-afcd-a29fd5e0335a', '75b21a4c-150c-4f7a-a093-9faaa19626e2', '1824e1f9-3b7e-48d2-b06a-709239d1d6d9']

		[com/gexperts/Tilix/profiles/1824e1f9-3b7e-48d2-b06a-709239d1d6d9]
		background-color='#272822'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#F8F8F2'
		highlight-colors-set=false
		palette=['#272822', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F8F8F2', '#75715E', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F9F8F5']
		use-theme-colors=false
		visible-name='Monokai'

		[com/gexperts/Tilix/profiles/2b7c4080-0ddd-46c5-8f23-563fd3ba789d]
		background-color='#000000000000'
		background-transparency-percent=10
		badge-color='#AC7EA8'
		badge-color-set=true
		bold-color-set=false
		cursor-colors-set=false
		default-size-columns=180
		default-size-rows=40
		dim-transparency-percent=0
		font='Ubuntu Mono 10'
		foreground-color='#EFEFEF'
		highlight-colors-set=false
		palette=['#000000', '#AA0000', '#00AA00', '#AA5400', '#0000AA', '#AA00AA', '#00AAAA', '#AAAAAA', '#545454', '#FF5454', '#54FF54', '#FFFF54', '#5454FF', '#FF54FF', '#54FFFF', '#FFFFFF']
		terminal-title='${id}: ${title}${process}'
		use-system-font=false
		use-theme-colors=false
		visible-name='Linux'

		[com/gexperts/Tilix/profiles/5283b4cf-faa5-4aef-afcd-a29fd5e0335a]
		background-color='#FDF6E3'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#657B83'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Sun Microsystems'

		[com/gexperts/Tilix/profiles/75b21a4c-150c-4f7a-a093-9faaa19626e2]
		background-color='#002B36'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#839496'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Solarized'

		[com/gexperts/Tilix/profiles/8000e9d6-6f21-4a4e-a122-ac45607b56f5]
		background-color='#1E1E1E'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#A7A7A7'
		highlight-colors-set=false
		palette=['#1E1E1E', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#A7A7A7', '#5F5A60', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#FFFFFF']
		use-theme-colors=false
		visible-name='Twilight'

		[com/gexperts/Tilix/profiles/d6401d4b-4b26-42ec-918a-2e7dc977118d]
		palette=['#000000', '#CC0000', '#4D9A05', '#C3A000', '#3464A3', '#754F7B', '#05979A', '#D3D6CF', '#545652', '#EF2828', '#89E234', '#FBE84F', '#729ECF', '#AC7EA8', '#34E2E2', '#EDEDEB']
		use-theme-colors=true
		visible-name='Tango'
		EOF_TLX
		dconf load / < ~/.config/rtd/gconf-tilix-settings.ini
}








set_gnome_ui_tweak_no_media_error ()
{
# Description:  Function to handle missing media when attempting to set UI look to
# 		resemble MAC/Windows/etc. for users accustomed to that.
#
# Usage:
# set_gnome_ui_tweak_no_media_error
# OEM_Hint="My custom mesage" ; set_gnome_ui_tweak_no_media_error
#
# Globals: ${OEM_Hint}
# Arguments: none
# Outputs:
# Returns: Standard err for last task
# End of documentation
	: ${OEM_Hint:="I cannot find the actual theme files needed. Should I attempt to get these?"}

	zenity --question --text "${OEM_Hint}" --width=600
	case "$?" in
		0 ) oem::deploy_themes ; bash ${_THEME_DIR}/plus-themes.se ;;
		1 ) return ;;
		* ) write_error "unknown response received!" ; return 1 ;;
	esac
}







set_gnome_ui_mac_tweaks_for_user ()
{
# Description: Function to set UI look to resemble MAC for users accustomed to that.
#
# Usage:
# set_gnome_ui_mac_tweaks_for_user Dark
# set_gnome_ui_mac_tweaks_for_user Light
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# End of documentation

	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting MAC like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/WhiteSur-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'WhiteSur-Dark'
			gsettings set org.gnome.desktop.interface icon-theme 'WhiteSur-dark'
			gsettings set org.gnome.shell.extensions.user-theme name "WhiteSur-Dark"

			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name MojaveNight.jpg)

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'dark'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/WhiteSur-Light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'WhiteSur-Light'
			gsettings set org.gnome.desktop.interface icon-theme 'WhiteSur'
			gsettings set org.gnome.shell.extensions.user-theme name "WhiteSur-Light"

			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name MojaveDay.jpg)

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'light'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'
	gsettings set org.gnome.desktop.wm.preferences button-layout 'close,maximize,minimize:appmenu'
	# Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'desktop-icons@csoriano', \
	'ubuntu-appindicators@ubuntu.com', \
	'CoverflowAltTab@palatis.blogspot.com']"


	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}






set_gnome_ui_win10_tweaks_for_user ()
{
# Description: Function to set UI look to resemble Windows 10 for users accustomed to that.
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_win10_tweaks_for_user Dark
# set_gnome_ui_win10_tweaks_for_user Light
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Windows like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Windows-10-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Dark"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Windows-10-Light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Light'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Light"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background 'false'

	# Set wallpaper
	gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name Redmond.png)

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}






set_gnome_ui_corprate_crisp_tweaks_for_user ()
{
# Description: Function to set UI look to appeal to teh corporate or business user.
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_corprate_crisp_tweaks_for_user Dark
# set_gnome_ui_corprate_crisp_tweaks_for_user Light
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Crisp like tweaks..."

	GNOME_TERMINAL_PROFILE="$(gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}')"

	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Arc-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc-Dark"
			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name RTD_Wallpapers_HQ_Public_Domain_019.jpg)
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Arc ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc"
			gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name RTD_Wallpapers_HQ_Public_Domain_020.jpg)
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	if [[ -d /usr/share/icons/Arc-icon-theme ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Arc-icon-theme'
	else
			set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}









set_gnome_ui_moca_tweaks_for_user ()
{
# Description: Function to set UI look to be friendly on the eyes, limiting eye strain.
#
# Globals:
# Arguments: none
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_moca_tweaks_for_user
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Eye strain saving tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`

	if [[ -d /usr/share/themes/vimix-dark-doder ]] ; then
		gsettings set org.gnome.desktop.interface gtk-theme 'vimix-dark-doder'
		gsettings set org.gnome.shell.extensions.user-theme name "vimix-dark-doder"
		gsettings set org.gnome.desktop.background picture-uri file://$(find ${_OEM_DIR} -name Chocolate_brown_wallpaper.jpg)
	else
		set_gnome_ui_tweak_no_media_error
	fi

	if [[ -d /usr/share/icons/Flatery-Black-Dark ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Flatery-Black-Dark'
	else
		set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'

	# Configure terminal look...
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}










oem::register_wallpapers_for_gnome ()
{
# Description: Function to simplify registering wallpapers for Gnome.
#
# Globals:
# Arguments: /path/to/folder/with/wallpapers
# Outputs:
# Returns:
# Usage:
# oem::register_wallpapers_for_gnome  /path/to/folder/with/wallpapers
#
# End of documentation

	local _wallpaper_dir="${1:-"${_WALLPAPER_DIR}"}"

	# Make a header:
	echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
	<!DOCTYPE wallpapers SYSTEM \"gnome-wp-list.dtd\">
	<wallpapers>" > oem-backgrounds.xml

	# Registering all pictures in $_wallpaper_dir:
	for i in ${_wallpaper_dir}/*.jpg ${_wallpaper_dir}/*.png; do
	echo "<wallpaper>
	<name>$i</name>
	<filename>$i</filename>
	<options>stretched</options>
	<pcolor>#8f4a1c</pcolor>
	<scolor>#8f4a1c</scolor>
	<shade_type>solid</shade_type>
	</wallpaper>" >> oem-backgrounds.xml
	done

	# creating the footer:
	echo "</wallpapers>" >> oem-backgrounds.xml

	# Register all files:
	mkdir -p /usr/local/share/gnome-background-properties
	sed 's/<name>\/usr\/share\/backgrounds\//<name>/g' oem-backgrounds.xml > /usr/local/share/gnome-background-properties/oem-backgrounds.xml
	rm oem-backgrounds.xml
}








rtd_oem_turn_on_gui_network_management ()
{
# Description: Function to set NetworkManager by default to manage networking.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# The function expects no arguments.
# Usage:
# rtd_oem_turn_on_gui_network_management
#
# End of documentation

	if ls /usr/bin/*session ; then
		# backup any existing network yaml definitions:
		mkdir -p /etc/netplan/bak && mv /etc/netplan/*.yaml /etc/netplan/bak/

		# Create a new netplan for all interfaces:
		# Be careful with white spaces in yaml files!!!
		cat > /etc/netplan/01-network-manager-all.yaml <<- 'EOF'
		# Let NetworkManager manage all devices on this system
		network:
		  version: 2
		  renderer: NetworkManager

		EOF

		# Enable network manager:
		systemctl disable systemd-networkd
		systemctl enable  NetworkManager
		systemctl start  NetworkManager
		systemctl stop systemd-networkd
		systemctl restart  NetworkManager
	else
		write_error "No graphical session appear to be availabl in this system! Skipping netconfig..."
	fi
}






add_gnome3_favorite_app ()
{
# Description: Function to add a new favorite app to the gnome favorites bar.
# Globals: none
# Arguments: name of the shortcut to create (appname.desktop)
# Outputs:
# Returns: 0/1
# Usage: add_gnome3_favorite_app [appname.desktop]
#
# NOTE: This function must be run in the user context.
# End of documentation
# A potentioal simplification if the escapes cn be figured out:
# sudo -iu $SUDO_USER /bin/bash -c \" "gsettings set org.gnome.shell favorite-apps \\\"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\\$//), '${Newapp}']\\\"" \"
	NewApp="$1"
	if TMP_FIL=$(mktemp -p "$(mktemp -d )") ; then
		chown -R $SUDO_USER ${TMP_FIL%/*}
		sudo -iu  $SUDO_USER  echo "gsettings set org.gnome.shell favorite-apps \"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\$//), '${NewApp}']\"" >${TMP_FIL}
		sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus /bin/bash ${TMP_FIL}
		rm ${TMP_FIL}
	else
		return 1
	fi
}







system::run_command_in_gnome_user_session () {
# Description: Function to do a reverse sudo back to teh original Gnome user who called upon sudo.
# This functon expects any number of parameters that would make up the command or commands
# to be run in the users session. For example:
# 	system::run_command_in_gnome_user_session script_name.sh parameter one two etc
#
# Globals:
# Arguments: [path/script.sh] [bash command]
# Outputs:
# Returns:
# Usage: system::run_command_in_gnome_user_session script_name.sh
#
# End of documentation
	echo -------------------------- Begin as user: $SUDO_USER ---------------------
	echo "$*"
	sudo -H -u "$SUDO_USER" DISPLAY=$DISPLAY DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus $*
	echo " "
	echo -------------------------- End as user: $SUDO_USER   ---------------------
}





ensure_admin ()
{
# Description: Function to elevate priviledges of script execution and to ensure administrative privileges
# such that system wide settings or configuration may be done.
#
# This function evaluates and uses multiple ways to elevate priviledges based on the environment. In an
# X session; and normal GUI w. systemd: elevate privs with normal GUI policy kit, otherwise try dialog
# menu system and cached sudo, and finally fall back on good old sudo. Since scripts may be launched with
# a GUI front (for user interaction) end and NO terminal; it is really preferable to display a proper
# priviledge escalation propt in a GUI format and only use sudo in cases where there is a terminal or
# no other option is present.
#
# Should the function not discover an X session, then dialog will be preferred over regular sudo.
#
# Globals: $UID
# Arguments: None
# Outputs: GUI
# Dependencies: soft dependency on "dialog", will fall back on CLI if dialog is absent.
# Returns: relaunches script under sudo.
# Usage: The function expects no arguments, but will prompt for system password if required.
# Usage: ensure_admin
#
# End of documentation

	if [ ! "$UID" -eq 0 ]; then
		if xset q &>/dev/null; then
			# If X is running in this session then...
			if echo $(systemctl get-default ) |grep graphical &>/dev/null ; then
				# If we are a normal GUI w. systemd: elevate privs with normal GUI policy kit...
				write_information "Allowing root to display menus..."
				xhost local:root
				write_information "Authenticating..."
				pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY SUDO_USER=$USER "$(readlink -m ${0})"
				exit
			else
				# If we are some other kind of archane GUI then...
				write_information "Allowing root to display menus..."
				xhost local:root
				write_information "Checking for dialog..."
				if hash dialog 2>/dev/null ; then
					token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
					ret=$? ; clear
					case $ret in
						0)
							export HISTIGNORE='*sudo -S*'
							echo ${token} | sudo -S -v || ensure_admin
							sudo -E SUDO_USER=$USER /bin/bash "${0}" "$*" || rtd_oem_pause 1
						;;
						1) echo "Request cancelled" ;;
						255) echo "[esc] Request aborted" ;;
						* )  exit 1
					esac
					exit
				else
					# If we have some kind of X but not even "dialog" then...
					write_information "Dialog not found..."
					write_warning "This script needs administrative access..."
					xhost local:root
					sudo -E SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
					exit
				fi
			fi
		else
			# If there is no X in this session...
			write_information "No X server at \$DISPLAY [$DISPLAY]"
			# Use dialog if possible, otherwise just terminal...
			if hash dialog 2>/dev/null ; then
				token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
				ret=$? ; clear
				case $ret in
					0)
						export HISTIGNORE='*sudo -S*'
						echo ${token} | sudo -S -v || ensure_admin
						sudo -E SUDO_USER=$USER /bin/bash "${0}" "$@" || rtd_oem_pause 1
					;;
					1) echo "Request cancelled" ;;
					255) echo "[esc] Request aborted" ;;
					* )  exit 1
				esac
				exit
			else
				write_warning "This script needs administrative access..."
				sudo -E SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
				exit
			fi
		fi
	else
		if [[ ! -e /etc/pam.d/sudo ]] ; then
			#touch /etc/pam.d/sudo
			#echo 'session  optional       pam_xauth.so' > /etc/pam.d/sudo
			system::log_item "${FUNCNAME[0]} sudo:Administrative access granted to ${SUDO_USER:-"unknon user"} as requested by ${FUNCNAME[1]} ..."
		else
			#sed -i s/'# session  optional       pam_xauth.so'/'session  optional       pam_xauth.so'/g /etc/pam.d/sudo
			system::log_item "${FUNCNAME[0]} sudo:Administrative access granted to ${SUDO_USER:-"unknon user"} as requested by ${FUNCNAME[1]} ..."
		fi
	fi
}






rtd_oem_check_inet_access ()
{
# Description: Function to verrify internet availabiltiy.
# The funciton will pause for 10 seconds by default, and will accept
# an integer to indicate a non-decault time to pause.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_check_inet_access [ integer ]
#
# Example:
# rtd_oem_check_inet_access 60
#
# If an argument is omitted rtd_oem_check_inet_access will wait indefinitley
# for input.
#
# End of documentation
	_ARG=$1
	if ! hash curl &>/dev/null; then
		read -t 10 -p "N O T I C E ! --
		Could not check for internet connectivity...
		Please install (curl) web crawler/downloader.
		Press [ENTER] to continue and [CTRL] + [C] to exit! Continuing in 10 seconds..."
	else
		if [[ -z "$_ARG" ]]; then
			curl ipinfo.io &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
		else
			curl ipinfo.io &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
		fi
	fi
}






rtd_oem_kde_set_wallpaper ()
{
# Description:
# Function to set KDE Plasma wallpaper from a script. this function expects one variable
# indication what file to set as background. You must provide the full path to the file.
# rtd_oem_kde_set_wallpaper /opt/oem/wallpaper.png Supported fule types are:
# webm, mp4, png, jpeg, gif, webp.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	echo "Setting wallpaper $1"
	full_image_path=$(realpath "$1")
	ext=$(file -b --mime-type "$full_image_path")
	XDG_RUNTIME_DIR="/run/user/${SUDO_UID}"

	if [ -z "$2" ]; then
	# Identify filetype and make changes
	case $(echo $ext | cut -d'/' -f2) in
		"mp4"|"webm") type='VideoWallpaper' ; write='VideoWallpaperBackgroundVideo';;
		"png"|"jpeg"|"jpg") type='org.kde.image' ; write='Image' ;;
		"gif"|"webp") type='GifWallpaper' ; write="GifWallpaperBackgroundGif" ;;
	esac
	else
	type="$2";
	write="$3";
	fi

	wallpaper_set_script="var allDesktops = desktops();
	print (allDesktops);
	for (i=0;i<allDesktops.length;i++)
	{
		d = allDesktops[i];
		d.wallpaperPlugin = '${type}';
		d.currentConfigGroup = Array('Wallpaper', '${type}', 'General');
		d.writeConfig('Image', 'file:///dev/null')
		d.writeConfig('$write', 'file://${full_image_path}')
	}"

	# have to put in these stupid fixes because distros can't agree where to but stuff!
	hash qdbus || ${_qdbus="/usr/bin/qdbus-qt5" } && ${_qdbus="qdbus" }
	${_qdbus} org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "${wallpaper_set_script}"
	kwriteconfig5 --file kscreenlockerrc --group Greeter --group Wallpaper --group org.kde.image --group General --key Image "file://$full_image_path"
}








rtd_oem_setup_brand_splash_screen ()
{
# Description: Function to brand the installer splash screen for the customized installer
# downloaded from a ginve vendor. This function expects a few simple peices of information:
# parameter 1: full path to image file to be branded.
# parameter 2: quoted text to be incerted.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_setup_brand_splash_screen [string] [string]
#
# [string]: /path/to/imagefile.png, "text to brand image with"
#
# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
#
# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $tmp_disc_dir/splash.png ]; then
			echo "$tmp_disc_dir/splash.png"
		elif  [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		elif [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || write_error "Image [ $image_file_to_brand ] NOT branded!  "
	fi
}





system::prepare_environment_for_iso_creation ()
{
# Description: Function to check that all dependencies are available for manipulating the
# net install ISO from Ubuntu. Subsequently, the temporary file locations
# are setup and templates are downloaded.
#
# Several key software components are required to create ISO files (virtual DVD/CD/BlueRay)
# as well as a few others needed to download files from the internet, etc.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# DEPENDENCIES: dos2unix, cpio, gzip, genisoimage, whois, pwgen, wget, fakeroot, xorriso.
#
# This function will find full paths for the binaries needed since if they are recently
# added, they may not be found in the current $PATH.
#
#	Software PATH insurance:
#	: "${bin_7z:=$(type -P 7z)}"
#	: "${bin_xorriso:=$(type -P xorriso)}"
#	: "${bin_cpio:=$(type -P gnucpio || type -P cpio)}"
#	: "${bin_qemu_img:=$(type -P qemu-img)}"
#	: "${bin_kvm:=$(type -P kvm)}"
#	: "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
#	: "${put_iso_file_here_when_done:="/home/$SUDO_USER/Virtual-DVDs"}"
#	: "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
#	: "${VOLUME_TITLE:="RTD Auto Installer"}"
#	: "${ssh_public_key_file:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
#	: "${permanent_download_dir:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"
#
# The main tool to create ISO files system is "xorriso".
# [xorriso] copies file objects from POSIX compliant filesystems into Rock Ridge
# enhanced ISO 9660 filesystems and allows session-wise manipulation of such filesystems.
# It can load the management information of existing ISO images and it writes the session results
# to optical media or to filesystem objects.
#
# At this time this function expects no arguments.
#
# End of Documentation

        if [[ "$1" == "--cleanup" ]]; then
                for dir in "$tmp_download_dir" "$tmp_disc_dir" "$tmp_initrd_dir"; do
                if [ -z "$dir" ]; then
                        system::log_item "Warning: Directory variable is not set for the directory cleanup."
                fi

                if [ "$dir" = "/" ] || [[ "$dir" =~ ^/[^/]+/?$ ]] || [ "$dir" = "$HOME" ]; then
                        system::log_item "Error: Attempt to delete critical directory $dir"
                fi
                done

                unset bin_7z
                unset bin_xorriso
                unset bin_cpio
                unset bin_qemu_img
                unset bin_kvm
                unset bin_qemu_system_x86_64
                unset put_iso_file_here_when_done
                unset put_qcow_file_here_when_done
                unset VOLUME_TITLE
                unset ssh_public_key_file
                unset permanent_download_dir
                unset isohdpfx_bin
                unset current_dir
                unset script_dir
                unset tmp_download_dir
                unset tmp_disc_dir
                unset tmp_initrd_dir
                unset _dependencies
                return 0
        else
                system::log_item "Preparing environment for ISO creation..."

                : "${target_iso="$put_iso_file_here_when_done/$target_iso_file_name"}"
                if cat "/etc/os-release" | grep "debian" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-system libvirt-daemon-system"
                elif cat "/etc/os-release" | grep "fedora" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-system libvirt-daemon-system"
                elif  cat "/etc/os-release" | grep "suse" ; then
                        _dependencies="dos2unix cpio gzip genisoimage wget fakeroot xorriso isolinux qemu-x86 libvirt-daemon-qemu"
                else
                        write_error "Neither debian, fedora, or suse base distros or derivatives could be found; NOT installing dependencies."
                        return 1
                fi

                for i in $_dependencies; do check_dependencies $i ; done

                : "${bin_7z:=$(type -P 7z)}"
                : "${bin_xorriso:=$(type -P xorriso)}"
                : "${bin_cpio:=$(type -P gnucpio || type -P cpio)}"
                : "${bin_qemu_img:=$(type -P qemu-img)}"
                : "${bin_kvm:=$(type -P kvm)}"
                : "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
                : "${put_iso_file_here_when_done:="/home/$SUDO_USER/Virtual-DVDs"}"
                : "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
                : "${VOLUME_TITLE:="RTD Auto Installer"}"
                : "${ssh_public_key_file:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
                : "${permanent_download_dir:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

                system::log_item "Checking for presence of (isohdpfx.bin)..."
                if [[ -e /usr/lib/ISOLINUX/isohdpfx.bin ]]; then
                        : "${isohdpfx_bin:="/usr/lib/ISOLINUX/isohdpfx.bin"}"
                else
                        write_warning "An important file (isohdpfx.bin) was not found in the expected location. Attepting to workaround the issue..."
                        if hash locate 2>/dev/null ; then
                                locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 ; return 1 )
                                : "${isohdpfx_bin:=$(locate isohdpfx.bin  | head -n 1)}"
                                write_information "Found: $isohdpfx_bin"
                        else
                                check_dependencies plocate && ( write_warning "Updating file location DB, this may take a long time if there are a lot of files on the system..." ; updatedb )
                                locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 ; return 1 )
                                : "${isohdpfx_bin:=$(locate isohdpfx.bin  | head -n 1)}"
                                write_information "Found: $isohdpfx_bin"
                        fi
                fi

                if [[ ! -f "$ssh_public_key_file" ]] ; then
                        write_warning "Error: public SSH key $ssh_public_key_file not found!
                        You will need to setup automatic login using ssh manually each time you build a server with this media."
                fi

                current_dir="$(pwd)"
                script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                tmp_download_dir=$(mktemp -d )
                tmp_disc_dir=$(mktemp -d )
                tmp_initrd_dir=$(mktemp -d )

                for i in $put_qcow_file_here_when_done\
                        $put_iso_file_here_when_done\
                        $permanent_download_dir
                do
                        mkdir -p "$i" && chown "$SUDO_USER":"$SUDO_USER" "$i"
                done
        fi 
}







system::download_and_manipulate_iso_debian ()
{
# Description:
# system::download_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
# This is a simple command sequence to read the preference of distribution to install
# and what release to get... then download the network install file from debian
# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# system::download_and_manipulate_iso_debian [ISO Name] [Environment] [Addon Task]
#
# where [ISO Name] may be: any string to starte the file name with
# where [Environment] may be: any debian supported desktop environment
# where [Addon Task] may be: additional pre determined configuration
#
# EXAMPLE:
# system::download_and_manipulate_iso_debian openssh-server MinecraftTasks
# system::download_and_manipulate_iso_debian gnome-desktop
# system::download_and_manipulate_iso_debian xfce-desktop
#
# End of Documentation
        local _role=$1
	system::prepare_environment_for_iso_creation

	# Determine the name of the ISO file to create, and wich iso to download using default values if none are provided.
	# Capitlal variable names are generally global and set in the _loctations file.
	# Variables will be populated either from the default _locations file or detected.
	: "${_SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${_SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	: "${_CURRENT_DEB_ISO:="$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${target_iso_file_name="${_role:-"ssh-server"}-$_CURRENT_DEB_ISO"}"
	target_iso="$put_iso_file_here_when_done/$target_iso_file_name"
	iso_store="$put_iso_file_here_when_done/Downloaded/$_CURRENT_DEB_ISO"


	if [[ ! -f "$iso_store" ]]; then
		write_status "Geting install image..."
		write_information "Download: $_SOURCE_ISO_URL"
		wget -4  -q --show-progress "$_SOURCE_ISO_URL" -O "$iso_store" 
		write_information "Retreived: $(ls $iso_store)"
	fi

	$bin_7z x "$iso_store" "-o$tmp_disc_dir" || write_error  "FAILED to download and/or extract $_SOURCE_ISO_URL" 
	mkdir "$tmp_disc_dir/custom" && system::log_item "Created custom directory in $tmp_disc_dir" || write_error  "FAILED to create custom directory in $tmp_disc_dir"
	
	# write_status "Geting non-free firmware..."
	# write_information "Download: $_SOURCE_FIRMWARE"
	# wget -4  -q --show-progress "$_SOURCE_FIRMWARE" -O "$tmp_download_dir/firmware.zip" && ( mkdir "$tmp_disc_dir/firmware" & "$bin_7z" x "$tmp_download_dir/firmware.zip" "-o$tmp_disc_dir/firmware" )
	# write_information "Retreived: $(ls "$tmp_disc_dir"/firmware )"

	# Load the installation answers template.
	write_status "Getting intall instructions template... "
	system::make_preseed_cfg -a ask -p "$tmp_initrd_dir/" -r $_role || ( write_error "Failed to create preseed.cfg template" ; dialog::display_error "Something went wrong, please chack the logfile $_LOGFILE" )


	# ----------------------- Modify Boot Media --------------------------- #
	# Edit the grub.cfg file...
	#sed -i '/timeout/s/.*/set timeout=10/' "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i s/"menuentry --hotkey=g 'Graphical install' {"/"menuentry --hotkey=g 'Automatic Graphical install' {"/g "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i s/"menuentry --hotkey=i 'install' {"/"menuentry --hotkey=g 'Automatic install' {"/g "$tmp_disc_dir/boot/grub/grub.cfg"
	#sed -i '/insmod play/d' "$tmp_disc_dir/boot/grub/grub.cfg"
	sed -i 's/^[[:space:]]*set gfxmode=800x600$/  set gfxmode=1024x768/' "$tmp_disc_dir/boot/grub/grub.cfg"

	# Edit the gtk.cfg file...
	sed -i s/"menu label ^Graphical install"/"menu label ^Automatic Graphical install"/g "$tmp_disc_dir/isolinux/gtk.cfg"

	# Edit the txt.cfg file...
	sed -i s/"menu label ^Install"/"menu label ^Automatic Install"/g "$tmp_disc_dir/isolinux/txt.cfg"

	# Edit the spkgtk.cfg file...
	sed -i 's|ontimeout /install.amd/vmlinuz vga=788 initrd=/install.amd/gtk/initrd.gz speakup.synth=soft --- quiet|ontimeout /install.amd/vmlinuz vga=788 initrd=/install.amd/gtk/initrd.gz theme=dark --- quiet|' "$tmp_disc_dir/isolinux/spkgtk.cfg"

	dos2unix "$tmp_disc_dir/isolinux/isolinux.cfg"
	sed -i 's/^timeout 0$/timeout 100/' "$tmp_disc_dir/isolinux/isolinux.cfg"
	# --------------------------------------------------------------------- #

	write_status "Injecting created content into the new ISO..."
	pushd "$tmp_initrd_dir" || write_error "failed to enter init directory: $tmp_initrd_dir"
		write_status "# Modify the CLI Installer" 
		gzip -d -c "$tmp_disc_dir/install.amd/initrd.gz" > "./initrd"
		echo "./preseed.cfg" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
		find ./custom | fakeroot "$bin_cpio" -o -H newc -A -F ./initrd
		cat ./initrd | gzip -9c > "$tmp_disc_dir/install.amd/initrd.gz"
		rm "$tmp_initrd_dir/initrd"

		write_status "# Modify the GTK Installer"
		gzip -d -c  "$tmp_disc_dir/install.amd/gtk/initrd.gz"  > "./initrd"
		echo "./preseed.cfg" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
		find "./custom" | fakeroot "$bin_cpio" -o -H newc -A -F "./initrd"
		cat "./initrd" | gzip -9c > "$tmp_disc_dir/install.amd/gtk/initrd.gz"
	popd || (write_error  "Failed to popd"  & rtd_oem_pause 1)
	
        rtd_oem_setup_brand_splash_screen

}










create_iso_image_debian ()
{
# Description: Function to generate the new ISO file from the extracted and
# altered original ISO.
# Delete old iso file if there...
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	# Check for other input and create them if not defined...
	# : "${target_iso}"
	# : "${put_iso_file_here_when_done}"

	# Check for required input...
	# [[ -z "${target_iso}" ]] || rtd_oem_pause 1 "${FUNCNAME[0]} requires atleast one parameter."

	write_status "------ CREATING ISO: ${target_iso}    --------"
	if [ -f "${target_iso}" ]; then
		rm -f "${target_iso}"
	fi
	system::log_item "Creating ISO: ${target_iso}"

	pushd "$tmp_disc_dir" || system::log_item  "Failed to enter $tmp_disc_dir"
	[[ -e '[BOOT]' ]] && ( rm -r '[BOOT]' || system::log_item  "Failed to delete [BOOT] directory" )

	"$bin_xorriso" -as mkisofs -r \
		-V "${VOLUME_TITLE:-"Made by ${FUNCNAME[0]}"}" \
		-J -b "isolinux/isolinux.bin" \
		-c boot.cat \
		-no-emul-boot \
		-boot-load-size 4 \
		-boot-info-table \
		-input-charset utf-8 \
		-isohybrid-mbr "${isohdpfx_bin}" \
		-eltorito-alt-boot \
		-e boot/grub/efi.img \
		-no-emul-boot \
		-isohybrid-gpt-basdat -o "${target_iso}" ./ &>> "${_LOGFILE}" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
	chmod 777 "${target_iso}" &>>"${_LOGFILE}" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
        
        popd || write_error  "Failed to popd" 
	
        test_iso_boot_media "${target_iso}"
	
        if ${RTD_GUI} --yesno "Would you like to make a bootable thumbdrive from this ISO media?" "${HEIGHT}" "${WIDTH}" ; then
		create_physical_media_from_iso "${target_iso}" || create_physical_media_from_iso
	else
		return
	fi
	
	system::prepare_environment_for_iso_creation --cleanup
}















create_iso_image ()
{
# Description: Function to generate a bootable ISO file from source folder or an extracted and
# altered original ISO. The function takes 3 arguments: target file name, folder to use as source
# and volume title. The first argument is mandatory since it makes not sense unless it is known
# what source to use for makeing the ISO file.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# create_iso_image  ~/mybootablecdfolder ~/mybootable.iso "My cool bootable iso title"
#
# This function will over write the old iso file if there...
#
# End of Documentation

	# Check for required input...

	write_status "------ CREATING ISO: $target_iso    --------"
	if [ -f "$target_iso" ]; then
		rm -f "$target_iso"
	fi

	cd "$tmp_disc_dir" || echo "failed to enter $tmp_disc_dir "
	rm -r '[BOOT]'
	"$bin_xorriso" -as mkisofs -r -V "$VOLUME_TITLE" \
			-J -b isolinux.bin \
			-c boot.cat \
			-no-emul-boot \
			-boot-load-size 4 \
			-boot-info-table \
			-input-charset utf-8 \
			-isohybrid-mbr "$isohdpfx_bin" \
			-eltorito-alt-boot \
			-e boot/grub/efi.img \
			-no-emul-boot \
			-isohybrid-gpt-basdat \
			-o "$target_iso" ./ || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
	chmod 777 "$target_iso" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"

	system::prepare_environment_for_iso_creation --cleanup
}







create_physical_media_from_iso ()
{
# Description:
# Function to automatically write ISO (virtual DVD/CD/BlueRay) to a thumb drive. No argumenst are
# required, but a source ISO file location can may be provided when calling the function.
# If information is required, but not provided, the end user will be interactively prompted.
# This function requires elevated priviledges to be able to write media to a thumb drive
# (boot sector) and other system restrictied activities. If the function is NOT called in a
# script with elevated priviledges, it will attempt to elevate priviledges and prompt for a password.
# Since writing a new bootable thumb drive is inherrently an interactive activity; a prompt will
# be displayed asking what media to write to. If no media is present, a warning error
# message will be displayed.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# "create_physical_media_from_iso" or "create_physical_media_from_iso path/to/file.iso"
#
# NOTE:
# [Note 1] An ISO file, often called an ISO image, is a single file that's a perfect representation of an
# entire CD, DVD, or BD. The entire contents of a disc can be precisely duplicated in a single ISO file.
# An optical disc image (or ISO image, from the ISO 9660 file system used with CD-ROM media) is a disk image
# that contains everything that would be written to an optical disc, disk sector by disc sector, including the
# optical disc file system. ISO images are expected to contain the binary image of an optical media file system
# (usually ISO 9660 and its extensions or UDF), including the data in its files in binary format, copied exactly
# as they were stored on the disc. The data inside the ISO image will be structured according to the file system
# that was used on the optical disc from which it was created.
#
# [Note 2] A USB flash drive is a data storage device that includes flash memory with an integrated USB interface.
# It is typically removable, rewritable and much smaller than an optical disc. Most weigh less than 30 g (1 oz).
# Since first appearing on the market in late 2000
# End of documentation


	: ${BackTitle="Physical Installation Media Creator"}
	: ${Title="OS Media Manger"}

	if [ ! "$UID" -eq 0 ]; then
		# find  a diferent way... tempfile not universal...
		data=$(tempfile 2>/dev/null)
		trap "rm -f $data" 0 1 2 5 15
		dialog --title "${Title}" --backtitle "${BackTitle}" --insecure --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90 2> $data
		ret=$? ; clear
		case $ret in
			0) cat $data | sudo -S bash "$0" "$*" ;;
			1) echo "Request cancelled" ;;
			255) [ -s $data ] && rm $data &>/dev/null || echo "[esc] Request aborted" ;;
			* ) rm $data &>/dev/null ; exit 1
		esac
		rm $data &>/dev/null
		exit
	fi

	if [[ -z "$1" ]]; then
		[[ -d /home/${SUDO_USER}/Virtual-DVDs ]] && SuggestedFolder="/home/${SUDO_USER}/Virtual-DVDs/" || SuggestedFolder="/home/${SUDO_USER}"
		target_iso=$(dialog --stdout --title "${Title}" --backtitle "${BackTitle}" --fselect "${SuggestedFolder}" 15 110 2)
		UserResponse=$? ; clear
		case ${UserResponse} in
			  1) echo "Request cancelled"; return 0 ;;
			  255) echo "[ESC] key pressed."; return 255 ;;
		esac
	else
		target_iso=$1
	fi

	if [[ -z "${target_iso}" ]]; then
		DIALOGRC=~/.dialogrc
		if [[ -e ${DIALOGRC} ]]; then
			mv ${DIALOGRC} ${DIALOGRC}.bak
		fi

		echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
		dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n You must provide an ISO file as argument! \n Usage: ${0##*/} ~/filename.iso"  14 90
		clear ; rm ${DIALOGRC}

		if [[ -e ${DIALOGRC}.bak ]]; then
			mv ${DIALOGRC}.bak ${DIALOGRC}
		fi
		return 1
	else
		#          List removable dev : not loop dev: not CD    : not nvme HD : filter: header w. name
		devlist="$(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep -v nvme |grep 1 | cut -f1 -d' ')"

		if [[ -z ${devlist} ]]; then
			DIALOGRC=~/.dialogrc
			echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
			dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n No removable media could be found! Please insert a thumb drive and try again."  14 90
			clear ; rm ${DIALOGRC}
			return 1
		else
			declare -A RemovableMediaList
			index=1

			for media in ${devlist};
			do
				SuggestedRemovableDevice="${media}"
				RemovableMediaList[$index]=$(echo -e \'$(fdisk -l /dev/$media |head -1)\')
				(( index++ ))
			done

			DiscoveredItems="\n
			\n Removable media found: ${#RemovableMediaList[@]}
			\n --------------------------------------------------------

			$(until [ $i -gt ${#RemovableMediaList[@]} ]
			do
				[[ $i -gt 0 ]] && echo -e "Removable Disk $i:   ${RemovableMediaList[$i]} \n"
				((i=i+1))
			done
			)"

			USBTargetDevice=$( dialog --stdout --no-collapse --title "${Title}" --backtitle "${BackTitle}"  --inputbox "${DiscoveredItems}" 15 110 /dev/${SuggestedRemovableDevice} )
			Response=$?
			clear
			case ${Response} in
				0 )
					dialog --title "${Title}" --backtitle "${BackTitle}" --yesno "Please Confirm:\n Write the ISO file: \n ${target_iso} \n To the drive: \n ${USBTargetDevice}" 25 90
						case $? in
							0 ) ( dd if=${target_iso} of=${USBTargetDevice} status=progress 2>&1 |dialog --title "${Title}" --backtitle "${BackTitle}" --programbox "Please wait, writing disk now:" 25 90) ;;
							1 ) echo "Request cancelled"; create_physical_media_from_iso ;;
							255 ) echo "[ESC] key pressed."; return 255 ;;
							* ) echo "An unknown event occurred!" ; return 1 ;;
						esac
					clear ; return
				;;
				1 ) echo "Request cancelled"; return 0 ;;
				255 ) echo "[ESC] key pressed."; return 255 ;;
				* ) echo "An unknown event occurred!" ; return 1 ;;
			esac
			return
		fi
	fi
	return
}









rtd_oem_setup_brand_splash_screen()
{
# Description: Function to brand the installer splash screen for the customized installer
# downloaded from a ginve vendor. This function expects a few simple peices of information:
# parameter 1: full path to image file to be branded.
# parameter 2: quoted text to be incerted.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_setup_brand_splash_screen [string] [string]
#
# [string]: /path/to/imagefile.png, "text to brand image with"
#
# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
#
# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $tmp_disc_dir/splash.png ]; then
			echo "$tmp_disc_dir/splash.png"
		elif  [ -f $tmp_disc_dir/isolinux/splash.png ]; then
			echo "$tmp_disc_dir/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="RunTime Data OEM Install: $PREFERENCE"}"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || write_error "Image [ $image_file_to_brand ] NOT branded!  " 
	fi

        unset image_file_to_brand
        unset text_to_brand_with
}







rtd_oem_ubuntu_auto_install_iso_builder ()
{
# Description: Function to generate an edited ISO file from a folder.
# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# :: function name				:: target		:: iso version to download
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	desktop â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	live	â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	server	â­ creates auoinstall iso using the Ubuntu server dvd
#
# End of Documentation


	CONFIG=$1
	ISO_VER=$2
	system::prepare_environment_for_iso_creation

	write_information "Retreive list of available Ubuntu versions..."
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# Ask for desired version to use:
	ubuntu_ver=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... \n $picachu "  25 110 "${all[-1]}" 3>&1 1>&2 2>&3) ;clear
	[ "$ubuntu_ver" ] || ubuntu_ver=${all[-1]}

	write_information Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $ubuntu_ver ubuntu $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)

	write_status "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$permanent_download_dir" || read -p "Failure to download ISO file"
		iso="$permanent_download_dir/$ISO_FILENAME"
	fi

	mnt="${tmp_disc_dir:=$(mktemp -d )}"
	tmp_disc_dir=$mnt
	write_status "Mounting intallation media..."
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	write_status "Verifying media presence..."
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	write_information "Creating Installations media: $auto "
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	write_status "Modifying startup instructions...  "
		for f in splash.pcx splash.png ; do
			rtd_oem_setup_brand_splash_screen $auto/isolinux/$f
		done
		pushd ./$auto/isolinux/
			find splash.pcx | cpio -ov >>bootlogo
			find splash.png | cpio -ov >>bootlogo
		popd
	write_status "Unmounting $mnt... "
	umount $mnt || rtd_oem_pause 1


	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in live media... "
			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			system::make_preseed_cfg  $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in server image... "
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			system::make_preseed_cfg  $auto $CONFIG

		;;
	esac


	target_iso="$put_iso_file_here_when_done/$auto.iso"


	if [[ -f $target_iso ]]; then
		rm $target_iso
	fi

	$bin_xorriso -as mkisofs -isohybrid-mbr "$isohdpfx_bin" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$put_iso_file_here_when_done/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$put_qcow_file_here_when_done/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$target_iso" "$put_qcow_file_here_when_done/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}














system::process_vm_opt_args ()
{
# Description:
# Function to evaluate input fiven to a VM build finction and set configuration override variables. 
#
# Globals:
# Arguments: No[-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]ne
# Outputs:
# Returns: variables; _cpu _mem _dsk _task _role 
# Usage:
#
# system::process_vm_opt_args [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]
#
#	Supported overrides:
#	Role:   -r ${role}
#	Task:   -t ${CONFIG}
#	CPU:    -c ${_cpu} VCPU
#	Memory: -m ${_mem} GB
#	Disk:   -d ${_dsk} GB
#
#
# call from another function or script:
# 	system::process_vm_opt_args $@
#
# This will call this function and pass all parameters received here. Any parameters that match the expected
# format will set the variable accordingly. 
#
# End of documentation

	# Check for optional default T-Shirts size overrides... 
	write_information "Set custom values for VM T-Shirts sizes, tasks and roles..."
	local OPTIND o a
	while getopts ':c:m:d:t:r:*' OPTION; do
		case "$OPTION" in
		c )
			_cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			_mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			_dsk="${OPTARG}"
			write_information "Custom disk size set to: ${OPTARG}"
		;;
		t )
			_task="${OPTARG}"
			write_information "Custom task set to: ${OPTARG}"
		;;
		r )
			_role="${OPTARG}"
			write_information "Custom role set to: ${OPTARG}"
		;;
		? )
			write_information "Usage: ${FUNCNAME[1]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]"
			return 0
		;;
		*)
			echo "Using default VM settings..."
			return 0
		;;
		esac
	done
	unset OPTIND
}







system::find_download_ubuntu_iso ()
{

	ubuntu_flavor="${1}"
	write_information "ðŸ”Ž Retreive list of available $ubuntu_flavor versions..."
	case "$ubuntu_flavor" in
		ubuntu)
			declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$ubuntulogo"
		;;
		kubuntu)
			declare -a all_lts_versions=($(wget -O- cdimage.ubuntu.com/kubuntu/releases -q | perl -ne '/ (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$kubuntulogo"
		;;
		*)
			declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
			dist_logo="$ubuntulogo"
		;;
	esac

	tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor " --inputbox "\n ðŸ‘ Please pick an available \Z1 $ubuntu_flavor \Zn version by entering it below.
	Long Term Support Versions to choose from are the following:\Z4 ${all_lts_versions[*]} \Zn You may also enter an inbetween release version
	by typing its release number below as well. If you are not sure just let me choose intelligently for you... \n \Z1 ${dist_logo} \Zn"  30 90 "${all_lts_versions[-1]}" 3>&1 1>&2 2>&3)
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	[ "$tgt_ubuntu_ver" ] || tgt_ubuntu_ver=${all_lts_versions[-1]}

	: ${ubuntu_iso_url=$(rtd_oem_find_live_release $tgt_ubuntu_ver $ubuntu_flavor live)}
	: ${iso_filename:="$(basename $ubuntu_iso_url)"}
	: ${permanent_download_dir:="/var/lib/libvirt/boot/"}
	
	
	write_status "Checking if $iso_filename already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$iso_filename")
	if [ ! -e "$iso" ]; then
		write_warning "$iso_filename is not in cache, downloading..."
		wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "Failure to download ISO file"
		iso="$permanent_download_dir/$iso_filename"
	fi

}







system::create_physical_media_from_ubuntu_iso ()
{
# Description:
# Courtesy of 'covertsh':  ubuntu-autoinstall-generator
# Function to automatically write ISO (virtual DVD/CD/BlueRay) to a thumb drive. No argumenst are
# required, but a source ISO file location can may be provided when calling the function.
# If information is required, but not provided, the end user will be interactively prompted.
# This function requires elevated priviledges to be able to write media to a thumb drive
# (boot sector) and other system restrictied activities. If the function is NOT called in a
# script with elevated priviledges, it will attempt to elevate priviledges and prompt for a password.
# Since writing a new bootable thumb drive is inherrently an interactive activity; a prompt will
# be displayed asking what media to write to. If no media is present, a warning error
# message will be displayed.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# "system::create_physical_media_from_ubuntu_iso" or "create_physical_media_from_iso path/to/file.iso"
#
# End of documentation

	cleanup() {
		trap - SIGINT SIGTERM ERR EXIT
		if [ -n "${tmpdir+x}" ]; then
			rm -rf "$tmpdir"
			log "ðŸš½ Deleted temporary working directory $tmpdir"
		fi
	}

	trap cleanup SIGINT SIGTERM ERR EXIT
	script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
	[[ ! -x "$(command -v date)" ]] && echo "ðŸ’¥ date command not found." && exit 1
	today=$(date +"%Y-%m-%d")

	log() {
		write_host --cyan "[$(date +"%Y-%m-%d %H:%M:%S")] ${1-}"
	}

	die() {
		local msg=$1
		local code=${2-1} # Bash parameter expansion - default exit status 1. See https://wiki.bash-hackers.org/syntax/pe#use_a_default_value
		log "$msg"
		exit "$code"
	}

	usage() {
		create_physical_media_from_ubuntu_iso_usage="
		
		Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v] [-a] [-e] [-u user-data-file] [-m meta-data-file] [-k] [-c] [-r] [-s source-iso-file] [-d destination-iso-file]

		ðŸ’ This script will create fully-automated Ubuntu 20.04 Focal Fossa installation media.

		Available options:

		-h, --help              Print this help and exit
		-v, --verbose           Print script debug info
		-a, --all-in-one        Bake user-data and meta-data into the generated ISO. By default you will
					need to boot systems with a CIDATA volume attached containing your
					autoinstall user-data and meta-data files.
					For more information see: https://ubuntu.com/server/docs/install/autoinstall-quickstart
		-e, --use-hwe-kernel    Force the generated ISO to boot using the hardware enablement (HWE) kernel. Not supported
					by early Ubuntu 20.04 release ISOs.
		-u, --user-data         Path to user-data file. Required if using -a
		-m, --meta-data         Path to meta-data file. Will be an empty file if not specified and using -a
		-k, --no-verify         Disable GPG verification of the source ISO file. By default SHA256SUMS-$today and
					SHA256SUMS-$today.gpg in ${script_dir} will be used to verify the authenticity and integrity
					of the source ISO file. If they are not present the latest daily SHA256SUMS will be
					downloaded and saved in ${script_dir}. The Ubuntu signing key will be downloaded and
					saved in a new keyring in ${script_dir}
		-c, --no-md5            Disable MD5 checksum on boot
		-r, --use-release-iso   Use the current release ISO instead of the daily ISO. The file will be used if it already
					exists.
		-s, --source            Source ISO file. By default the latest daily ISO for Ubuntu 20.04 will be downloaded
					and saved as ${script_dir}/ubuntu-original-$today.iso
					That file will be used by default if it already exists.
		-d, --destination       Destination ISO file. By default ${script_dir}/ubuntu-autoinstall-$today.iso will be
					created, overwriting any existing file."
		echo $create_physical_media_from_ubuntu_iso_usage
	}


	parse_params() {
		# default values of variables set from params
		user_data_file=''
		meta_data_file=''
		ubuntu_flavor="ubuntu"
		dist_logo="$ubuntulogo"
		tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor " --inputbox "\n ðŸ‘ Please pick an available \Z1 $ubuntu_flavor \Zn version by entering it below.
		Long Term Support Versions to choose from are the following:\Z4 ${all_lts_versions[*]} \Zn You may also enter an inbetween release version
		by typing its release number below as well. If you are not sure just let me choose intelligently for you... \n \Z1 ${dist_logo} \Zn"  30 90 "${all_lts_versions[-1]}" 3>&1 1>&2 2>&3)
		case $? in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac
		clear
		: ${ubuntu_iso_url=$(rtd_oem_find_live_release $tgt_ubuntu_ver $ubuntu_flavor live)}
		download_url="https://cdimage.ubuntu.com/ubuntu-server/focal/daily-live/current"
		download_iso="focal-live-server-amd64.iso"
		original_iso="ubuntu-original-$today.iso"
		source_iso="${script_dir}/${original_iso}"
		destination_iso="${script_dir}/ubuntu-autoinstall-$today.iso"
		sha_suffix="${today}"
		gpg_verify=1
		all_in_one=0
		use_hwe_kernel=0
		md5_checksum=1
		use_release_iso=0

		while :; do
			case "${1-}" in
			-h | --help) usage ;;
			-v | --verbose) set -x ;;
			-a | --all-in-one) all_in_one=1 ;;
			-e | --use-hwe-kernel) use_hwe_kernel=1 ;;
			-c | --no-md5) md5_checksum=0 ;;
			-k | --no-verify) gpg_verify=0 ;;
			-r | --use-release-iso) use_release_iso=1 ;;
			-u | --user-data)
				user_data_file="${2-}"
				shift
				;;
			-s | --source)
				source_iso="${2-}"
				shift
				;;
			-d | --destination)
				destination_iso="${2-}"
				shift
				;;
			-m | --meta-data)
				meta_data_file="${2-}"
				shift
				;;
			-?*) die "Unknown option: $1" ;;
			*) break ;;
			esac
			shift
		done

		log "ðŸ‘¶ Starting up..."

		# check required params and arguments
		if [ ${all_in_one} -ne 0 ]; then
			[[ -z "${user_data_file}" ]] && die "ðŸ’¥ user-data file was not specified."
			[[ ! -f "$user_data_file" ]] && die "ðŸ’¥ user-data file could not be found."
			[[ -n "${meta_data_file}" ]] && [[ ! -f "$meta_data_file" ]] && die "ðŸ’¥ meta-data file could not be found."
		fi

		if [ "${source_iso}" != "${script_dir}/${original_iso}" ]; then
			[[ ! -f "${source_iso}" ]] && die "ðŸ’¥ Source ISO file could not be found."
		fi

		if [ "${use_release_iso}" -eq 1 ]; then
			download_url="https://releases.ubuntu.com/focal"
			log "ðŸ”Ž Checking for current release..."
			download_iso=$(curl -sSL "${download_url}" | grep -oP 'ubuntu-20\.04\.\d*-live-server-amd64\.iso' | head -n 1)
			original_iso="${download_iso}"
			source_iso="${script_dir}/${download_iso}"
			current_release=$(echo "${download_iso}" | cut -f2 -d-)
			sha_suffix="${current_release}"
			log "ðŸ’¿ Current release is ${current_release}"
		fi

		destination_iso=$(realpath "${destination_iso}")
		source_iso=$(realpath "${source_iso}")

		return 0
	}

	ubuntu_gpg_key_id="843938DF228D22F7B3742BC0D94AA3F0EFE21092"

	parse_params "$@"

	tmpdir=$(mktemp -d)

	if [[ ! "$tmpdir" || ! -d "$tmpdir" ]]; then
		die "ðŸ’¥ Could not create temporary working directory."
	else
		log "ðŸ“ Created temporary working directory $tmpdir"
	fi

	log "ðŸ”Ž Checking for required utilities..."
	[[ ! -x "$(command -v xorriso)" ]] && die "ðŸ’¥ xorriso is not installed. On Ubuntu, install  the 'xorriso' package."
	[[ ! -x "$(command -v sed)" ]] && die "ðŸ’¥ sed is not installed. On Ubuntu, install the 'sed' package."
	[[ ! -x "$(command -v curl)" ]] && die "ðŸ’¥ curl is not installed. On Ubuntu, install the 'curl' package."
	[[ ! -x "$(command -v gpg)" ]] && die "ðŸ’¥ gpg is not installed. On Ubuntu, install the 'gpg' package."
	[[ ! -f "/usr/lib/ISOLINUX/isohdpfx.bin" ]] && die "ðŸ’¥ isolinux is not installed. On Ubuntu, install the 'isolinux' package."
	log "ðŸ‘ All required utilities are installed."

	if [ ! -f "${source_iso}" ]; then
		log "ðŸŒŽ Downloading ISO image for Ubuntu 20.04 Focal Fossa..."
		curl -NsSL "${download_url}/${download_iso}" -o "${source_iso}"
		log "ðŸ‘ Downloaded and saved to ${source_iso}"
	else
		log "â˜‘ï¸ Using existing ${source_iso} file."
		if [ ${gpg_verify} -eq 1 ]; then
			if [ "${source_iso}" != "${script_dir}/${original_iso}" ]; then
				log "âš ï¸ Automatic GPG verification is enabled. If the source ISO file is not the latest daily or release image, verification will fail!"
			fi
		fi
	fi

	if [ ${gpg_verify} -eq 1 ]; then
		if [ ! -f "${script_dir}/SHA256SUMS-${sha_suffix}" ]; then
			log "ðŸŒŽ Downloading SHA256SUMS & SHA256SUMS.gpg files..."
			curl -NsSL "${download_url}/SHA256SUMS" -o "${script_dir}/SHA256SUMS-${sha_suffix}"
			curl -NsSL "${download_url}/SHA256SUMS.gpg" -o "${script_dir}/SHA256SUMS-${sha_suffix}.gpg"
		else
			log "â˜‘ï¸ Using existing SHA256SUMS-${sha_suffix} & SHA256SUMS-${sha_suffix}.gpg files."
		fi

		if [ ! -f "${script_dir}/${ubuntu_gpg_key_id}.keyring" ]; then
			log "ðŸŒŽ Downloading and saving Ubuntu signing key..."
			gpg -q --no-default-keyring --keyring "${script_dir}/${ubuntu_gpg_key_id}.keyring" --keyserver "hkp://keyserver.ubuntu.com" --recv-keys "${ubuntu_gpg_key_id}"
			log "ðŸ‘ Downloaded and saved to ${script_dir}/${ubuntu_gpg_key_id}.keyring"
		else
			log "â˜‘ï¸ Using existing Ubuntu signing key saved in ${script_dir}/${ubuntu_gpg_key_id}.keyring"
		fi

		log "ðŸ” Verifying ${source_iso} integrity and authenticity..."
		gpg -q --keyring "${script_dir}/${ubuntu_gpg_key_id}.keyring" --verify "${script_dir}/SHA256SUMS-${sha_suffix}.gpg" "${script_dir}/SHA256SUMS-${sha_suffix}" 2>/dev/null
		if [ $? -ne 0 ]; then
			rm -f "${script_dir}/${ubuntu_gpg_key_id}.keyring~"
			die "ðŸ‘¿ Verification of SHA256SUMS signature failed."
		fi

		rm -f "${script_dir}/${ubuntu_gpg_key_id}.keyring~"
		digest=$(sha256sum "${source_iso}" | cut -f1 -d ' ')
		set +e
		grep -Fq "$digest" "${script_dir}/SHA256SUMS-${sha_suffix}"
		if [ $? -eq 0 ]; then
			log "ðŸ‘ Verification succeeded."
			set -e
		else
			die "ðŸ‘¿ Verification of ISO digest failed."
		fi
	else
		log "ðŸ¤ž Skipping verification of source ISO."
	fi
	log "ðŸ”§ Extracting ISO image..."
	xorriso -osirrox on -indev "${source_iso}" -extract / "$tmpdir" &>/dev/null
	chmod -R u+w "$tmpdir"
	rm -rf "$tmpdir/"'[BOOT]'
	log "ðŸ‘ Extracted to $tmpdir"

	if [ ${use_hwe_kernel} -eq 1 ]; then
		if grep -q "hwe-vmlinuz" "$tmpdir/boot/grub/grub.cfg"; then
			log "â˜‘ï¸ Destination ISO will use HWE kernel."
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/isolinux/txt.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/isolinux/txt.cfg"
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/boot/grub/grub.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/boot/grub/grub.cfg"
			sed -i -e 's|/casper/vmlinuz|/casper/hwe-vmlinuz|g' "$tmpdir/boot/grub/loopback.cfg"
			sed -i -e 's|/casper/initrd|/casper/hwe-initrd|g' "$tmpdir/boot/grub/loopback.cfg"
		else
			log "âš ï¸ This source ISO does not support the HWE kernel. Proceeding with the regular kernel."
		fi
	fi

	log "ðŸ§© Adding autoinstall parameter to kernel command line..."
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/isolinux/txt.cfg"
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/boot/grub/grub.cfg"
	sed -i -e 's/---/ autoinstall  ---/g' "$tmpdir/boot/grub/loopback.cfg"
	log "ðŸ‘ Added parameter to UEFI and BIOS kernel command lines."

	if [ ${all_in_one} -eq 1 ]; then
		log "ðŸ§© Adding user-data and meta-data files..."
		mkdir "$tmpdir/nocloud"
		cp "$user_data_file" "$tmpdir/nocloud/user-data"
		if [ -n "${meta_data_file}" ]; then
			cp "$meta_data_file" "$tmpdir/nocloud/meta-data"
		else
			touch "$tmpdir/nocloud/meta-data"
		fi
		sed -i -e 's,---, ds=nocloud;s=/cdrom/nocloud/  ---,g' "$tmpdir/isolinux/txt.cfg"
		sed -i -e 's,---, ds=nocloud\\\;s=/cdrom/nocloud/  ---,g' "$tmpdir/boot/grub/grub.cfg"
		sed -i -e 's,---, ds=nocloud\\\;s=/cdrom/nocloud/  ---,g' "$tmpdir/boot/grub/loopback.cfg"
		log "ðŸ‘ Added data and configured kernel command line."
	fi

	if [ ${md5_checksum} -eq 1 ]; then
		log "ðŸ‘· Updating $tmpdir/md5sum.txt with hashes of modified files..."
		md5=$(md5sum "$tmpdir/boot/grub/grub.cfg" | cut -f1 -d ' ')
		sed -i -e 's,^.*[[:space:]] ./boot/grub/grub.cfg,'"$md5"'  ./boot/grub/grub.cfg,' "$tmpdir/md5sum.txt"
		md5=$(md5sum "$tmpdir/boot/grub/loopback.cfg" | cut -f1 -d ' ')
		sed -i -e 's,^.*[[:space:]] ./boot/grub/loopback.cfg,'"$md5"'  ./boot/grub/loopback.cfg,' "$tmpdir/md5sum.txt"
		log "ðŸ‘ Updated hashes."
	else
		log "ðŸ—‘ï¸ Clearing MD5 hashes..."
		echo > "$tmpdir/md5sum.txt"
		log "ðŸ‘ Cleared hashes."
	fi

	log "ðŸ“¦ Repackaging extracted files into an ISO image..."
	cd "$tmpdir"
	xorriso -as mkisofs -r -V "ubuntu-autoinstall-$today" -J -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin -boot-info-table -input-charset utf-8 -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "${destination_iso}" . &>/dev/null
	cd "$OLDPWD"
	log "ðŸ‘ Repackaged into ${destination_iso}"

	die "âœ… Completed." 0
}











compress_all_items_here ()
{
# Description: Function to compress the contents of the present working directory.
#
# Purpose:	To compress all files and folders individually found in the current folder.
#		The current folder refers to the present working directory "PWD". Compression method
#		is 7z. This privides a high level of compression.
#
# Globals:
# Arguments: --noprompt, --encrypt (mutually exclusive)
# Outputs:
# Returns:
# Usage:	compress_all_items_here [--compress] [--noprompt]
# Usage:	Simply call this function to accomplish this task.
#
# Arguments:	No parameters required for basic function (user will be prompted).
#
# End of documentation

	if hash 7z ; then
		write_information "7z is present, good..."
	else
		write_error "the 7z (7 zip) program was not found"
		for i in p7zip-full 7za
		do
			for i in dnf zypper apt-get ; do
				write_warning "Installing software requires elevated priviladges!"
				write_status "Peare enter password beloow (if not cached):"
				sudo $i install -y p7zip-full
			done
			exit 0
		done
	fi

	if [[ ! "$1" == "--noprompt" ]]; then
		if hash dialog 2>/dev/null ; then
			if ( dialog --backtitle "${BRANDING:-"${FUNCNAME[0]}"} ${1}" --title "Compress Content Here" --colors --cr-wrap --no-collapse --no-button "NO: Quit" --yes-button "YES: Compress" --yesno "Hello ${USER}... I am going to compress each file or folder that I find here: $(pwd) These are: \Z5 \n$(ls -h1 -F -I "*.7z")" 20 90 ); then
				clear
			else
				clear
				exit
			fi
		else
			clear
			write_host --cyan  "Hello ${USER}... I am going to compress each file or folder that I find in this folder. These are:"
			ls -I "*.7z" --color=always
			echo -e " \n"
			write_information "To cancel this, just close the terminal or press [CRTL] + [C]."
			read -p "Press the [ENTER] key to continue..."
		fi
	fi


	if echo ${*} |grep "encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" --stdout --insecure --passwordbox "\n Please provide a passphrase for the encryption. \n Please do not forget it!" 10 90 )
		ret=$? ; clear
		case $ret in
			0)
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $(ls -I "*.7z")
				do
					7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS
				result="
				\n Created the following archives encrypted with a pass-phrase:

				\n \Z1  $(ls *.7z)"
				display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		for line in $(ls -I "*.7z")
		do
			7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on $line.7z $line
		done
		IFS=$SAVEIFS
		result="
		Created the following archives un-encrypted:

		\n \Z1  $(ls *.7z)"
		display_result "Done Compressing"
	fi
}






compress_provided_items ()
{
# Description: Function to compress the contents of the present working directory.
#
# Purpose:	To compress all files and folders individually found in the current folder.
#		The current folder refers to the present working directory "PWD". Compression method
#		is 7z. This privides a high level of compression.
#
# Globals:
# Arguments: --noprompt, --encrypt (mutually exclusive)
# Outputs:
# Returns:
# Usage:	compress_provided_items [--encrypt] [--noprompt]
# Usage:	Simply call this function to accomplish this task.
#
# Arguments:	No parameters required for basic function (user will be prompted).
#
# End of documentation
list="$*"
	if echo "${@}" |grep "--encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" \
                  --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" \
                  --stdout \
                  --insecure \
                  --passwordbox "\n To encrypt the content you have to give me a phrase to encrypt it with. \n This can be anything in one long word, but never forget it!" \
                  10 90 )
		ret=$?
		case $ret in
			0)

				echo "â˜• Please be patient, Large sets of files may take serious time..."
				list="${list:9:1000}"
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $list ;
				do
					7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS

				result="
				\nâ™¹ Created the following archive(s) encrypted: \n
				\n STATUS	FILENAME
				$(
				echo \\n
				for d in $list; do
				[[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n"
				done
				)
				\n Please review the above: â«"
				display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		write_information "â˜• Please be patient, Large sets of files may take serious time..."

		for item in ${list} ;
		do
			case $item in
				--noprompt ) echo skipp >/dev/null ;;
				* ) 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on $item.7z $item ;;
			esac
		done

		IFS=$SAVEIFS
		result="
		Created the following archive(s): \n
		\n STATUS	FILENAME
		$(
		echo \\n
		for d in ${list} ; do
			case $d in
				--noprompt ) echo skipp >/dev/null ;;
				* ) [[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n" ;;
			esac
		done
		)
		\n Please review the above: â«"
		if echo ${*} |grep "--noprompt" ; then
			echo $result
		else
			display_result "Done creating encrypted archives"
		fi
	fi
}





# recompress_all_items_here ()
# {

# for i in *.zip ; do mkdir "${i::-4}" && unzip "${i}" -d ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done
# for i in *.rar ; do mkdir "${i::-4}" && unzip "${i}" -d ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done
# for i in *.rar ; do mkdir "${i::-4}" && rar x "${i}" ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done
# }


# recompress_provided_items ()
# {

# for i in *.zip ; do mkdir "${i::-4}" && unzip "${i}" -d ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done
# for i in *.rar ; do mkdir "${i::-4}" && unzip "${i}" -d ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done
# for i in *.rar ; do mkdir "${i::-4}" && rar x "${i}" ./"${i::-4}"/ && 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on  "${i::-4}.7z" "${i::-4}" && rm -r "${i::-4}" ; done

# }

create_swapfile ()
{
# Description: Function to create a swapfile and enable it automatically.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Usage: [function_name] [options]
# Arguments:
# 	[size] : size in MB or GB
# 	[path] : path to file (Default path: /swapfile)
#
# NOTE:
# The Linux Kernel divides RAM into chunks of memories and the swapping process is
# when the Linux Kernel uses a hard disk space (swap space) to store information from RAM
# and thus releases some RAM space. That is why when you install a Linux distribution, the
# installation wizard usually asks you to assign some space for the system and another for the swap.
#
# Using swap is a very useful way to extend the RAM because it provides the necessary additional
# memory when the RAM space has been exhausted and a process has to be continued. It is especially
# recommended when you have less than 1Gb of RAM. Although in the end, everything depends on you.
# 
# End of documentation


	SWAP_SIZE=$1
	SWAP_PATH=$2



	: "${SWAP_SIZE:=4G}"
	: "${SWAP_PATH:="/swapfile-${RANDOM}"}"

	write_information "Swap Size: ${SWAP_SIZE}"
	write_information "File Path: ${SWAP_PATH}"

	usage_mesage () {
		write_host --blue "
		Usage: $0 {size}
		Example: $0 4G
		(Default path: /swapfile)
		Usage with optional path: $0 {size} {path}"
	}

	if [[ -z "${SWAP_SIZE}" ]]; then
		# If we are not given any size to make the swaptfile... well...
		write_error "Please tell me what size swap file to make!" 
		usage_mesage
		exit 1
	elif [[ ! "${SWAP_SIZE:0:1}" -ge "1" ]]; then
		# Fail if the argument is not a numer
		write_error "The size for swap file must be a number!" 
		usage_mesage
		exit 1
	else
		if [[ -e ${SWAP_PATH} ]]; then
			write_error "ERROR: the file ${SWAP_PATH} already exists! Please choose a different name."
			exit 1
		fi
		write_host --cyan "Welcome to Swap setup script! This script will automatically setup a swap file and enable it."

		fallocate -l "${SWAP_SIZE}" "${SWAP_PATH}"	&& write_information "Allocated ${SWAP_SIZE} swap file: ${SWAP_PATH}" || (write_error "Error creting actual swapfile using fallocate! "; exit 1)
		chmod 600 "${SWAP_PATH}"			&& write_information "Sucessfully modified permissions on $SWAP_PATH" || (write_error "Error changing premissions" ; exit 1)
		mkswap "${SWAP_PATH}"				&& (write_status "Sucessfully formatted ${SWAP_PATH} as a swap partition" ; file -s ${SWAP_PATH}) || (write_error "Error formating ${SWAP_PATH} as a swapspace!" ; exit 1)
		swapon "${SWAP_PATH}" 				# Turn on the swap file...
		if [ $? = 0 ]; then
			echo "${SWAP_PATH}   none    swap    sw    0   0" | sudo tee /etc/fstab -a # Add to fstab
			write_status "Done! You now have a ${SWAP_SIZE} swap file at ${SWAP_PATH}"
		else
			if df -T ${SWAP_PATH} |grep btrfs >/dev/null ; then
				write_error "ERROR: swapfiles cannot be allocated on BTRFS. \n The root filesystem is BTRFS. Please use an ext4 or xfs partition.
				This is a BUG and hopefully it will be fixed soon... "
				exit 1
			else
				write_error "An unknown error occurred with starting the swap partition.."
				exit 1
			fi
		fi

	fi
}







scan_for_malware ()
{
# Description: This function uses clam AV to scan for malware in a given location.
# Globals: None.
# Arguments: None
# Outputs: STDOUT
# Returns: STDERR & STDOUT
# Usage: scan_for_malware /directory/to/scan
#
# End of documentation

	# Set the location of the quarantined files
	QUARANINE=~/VIRUS
	if [ ! -d "$QUARANINE" ]; then
		mkdir "$QUARANINE"
	fi

	# set the location of the log file
	CLAMSCANLOGFILE=~/clamscan.log
	SCANDIR=$@

	# First discover what menu system is installed. Some systems use "dialog" and
	# other systems use whiptail for the terminal to show menus and dialogs.

	if ! type clamscan ; then
		check_dependencies clamscan && exit
	fi




	write_host --purple "
	___________________________________________________

	[   Setting    ] [           Value             ]
	Logging to:         $CLAMSCANLOGFILE
	Quarantine in:      $QUARANINE

	___________________________________________________
	Starting scan....
	Scanning folder: ${*}"

	# Run the scan function
	clamscan $SCANDIR -r -a -i -l $CLAMSCANLOGFILE --bytecode=yes --stdout  --phishing-sigs --bell --algorithmic-detection=yes --move="$QUARANINE"
	return $?
}





















#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#                  .88888888:.
#                 88888888.88888.
#               .8888888888888888.
#               888888888888888888
#               88' _`88'_  `88888
#               88 88 88 88  88888
#               88_88_::_88_:88888
#               88:::,::,:::::8888
#               88`:::::::::'`8888
#              .88  `::::'    8:88.
#             8888            `8:888.
#           .8888'             `888888.
#          .8888:..  .::.  ...:'8888888:.
#         .8888.'     :'     `'::`88:88888
#        .8888        '         `.888:8888.
#       888:8         .           888:88888
#     .888:88        .:           888:88888:
#     8888888.       ::           88:888888
#     `.::.888.      ::          .88888888
#    .::::::.888.    ::         :::`8888'.:.
#   ::::::::::.888   '         .::::::::::::
#   ::::::::::::.8    '      .:8::::::::::::.
#  .::::::::::::::.        .:888:::::::::::::
#  :::::::::::::::88:.__..:88888:::::::::::'
#   `'.:::::::::::88888888888.88:::::::::'
#         `':::_:' -- '' -'-' `':_::::'`
# ----------------------------------------------------------------
#  ____         __ _
# / ___|  ___  / _| |___      ____ _ _ __ ___
# \___ \ / _ \| |_| __\ \ /\ / / _` | '__/ _ \
#  ___) | (_) |  _| |_ \ V  V / (_| | | |  __/
# |____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___|
#
#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
# ----------------------------------------------------------------








software::package_kit::add_package ()
{
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This function should work consistently 
# on any distribution with the back end:     
#     Advanced Packaging Tool (APT)
#     Conary
#     libdnf[10] & librepo,[11] the libraries upon which DNF, (the successor to yum) builds
#     Entropy
#     Opkg
#     pacman
#     PiSi
#     Portage
#     Smart Package Manager
#     urpmi
#     YUM
#     ZYpp
# PackageKit is a free and open-source suite of software applications designed to provide a 
# consistent and high-level front end for a number of different package management systems. 
# PackageKit was created by Richard Hughes in 2007,[2][3] and first introduced into an 
# operating system as a default application in May 2008 with the release of Fedora 9.[4]
# 
# The suite is cross-platform, though it is primarily targeted at Linux distributions which 
# follow the interoperability standards set out by the freedesktop.org group. It uses the 
# software libraries provided by the D-Bus and Polkit projects to handle inter-process 
# communication and privilege negotiation respectively. 
# Arguments: package_name
# Outputs:
# Returns: Does not return error as it is designed for best effort smooth operation.  
# Usage: Call the function with one arguments matching then name of the package you need to install.
#
# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}
	
	if pkcon resolve "${1}" --filter installed | grep "${1}" &>/dev/null ; then
		write_status "The software package ${1} is Allready installed... " 
		system::log_item "The software package ${1} is Allready installed... "
	else
		if pkcon resolve "${1}" | grep "${1}" &>/dev/null; then
			write_status "The software package ${1} found in repository, installing... "
			system::log_item "The software package ${1} found in repository, installing... "
			pkcon install "${1}" --noninteractive --cache-age 5000 
			if [ $? = 0 ] ; then
				write_status "The software package ${1} transaction appears to have been sucessful..."
				system::log_item "The software package ${1} transaction appears to have been sucessful..."
			else
				write_warning "There appears to have been some problem installing the package ${1}..."
				system::log_item "There appears to have been some problem installing the package ${1}..."
			fi
		else
			write_error "The software package ${1} is not available in any configured repository..." 
			system::log_item "The software package ${1} is not available in any configured repository..." 
		fi	
	fi

}






software::package_kit::remove_package ()
{
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpak
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpak. A preference order between package system and
# snap or flatpak use.
# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}

	(
	if pkcon resolve "${1}" --filter installed | grep "${1}" &>/dev/null ; then
		write_status " âœ“ The software package ${1} is installed, removing as requested... "
		pkcon remove "${1}" --noninteractive
		if [ $? = 0 ] ; then
			write_status "The software package ${1} transaction appears to have been sucessful..."
		else
			write_warning "There appears to have been some problem removing the package ${1}..."
		fi
	else
		write_information "The software package ${1} is not installed, no need for action..." 
	fi
	) | tee ${_LOGFILE}
}









software::ensure_software_store_available ()
{
# Description: Function to ensure that flatpak is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# GNOME Software is a utility for installing applications and updates on Linux.
# It is part of the GNOME Core Applications, and was introduced in GNOME 3.10.[3]
#
# It is the GNOME front-end to the PackageKit, in turn a front-end to several package management
# systems, which include systems based on both RPM and DEB.
#
# The program is used to add and manage software repositories as well as Ubuntu
# Personal Package Archives (PPA). Ubuntu replaced its previous Ubuntu Software Center
# program with GNOME Software starting with Ubuntu 16.04 LTS,[5] and re-branded it as "Ubuntu Software".
#
# It also supports fwupd for servicing of system firmware.[6]
#
# GNOME Software removed Snap support in July 2019, due to code quality issues, lack of integration
# (specifically, the user can't tell what snap is doing after they click "install" and that it
# generally ignores GNOME's settings), and the fact that it competes with the GNOME-supported Flatpak standard.[7]
#
# End of documentation


	case "$DESKTOP_SESSION" in
		plasma )
			# If we find any plasma session then install the plasma store addons...
			write_information "${FUNCNAME[0]}: plasma on anything..".
			check_dependencies plasma-discover
			check_dependencies plasma-discover-backend-flatpak
			check_dependencies plasma-discover-backend-snap
		;;
		"/usr/share/xsessions/default" )
			# Special case for suse again...
			if cat /usr/share/xsessions/default.desktop |grep "Plasma"  ; then
				write_information "${FUNCNAME[0]}: kde on suse"
				check_dependencies plasma-discover
				check_dependencies plasma-discover-backend-flatpak
				check_dependencies plasma-discover-backend-snap
			else
				write_information "${FUNCNAME[0]}: gnome on suse"
				check_dependencies gnome-software
				check_dependencies gnome-software-plugin-flatpak
				check_dependencies gnome-software-plugin-snap
			fi
		;;
		* )
			# in any other case, install the gnome versions of store and plugins... 
			write_information "${FUNCNAME[0]}: case = *"
			check_dependencies gnome-software
			check_dependencies gnome-software-plugin-flatpak
			check_dependencies gnome-software-plugin-snap
		;;
	esac

}







ensure_flatpak_package_managment ()
{
# Description: Function to ensure that flatpak is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Like Snap, Flatpak is another distribution independent package format aimed to simplify overall
# app distribution and usage in Linux systems. Previously known as xdg-app, the framework was based
# on the concept of running applications in a secure virtual sandbox without requiring root privileges
# or posing a security threat to the system.
# Flatpak was officially released in 2015 with a reliable backup from Red Hat, Endless Computers, and
# Collabora. It targeted primarily three Desktop Environments. That is FreeDesktop, KDE, and GNOME. The
# Linux distributions currently having this framework are arch Linux, Debian, Fedora, Mageia,
# Solus, and Ubuntu.The Flatpak framework itself is developed in C programming and released under the
# LGPL license. The lead developer is Alexander Larsson â€“ a Red Hat employee. Like Snapcraft for Snap,
# Flatpak also has the Flathub app store where users can find and install all Flatpak packages.
# Initially, Flathub only allowed open-source publishing applications on the website but
# has recently approved the publishing of proprietary apps.
# Additionally, unlike Snap, where we have a single repository controlled by Canonical to install and update
# software packages, Flatpak supports the use of multiple repos. The one significant disadvantage with this
# package is the lack of support for Servers.
#
#	*	---       PREFFERRED Software install (Security + Control)           ----		*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation
	if [[ $(echo "$OSTYPE" |grep "linux") ]] &>/dev/null ; then
		# these tests focus on the latest versions of the distros evaluated...
		write_information "Ensuring flatpak software distribution system is available..."
		if hash flatpak &>/dev/null ; then
			write_status "flatpak command is available... "
			if flatpak remotes | grep flathub  &>/dev/null ; then 
				write_status "flathub remote is present..."
				export PATH=$PATH:/var/lib/flatpak/exports/bin
			else
				write_warning "flathub remote is not present... adding now... "
				ensure_admin
				flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || write_error "Failed to add flatpak repo!"
				export PATH=$PATH:/var/lib/flatpak/exports/bin
			fi

			if flatpak list|grep com.github.tchx84.Flatseal  &>/dev/null ; then 
				write_status "flatseal security management is also present..."
			else
				ensure_admin
				write_status "flatseal security manager not found, adding now..."
				flatpak install flathub com.github.tchx84.Flatseal --noninteractive -y
			fi
		else
			ensure_admin
			write_information "Ensuring Flatpak software distribution system is available..."
			if check_dependencies flatpak ; then
				flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || write_error "Failed to add flatpak repo!"
				export PATH=$PATH:/var/lib/flatpak/exports/bin			
			else
				write_error "Failed to satisfy dependecy flatpak!"
			fi
			
			if flatpak list|grep com.github.tchx84.Flatseal  &>/dev/null ; then 
				write_status "flatseal security management is also present..."
			else
				ensure_admin
				write_status "flatseal security manager not found, adding now..."
				flatpak install flathub com.github.tchx84.Flatseal --noninteractive -y
			fi
			return $?
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported with snap... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported with snap... " ; return 1
	else
		echo "I have no Idea what this system is" ; return 1
	fi
}





ensure_snap_package_managment ()
{
# Description: Function to ensure that snap is installed.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs: stdout
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE:
# https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Snap is a distribution independent package format developed by Canonical and first released
# in 2014. It was initially developed for Ubuntu but has been adopted by other Linux distributions
# like Arch, Linux Mint, CentOS, Gentoo, and Fedora, and also included support for the Snap
# framework. The main aim behind this package format development was to come up with a
# single unified format for software packages to run in a wide range of devices.
# That includes IoT (IoT), embedded devices running Ubuntu Core (a minimalistic
# version of Ubuntu), and computer systems that ran some Ubuntu version.
# Snap also offers an online app store â€“ Snapcraft, where users can find and
# install the software packages. It creates a large pool where users can find all
# available a snap package. Snapcraft is itself controlled and maintained by the
# Canonical team.
#
#
#	*	---   PREFFERRED Software install (Security + Control)        ----	*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation


	if [[ $(echo "$OSTYPE" |grep "linux") ]] &>/dev/null ; then
		# these tests focus on the latest versions of the distros evaluated...
		system::log_item "ensuring SNAP software distribution system is available..."
		if hash snap &>/dev/null ; then
			system::log_item "Snap is already present..."
			if [[ -e /snap ]]; then
				system::log_item "SNAP classic support present... "
				return $?
			else
				system::log_item "SNAP classic support NOT present... "
				system::log_item "adding links... "
				ln -s /var/lib/snapd/snap /snap
				return $?
			fi
		else
			if hostnamectl |grep "SUSE" 2>/dev/null ; then
				system::log_item "Special case for suse..."
				ensure_admin
				if hostnamectl |grep -i "tumbleweed" ; then
					local _repo=$(echo https://download.opensuse.org/repositories/system:/snappy/openSUSE_Tumbleweed snappy)
					system::log_item "Detected OpenSUSE Timbleweed. Adding repo: ${_repo}"
					zypper addrepo --refresh "${_repo}"
				else
					_repo=$(echo https://download.opensuse.org/repositories/system:/snappy/openSUSE_Leap_$(cat /etc/os-release |grep VERSION_ID |cut -d= -f2|cut -d\" -f2) snappy)
					system::log_item "Detected OpenSUSE Leap. Adding repo:${_repo}"
					zypper addrepo --refresh "${_repo}"
				fi
				zypper --gpg-auto-import-keys refresh || ( write_error "Failed to gpg keys!" ; return 1 ) 
				zypper dup --from snappy || ( write_error "Failed to update snap repository!" ; return 1 )
				check_dependencies snapd || ( write_error "Failed to satisfy dependecy SNAP!" ; return 1 )
				systemctl enable snapd ; systemctl start snapd
				systemctl is-active --quiet snapd || ( write_error "Service snapd not started sucessfully!" ; return 1 )
				ln -s /var/lib/snapd/snap /snap
				return $?
			else
				# For distributions that do not need to add a repository to install snap
				# But would need to install it from their standard reopsitory....
				if check_dependencies snapd ; then
					systemctl enable snapd ; systemctl start snapd
					echo snapd is $(systemctl is-active snapd) || return 1
					if [[ -e /snap ]]; then
						write_information "SNAP classic support present... "
					else
						ln -s /var/lib/snapd/snap /snap
					fi
					return $?
				else
					write_error "Failed to satisfy dependecy SNAP!"
				fi
			fi
		fi	

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported with snap... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported with snap... " ; return 1
	else
		echo "I have no Idea what this system is" ; return 1
	fi
}





up_2_date ()
{
# Description: Function to simplify updating system completely. At present this function sets the
# highest preference to use "pkcon", the command line interface of "Package Kit" since
# this is the most consistent across different distrbutions. It may even work on BSD.
# Only if "pkcon" is not available, will the function use the identified distro native
# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may
# alias another distributions command (like SuSE does with apt) to be helpfull.
# This is one of the first update functions written and is kept for compatibility.
# Globals:
# Arguments: None
# Outputs:
# Returns: 0/1/3 where 1/0 = sucess/fail and 3 = package manager NOT found
# Usage: up_2_date
# End of documentation
	ensure_admin
	write_status "Running up2date function:"

	if hash pkcon 2>/dev/null; then
		pkcon update -y
	elif hash yum 2>/dev/null; then
		yum update -y
	elif hash apt 2>/dev/null; then
		apt-get update
		apt-get upgrade -y
		apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		zypper --terse --color --table-style=6 list-updates
                zypper --terse --color --table-style=6 update -y
	else
		return 3
	fi
}






system_config::tune_system_power_profile ()
{
# Description: Tuned is a Linux feature that monitors a system and optimizes its performance
# under certain workloads. Tuned uses profiles to do this. A profile is a set of rules that
# defines certain system parameters such as disk settings, kernel parameters, network
# optimization settings, and many other aspects of the system.
#
# This function sets the performance according to laptop/desktop/vm based on what is detected.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: simply call function in a script
# End of documentation

	check_dependencies tuned
	systemctl enable --now tuned
	tuned-adm profile balanced

	case "${1}" in
		--quiet | -q ) : ${_print="#"} ;;
		* ) unset _print ;;
	esac

	check_dependencies virt-what
	check_dependencies laptop-detect
	if virt-what ; then
		"${_print}" write_information "${FUNCNAME[0]}: This is likely not running in a virtual machine."
		if laptop-detect ; then
			"${_print}" write_information "${FUNCNAME[0]}: This is likely a laptop; applying pwersave profile..."
			tuned-adm profile powersave
		else
			"${_print}" write_information "${FUNCNAME[0]}: This is likely NOT a laptop; applying desktop profile..."
			tuned-adm profile desktop
		fi
	else
		"${_print}" write_information "${FUNCNAME[0]}: This is likely a VM; applying virtual-guest profile..."
		tuned-adm profile virtual-guest
	fi
}




oem::check_boot_splash_screen_enable () {
# Description: OEM function to enable splash screen on boot if desktop is indicated in
# a configuration file. This file could be an AutoYast.xml, or ks.cfg, or a preseed.cfg.
#
# Globals:
# Arguments: [FILE]
# Outputs:
# Returns: error level
# Usage: oem::check_boot_splash_screen_enable /root/original-ks.cfg
# End of documentation
	if [[ -n "$1" ]] ; then
		if [[ -r "$1" ]] ; then
			if cat $1 |grep -i "desktop" ; then
				check_dependencies splash
				echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"'>> /etc/default/grub
				update-grub
				
			fi
		fi
	fi
}




is_software_package_installed ()
{
# Description: Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Globals:
# Arguments: None
# Outputs:
# Returns: 1/0 where 0 = package is installed/1 = package is NOT installed
# Usage:
# Call this function by:
# is_software_package_installed "package name"
#                 or
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash dnf &> /dev/null; then
		rpm -q "$1" &> /dev/null && return 0 || return 1
	elif hash zypper &> /dev/null; then
		zypper se -i "$1" &> /dev/null || return 1 && return 0 
	elif hash apt &> /dev/null; then
		dpkg -l "$1" |tail -1 |grep "ii  $1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi
}




software::is_native_package_installed ()
{
# Description: Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Globals:
# Arguments: None
# Outputs:
# Returns: 1/0 where 0 = package is installed/1 = package is NOT installed
# Usage:
# Call this function by:
# software::is_native_package_installed "package name"
#                 or
# software::is_native_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash dnf &> /dev/null; then
		rpm -q "$1" &> /dev/null && return 0 || return 1
	elif hash zypper &> /dev/null; then
		zypper se -i "$1" &> /dev/null || return 1 && return 0 
	elif hash apt &> /dev/null; then
		dpkg -l "$1" |tail -1 |grep "ii  $1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi
}



is_software_package_available ()
{
# Description: Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		if zypper se "${1}" |grep "${1}" &> /dev/null ; then return 0 ; else return 1 ; fi
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" | grep -q "$1" 2>/dev/null  && return 0 || return 1
	else
		return 3
	fi
}



software::is_native_package_available ()
{
# Description: Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		if zypper se "${1}" |grep "${1}" &> /dev/null ; then return 0 ; else return 1 ; fi
	elif hash apt 2>/dev/null; then
		apt-get -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	else
		return 3
	fi
}



InstallSoftwareFromRepo ()
{
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpak
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpak. A preference order between package system and
# snap or flatpak use.
# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}
	# Ask function how to install software...
	set_install_command &>>"${_LOGFILE}"

	# make some decent display terminal Graphics...
	PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "${1}"; then
		if is_software_package_available "${1}"; then
			printf "${PRE}" & software::add_native_package "${1}" &>>${_LOGFILE} && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR " ||   printf "%b%-6s%b [ ! ] ${RED} FAILED ${ENDCOLOR}"
			#term::animate_while_command "$_INSTCMD ${1}" 
			if [ $? != 0 ];
			then
				return 1
			fi
		else
			echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Not available... $ENDCOLOR \n" && return 1
		fi
	else
		echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Allready installed... $ENDCOLOR \n"
	fi
}




software::add_native_package ()
{
# Description:
# add global install command for portability and convenience. This function
# allows for scripts to add software across many systems.
# Primarily for Linux: this function will look for the common package managers
# apt (all debina and ubuntu based distributions), dnf (RedHat, Fedora, Mandriva, and others)
# zypper (SuSE and Open SUSE). If neither of those package manages are available many systems
# use package kit; and this will be registered as an sinstall option.
#
# Globals:
# Arguments: package_name
# Outputs:
# Returns:
# Usage: "software::add_native_package <package_name> <package_name> <...n>"
#
#
# Return Codes:
# 
# A return code of "1" will be returned the function was not able install the package.
#
#
# End of documentation

        if [[ $(echo $OSTYPE | grep "linux") ]]; then
		if hash zypper 2>/dev/null; then
			write_status  "Installing ${1} using ZYPPER"
			sudo zypper install -y ${1}
			return $?
		elif hash apt 2>/dev/null; then
			write_status  "Installing ${1} using DEB"
			sudo apt-get -y install ${1}
			return $?
		elif hash dnf 2>/dev/null; then
			write_status "Installing ${1} using DNF"
			sudo dnf -y install ${1}
			return $?
		elif hash pkcon 2>/dev/null; then
			write_status  "Installing ${1} using Package Kit..."
			pkcon install -y ${1}
			return $?
		else
			write_error "This system does not seem to have a software managment system"
			return 1
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		return 1
	fi
	return $?
}





set_install_command ()
{
# Description:
# add global install command for portability and convenience. This function
# allows for scripts to add software across many systems.
# Primarily for Linux: this function will look for the common package managers
# apt (all debina and ubuntu based distributions), dnf (RedHat, Fedora, Mandriva, and others)
# zypper (SuSE and Open SUSE). If neither of those package manages are available many systems
# use package kit; and this will be registered as an sinstall option.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: "set_install_command"
#
# Arguments: none.
#
# Return Codes:
# set_install_command will return a global variable ${_INSTCMD}
# ${_INSTCMD} will expand to teh appropriate install cmmand including options
# for non interactive install of a package. ${_INSTCMD} package.name will install said pacakge.
#
# A return code of "1" will be returned the function was not able to set the install command.
#
#
# End of documentation

                if [[ $(echo $OSTYPE |grep "linux") ]]; then

		if hash dnf 2>/dev/null; then
			# Try dnf (RedHat, Cent OS, Fedora)
			write_status "Setting install options for DNF"
			export _INSTCMD="sudo dnf -y  install"
		elif hash zypper 2>/dev/null; then
			# Try zypper (Open SUSE)
			write_status  "Setting install options for ZYPPER"
			export _INSTCMD="sudo zypper install -y "
		elif hash apt 2>/dev/null; then
			# Try apt (Debian, Ubuntu, and all derivatives)
			write_status  "Setting install options for DEB"
			export _INSTCMD="sudo apt-get -y install"
		elif hash pkcon 2>/dev/null; then
			# If there is no apt, zypper, dnf
			write_status  "Setting install options for Package Kit"
			export _INSTCMD="sudo pkcon -y  install"
		else
			write_error "This system does not seem to have a software managment system"
			return 1
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		return 1
	fi
	return $?
}










check_dependencies ()
{
# Description:
# Function to check that a piece of software is installed and if not install it.
# Works for apt, zypper, dnf or yum based systems currently. The function will take a parameter 
# that is expected to match the software name or rather the name of the package. 
# 
# 
# This is done to comply wiht the philosophy to do what it takes to reach the objective, and 
# just work. Rather than just fail, we want to try and solve the problem and make the software
# available. 
# 
# Globals:
# Arguments: None
# Dependencies: [package manager]
# Function Dependencies: (other functions)
# ensure_admin, write_status, write_information, write_warning, write_error, is_software_package_installed,
# InstallSoftwareFromRepo
# 
# Outputs:
# Returns: 1/0
# Usage: check_dependencies [packagename]
# 
# EXAMPLE: check_dependencies snapd
# 
# End of documentation
	ensure_admin
	#---------------------------------------------------------------
	write_status "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	if is_software_package_installed "${1}" ; then
		write_information "I found that the dependency ${1} is present on this system... "
	else
		write_warning "You seem to have no ${1}... I will try to get it... "
		if InstallSoftwareFromRepo "${1}" ; then
			write_status "OK Done! Continuing..."
		else
			write_error "That install didn't work out so well."
			write_error "Please manually try to add the software since I couldn't do it."
			return 1
		fi
	fi
}





software::check_native_package_dependency ()
{
# Description:
# Function to check that a piece of software is installed and if not install it.
# Works for apt, zypper, dnf or yum based systems currently. The function will take a parameter 
# that is expected to match the software name or rather the name of the package. 
# 
# 
# This is done to comply wiht the philosophy to do what it takes to reach the objective, and 
# just work. Rather than just fail, we want to try and solve the problem and make the software
# available. 
# 
# Globals:
# Arguments: None
# Dependencies: [package manager]
# Function Dependencies: (other functions)
# ensure_admin, write_status, write_information, write_warning, write_error, is_software_package_installed,
# InstallSoftwareFromRepo
# 
# Outputs:
# Returns: 1/0
# Usage: software::check_native_package_dependency [packagename]
# 
# EXAMPLE: software::check_native_package_dependency snapd
# 
# End of documentation
	ensure_admin
	#---------------------------------------------------------------
	write_status "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	if is_software_package_installed "${1}" ; then
		write_information "I found that the dependency ${1} is present on this system... "
	else
		write_warning "You seem to have no ${1}... I will try to get it... "
		if software::add_native_package "${1}" ; then
			write_status "OK Done! Continuing..."
		else
			write_error "That install didn't work out so well."
			write_error "Please manually try to add the software since I couldn't do it."
			return 1
		fi
	fi
}






rtd_ppa_checker ()
{
# Description:
# Function to check status of Ubuntu and derivatives' PPA aarchives.
# This function will take one optional argument to toggle the "delete" option. If the delet option
# is requested rtd_ppa_checker will delete any PPA's that are not used (no software is installed from it)
#
# PPA stands for Personal Package Archive. The PPA allows application developers and
# Linux users to create their own repositories to distribute software. With PPA, you can
# easily get newer software version or software that are not available via the official Ubuntu
# repositories.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# rtd_ppa_checker [] [--delete]
#
# End of documentation
	ensure_admin
	for f in /etc/apt/sources.list.d/*.list; do
		grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
			echo "ENTRY: $ENTRY"
			HOST=$(cut -d/ -f3 <<< "$ENTRY")
			if [ "ppa.launchpad.net" = "$HOST" ]; then
				USER=$(cut -d/ -f4 <<< "$ENTRY")
				PPA=$(cut -d/ -f5 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "PPA: ppa:$USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			else
				USER=$(cut -d/ -f3 <<< "$ENTRY")
				PPA=$(cut -d/ -f4 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "REPOSITORY: $USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			fi
		done
	done
}









rtd_oem_release_upgrade ()
{
# Description: Function to attempt to perform a release upgade on several Linux distributions.
# Supported distributions are: Ubuntu, Pop! OS, Debian, SUSE, and fedora.
# This function does not require any arguments but will respect "interactive". The "interactive"
# parameter will force the function to pause if a supported distribution is not found.
# It will check for a supported distribution and attempt the upgrade if possible.
# If a supported distribution is not detected the function will do nothing.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  (in a script):
#  rtd_oem_release_upgrade [ string ]
#
# [ string ] : interactive
#
# End of Documentation


	ensure_admin
	local set interactive=$1
	unset result
	tmp_disc_dir=$(mktemp -d )
		if hostnamectl |grep "Ubuntu" 2>/dev/null ; then
			write_warning "this may take some time, please be patient!"
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$tmp_disc_dir"/stdout ) 2> >(tee "$tmp_disc_dir"/stderr >&2 )
			result="$( cat "$tmp_disc_dir"/stdout; cat "$tmp_disc_dir"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$tmp_disc_dir" ; unset tmp_disc_dir
		elif hostnamectl |grep "Pop!_OS" 2>/dev/null ; then
			write_warning "this may take some time, please be patient!"
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$tmp_disc_dir"/stdout ) 2> >(tee "$tmp_disc_dir"/stderr >&2 )
			result="$( cat "$tmp_disc_dir"/stdout; cat "$tmp_disc_dir"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$tmp_disc_dir" ; unset tmp_disc_dir
		elif hostnamectl |grep "Debian" 2>/dev/null ; then
			write_error "Debian does not provide an upgrade tool between major releases... Please use the manual upgrade method."
			result="Debian does not have an in place upgrade tool. Please edit the /etc/apt/sources.list and use the disd-upgrade option"
			display_result "Release Upgrade Attempt Result: "
		elif hostnamectl |grep "SUSE" 2>/dev/null ; then
			write_warning "This REALLY may take some time, please be patient!"
			cat /etc/os-release
			write_information "these are the current repositories..."
			zypper modifyrepo --enable repo-update
			zypper repos --uri

			SUSE_VER=$($RTD_GUI --title "SUSE Distribution Upgrade Confirmation" --inputbox "Please pick an available Suse version by entering it below. For example type: 15.3  \n You are currently using: \n $(hosnamectl)  "  25 110 "15.3" 3>&1 1>&2 2>&3) ;clear
			[ "${SUSE_VER}" ] || write_error "No verson selected for distribution upgrade -- Only running a regular update then... "

			write_status "Checking if it is possible to upgrade to ${SUSE_VER}"
			if zypper --releasever="${SUSE_VER}" lr -u ; then
				zypper --releasever="${SUSE_VER}" ref
				write_status "Attempting upgrade of system now..."
				zypper --releasever="${SUSE_VER}" dup --force-resolution
				read -p "$ERRMSG: Press  [ ENTER ] to REBOOT:"
				reboot
			else
				write_error "It is not possible to upgrade to Open Suse ${SUSE_VER} since there does not appear to be a release server available for ${SUSE_VER}"
				read -p "$ERRMSG: Press  [ ENTER ] to continue:"
			fi
		elif hostnamectl |grep "fedora" 2>/dev/null ; then
			releasever=$($RTD_GUI --title "Fedora Distribution Upgrade Confirmation" --inputbox "Please enter the Fedora version you want to upgrade to. Please make sure that it has been published. You are currently using: $(hosnamectl)  only numbers are valid" 8 78  3>&1 1>&2 2>&3)
			dnf upgrade --refresh
			dnf install dnf-plugin-system-upgrade
			dnf system-upgrade download --refresh --releasever="${releasever}"
			read -p "$ERRMSG: Press  [ ENTER ] to REBOOT and install the upgrade:"
				case $? in
					0 ) dnf system-upgrade reboot || return 1;;
					1 ) return 1 ;;
					255) return 1 ;;
				esac

		else
			[[ "$interactive" == "interactive" ]] && read -p "This option requires the program (do-release-upgrade) (Ubuntu) or OpenSUSE (zypper) on your system. Press [Enter] key to return to menu."
		fi
		return
}












rtd_oem_remove_non_western_latin_fonts ()
{
# Description:  a simple function to remove known
# non-western (latin) fonts from a distribution. Notably, Ubuntu provides too many fonts
# of all kinds by default, even if the user will never need the fonts. However, the fonts
# may cause unexpected font tool behavior and crashes, due to the large number of fonts
# and their features. It is there fore a good Idea to remove these fonts if they are not needed.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#	Simply call this function by stating its name:
# 	rtd_oem_remove_non_western_latin_fonts
#
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation
	ensure_admin
	font_list="fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lklug-sinhala fonts-lohit-guru fonts-guru fonts-nanum fonts-noto-cjk fonts-takao-pgothic fonts-tibetan-machine fonts-guru-extra \
		fonts-lao fonts-sil-padauk fonts-sil-abyssinica fonts-tlwg-* fonts-beng fonts-beng-extra fonts-deva fonts-deva-extra fonts-gubbi fonts-gujr fonts-gujr-extra fonts-kalapi fonts-knda \
		fonts-lohit-* fonts-orya* fonts-pagul fonts-sahadeva fonts-samyak-* fonts-sarai fonts-smc fonts-smc-* fonts-taml fonts-telu fonts-telu-extra"
	echo "Attempting to remove non-western fonts..."
	count=0
	for i in $font_list ; do
		rtd_oem_remove_software $i && (( count++))
	done
	echo "Removed [ $count ] non-western Fonts"
}









rtd_oem_remove_software ()
{
# Description:
# The OEM remove software function will attempt to remove whatever package name given
# as an argument using whatever package system found on the system. This is provided
# for portability and convenience. Currently, this functions will attempt to use
# pkcon (prefferred as it run on many distributions), apt, yum, dnf, and zypper.
# Additional package manager may be added as time allows.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# 	call this function using one argument only for reliability reasons;
#	as per the below example. If thre is a need to remove a large number of
#	packages it is reccommended to use a for loop and call this function,
#	still realizing the benefit of mylti-distribution support.
#
#	rtd_oem_remove_software packagename
#
# If a failure occurs this function will return a non "0" exit code. (1)
# End of documentation

	ensure_admin
	if [[ $(echo $OSTYPE |grep "linux") ]]; then
		echo "Trying to remove package $*"
		if hash dnf 2>/dev/null; then
			dnf -y remove $*
			return $?
		elif hash yum 2>/dev/null; then
			yum -y remove $*
			return $?
		elif hash zypper 2>/dev/null; then
			zypper remove -y $*
			return $?
		elif hash apt 2>/dev/null; then
			apt-get -y remove $* && apt-get -y autoremove
			return $?
		elif hash pkcon 2>/dev/null; then
			pkcon remove $* -y --autoremove
			return $?
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			return 1
		fi
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		return 1
	else
		echo "Though you can run bash, I have no Idea how to remove software here!"
		return 1
	fi
}






software::remove_native_software_package ()
{
# Description:
# The OEM remove software function will attempt to remove whatever package name given
# as an argument using whatever package system found on the system. This is provided
# for portability and convenience. Currently, this functions will attempt to use
# pkcon (prefferred as it run on many distributions), apt, yum, dnf, and zypper.
# Additional package manager may be added as time allows.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# 	call this function using one argument only for reliability reasons;
#	as per the below example. If there is a need to remove a large number of
#	packages it is reccommended to use a for loop and call this function,
#	still realizing the benefit of mylti-distribution support.
#
#	software::remove_native_software_package packagename
#
# If a failure occurs this function will return a non "0" exit code. (1)
#
# End of documentation
	system::log_item "Requested to remove package $*"
	ensure_admin
	if [[ $(echo $OSTYPE |grep "linux") ]]; then
		system::log_item "Linux system deetected; Trying to remove package $* using native package manager..."
		if hash dnf 2>/dev/null; then
			system::log_item "dnf package manager detected; attempting to remove package $*"
			dnf -y remove $*
			return $?
		elif hash yum 2>/dev/null; then
			system::log_item "yum package manager detected; attempting to remove package $*"
			yum -y remove $*
			return $?
		elif hash zypper 2>/dev/null; then
			system::log_item "zypper package manager detected; attempting to remove package $*"
			zypper remove -y $*
			return $?
		elif hash apt 2>/dev/null; then
			system::log_item "apt package manager detected; attempting to remove package $*"
			apt-get -y remove $* && apt-get -y autoremove
			return $?
		elif hash pkcon 2>/dev/null; then
			system::log_item "pkcon package manager detected; attempting to remove package $*"
			pkcon remove $* -y --autoremove
			return $?
		else
			write_error "This system does not seem to have a software managment system" 
			return 1
		fi
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
		return 1
	else
		write_error "Though you can run bash, I have no Idea how to remove software here!"
		return 1
	fi
}







system::log_item ()
{
# Description:
# The purpose of this function is to consistently write script output to the right log file. 
# By default, the log file will be /var/log/$(basename $0).log. If the log file is not set
# the function will set it to the default. If the log file is set, it will use the set log file.
# 
# This function will log items by prepending the time and date, as well as the calling function. 
# If the calling function is write_warning, write_error, write_information, or write_status, 
# the function will prepend the log item with the preceding calling function name. Otherwise, 
# it will simply prepend the calling function name.
# 
# Globals: _LOGFILE
# Arguments: "Text to log"
# Outputs: Writes to log file
#
# Example:
# 2024/01/17 11:43  --- : ðŸ§© source: ðŸ§© _LOG_DIR=/home/tangaroa/.config/rtd/logs
# 2024/01/17 11:43  --- : ðŸ§© source: ðŸ§© _LOGFILE=/home/tangaroa/.config/rtd/logs/_rtd_library.log
# 2024/01/17 11:43  --- : ðŸ§© âš  source: Library is sourced from a script or terminal! 
# 2024/01/17 11:43  --- : ðŸ§© ðŸ›ˆ source: Script is sourced from bash in a terminal: /bin/bash 
# 2024/01/17 11:43  --- : ðŸ§© dependency::search_local: Requested dependency file: _branding ...
#
# Returns: None
# Usage:
#
# Call this function by: 
# system::log_item "Text to log"
#
# End of documentation

	if [[ -z $_LOGFILE ]] ; then
		# If log file not set globally, set it to defaults for this function a.k.a. script name
		local _scriptname=$(basename "${BASH_SOURCE[0]}")
		local _tla=${_scriptname:0:3}

		if [[ $EUID -ne 0 ]]; then
			_log_dir="${HOME}/.config/rtd/logs"
		else
			local _log_dir=${_LOG_DIR:-"/var/log/${_tla,,}"}
		fi

		mkdir -p ${_log_dir}
		local _logfile=${_log_dir}/${_scriptname}.log
	else 
		local _logfile="${_LOGFILE}"
	fi

	touch "${_logfile}"
	local _date="$(date '+%Y/%m/%d %H:%M')"

	# Format the log item based on the calling function for clear reading
	case "${FUNCNAME[1]}" in
		"write_error")
			echo "${_date}  --- ERROR: $*" >> "${_logfile}"
		;;
		"write_warning") 
			echo "${_date}  --- WARN : $*" >> "${_logfile}"
		;;
		"write_information")
			echo "${_date}  --- INFO : $*" >> "${_logfile}"
		;;
		"write_host")
			echo "${_date}  --- HOST : $*" >> "${_logfile}"
		;;
		"write_status")
			echo "${_date}  --- STAT : $*" >> "${_logfile}"
		;;
		*)
			echo "${_date}  --- LOGD : ðŸ§© ${FUNCNAME[1]}: $*" >> "${_logfile}"
		;;
	esac
}




rtd_update_system ()
{
# Description:
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak with a cleaned up oputput only displaying status.
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output.
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: rtd_update_system
# End of documentation
	#ensure_admin
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.14 (built in)"
	DIALOGRC="~/.config/rtd/dialogrc"
	_LOGFILE="${_LOGFILE:-$0.log}"

	write_status "${PUBLICATION}: Version ${VERSION}"
	write_status "------------------------------------------------------------------"

	write_host --cyan "I am updating software from all channels I can find on the system."
	write_host --cyan "I will update via the native package manager as well as newer formats"
	write_host --cyan "like snap and flatpak ..."
	echo -e " \n"

	rtd_software_task ()
	{
		system::log_item "running rtd_software_task with parameters $*"
		# make some decent display terminal graphics...
		PAD="----------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "Executing $LINE:"\ & "$@" >>"$_LOGFILE" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] ${RED} FAILED $ENDCOLOR  \n"
		# write_status "Executing ${LINE}:"\ & "$@" >>"${_LOGFILE}" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] OK!  \n" ||printf "%b%-6s%b [ ! ] FAILED  \n"

	}
	

	if hash dnf 2>/dev/null; then
		rtd_software_task dnf -y upgrade
	elif hash zypper 2>/dev/null; then
		rtd_software_task zypper up -y
	elif hash apt 2>/dev/null; then
		rtd_software_task apt-get update
		UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
		if [ "$UPGRADABLE" -eq 0 ]; then
			write_information "$UPGRADABLE packages that need updates; Skipping update task... "
		else
			write_information "There are $UPGRADABLE packages that need updates..."
			rtd_software_task dpkg --configure -a
			rtd_software_task apt-get upgrade -y
			rtd_software_task apt-get full-upgrade -y
			rtd_software_task apt-get --purge autoremove -y
			rtd_software_task apt-get clean
		fi
	elif hash pkcon 2>/dev/null; then
		rtd_software_task pkcon -y refresh
		rtd_software_task pkcon get-updates
		rtd_software_task pkcon -y update --autoremove 
	else
		write_error "This system does not seem to have a software managment system" 
		return 1
	fi

	write_status "updating snaps if snap is present on the system..."
	if hash snap 2>/dev/null; then
		rtd_software_task snap refresh
	else
		write_warning "--- snap software is not present on this system... skipping..."
	fi

	write_status "updating flatpaks if flatpak is present on system..."
	if hash flatpak 2>/dev/null; then
		rtd_software_task flatpak update --user --noninteractive -y
		rtd_software_task flatpak update --system --noninteractive -y
	else
		write_warning "--- flatpak software is not present on this system... skipping..."
	fi

}





software::update_system_txt ()
{
# Description:
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak with normal text only default output.
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output.
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: software::update_system_txt
# End of documentation
	ensure_admin
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.14 (built in)"
	DIALOGRC="~/.config/rtd/dialogrc"
	_LOGFILE="${_LOGFILE:-$0.log}"

	write_status "${PUBLICATION}: Version ${VERSION}"
	write_status "------------------------------------------------------------------"

	write_host --cyan "I am updating software from all channels I can find on the system."
	write_host --cyan "I will update via the native package manager as well as newer formats"
	write_host --cyan "like snap and flatpak ..."
	echo -e " \n"
	(
	if hash dnf 2>/dev/null; then
		dnf -y upgrade 
	elif hash zypper 2>/dev/null; then
		zypper up -y 
		zypper dup -y --auto-agree-with-licenses --allow-vendor-change 
	elif hash apt 2>/dev/null; then
		apt-get update
		UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
		if [ "$UPGRADABLE" -eq 0 ]; then
			write_information "$UPGRADABLE packages that need updates; Skipping update task... "
		else
			write_information "There are $UPGRADABLE packages that need updates..."
			dpkg --configure -a
			apt-get upgrade -y
			apt-get full-upgrade -y
			apt-get --purge autoremove -y
			apt-get clean
		fi
	elif hash pkcon 2>/dev/null; then
		pkcon -y refresh
		pkcon get-updates
		pkcon -y update --autoremove
	else
		write_error "This system does not seem to have a software managment system" 
		return 1
	fi
	) | tee -a "$_LOGFILE"

	write_status "updating snaps if snap is present on the system..."
	if hash snap 2>/dev/null; then
		snap refresh
	else
		write_warning "--- snap software is not present on this system... skipping..."
	fi
	

	write_status "updating flatpaks if flatpak is present on system..."
	if hash flatpak 2>/dev/null; then
		flatpak update --user -y
		flatpak update --system -y 

	else
		write_warning "--- flatpak software is not present on this system... skipping..."
	fi

	echo "
	
	$(write_information "All updates have been processed.")
	NATIVE PACKAGES:
	$(
		if hash apt ; then cat /var/log/dpkg.log | grep "\ upgrade\ "
		elif hash dnf ; then cat /var/log/dnf.log | grep "\ upgrade\ "
		elif hash zypper ; then for i in $(cat /var/log/zypp/history |grep '|install|' | cut -f3 -d'|' ) ; do echo -n "* $i "  ;done
		elif hash pkcon ; then pkcon get-updates
		fi
	) 

	SNAPS:
	$(snap changes)

	FLATPAKS:
	$(flatpak history --system --since=1h
	  flatpak history --user --since=1h)" | tee -a "$LOGFILE"
}






software::update_all_ui ()
{
	ensure_admin
	local TERMUITXT="nocolor"
	local PUBLICATION="$BRANDING Update Manager for Linux"
	local VERSION="1.15 (built in with dialog)"
	local DIALOGRC="~/.config/rtd/dialogrc"
	local _LOGFILE="${_LOGFILE:-$0.log}"
	local dialog_ui=${RTD_GUI:-"dialog --erase-on-exit --colors "}

	Native_Software_Packages ()
	{
		(
		if hash zypper 2>/dev/null; then
			zypper up -y
			write_information "Update task complete."
		elif hash apt 2>/dev/null; then
			apt-get update
			UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
			if [ "$UPGRADABLE" -eq 0 ]; then
				write_information "$UPGRADABLE packages that need updates; Skipping update task... "
			else
				write_information "There are $UPGRADABLE packages that need updates..."
				dpkg --configure -a
				apt-get upgrade -y
				apt-get full-upgrade -y
				apt-get --purge autoremove -y
				apt-get clean
			fi
			write_information "Update task complete."
		elif hash dnf 2>/dev/null; then
			dnf -y upgrade
			write_information "Update task complete."
		elif hash pkcon 2>/dev/null; then
			pkcon -y refresh
			pkcon get-updates
			pkcon -y update --autoremove 
			write_information "Update task complete."
		else
			write_error "This system does not seem to have a software managment system" 
			return 1
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB"  --progressbox "Updating all natively installed software..." 25 120
	}

	Snap_Apps ()
	{
		(
		write_status "updating snaps if snap is present on the system..."
		if hash snap 2>/dev/null; then
			snap refresh
			write_information "Update task complete."
		else
			write_warning "!snap software is not present on this system... skipping..."
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --progressbox "Updating all Contained Snap Apps..." 25 120
	}

	Flatpak_Apps ()
	{
		(
		write_status "updating flatpaks if flatpak is present on system..."
		if hash flatpak 2>/dev/null; then
			flatpak update --user --noninteractive -y
			flatpak update --system --noninteractive -y
			write_information "Update task complete."
		else
			write_warning "!flatpak software is not present on this system... skipping..."
		fi
		) | tee -a "$_LOGFILE" | $dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --progressbox "Updating all Contained Flatpaks Apps..." 25 120
	}

	while true; do
		exec 3>&1
			local _proglist=""Native_Software_Packages"  1 "on"  "Snap_Apps" 2 "on" "Flatpak_Apps" 3 "on""
			_run=$($dialog_ui --ok-label Update --cancel-label QUIT --backtitle "\Zb$PUBLICATION             $VERSION\ZB" --checklist "Select what to update:" 20 80 10 ${_proglist} 2>&1 1>&3 )
			exit_status=$?
		exec 3>&-

		case $exit_status in
			1) clear && echo [Quit] && return ;;
			255) clear && echo [ESC] && exit ;;
		esac

		case $_run in
			$_run )
				for i in $_run ; do $i 
				done
				$dialog_ui --backtitle "\Zb$PUBLICATION             $VERSION\ZB" \
				--title "Updates Complete" \
				--msgbox "
				
				All updates have been processed.
				NATIVE PACKAGES:
				$(
					if hash apt ; then cat /var/log/dpkg.log | grep "\ upgrade\ "
					elif hash dnf ; then cat /var/log/dnf.log | grep "\ upgrade\ "
					elif hash zypper ; then cat /var/log/zypp/history | grep "\ upgrade\ "
					elif hash pkcon ; then pkcon get-updates
					fi
				)

				SNAPS:
				$(snap changes)

				FLATPAKS:
				$(flatpak history --system --since=1h
				flatpak history --user --since=1h)
				
				
				" \
				20 120
			;;
			* ) 
				write_warning "No update actions were requested."
				exit 
			;;
		esac
	done
}



software::from_flathub.org ()
{
# Description: Function to simplify and streamline the installation and removal of flatpaks.
# Globals: none
# Dependencies: [distro pakage managment] [function: check_dependencies] [Internet access]
# Arguments: 
# -- Default action is to add software title matching passed parameter. 
# -- An optioin "--remove" may be passed to atempt removal of the software title. 
#
# Outputs:
# Returns: Standard return codes 1/0
# Usage: software::from_flathub.org [ title-name | title-name --remove ]
#
# 
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Like Snap, Flatpak is another distribution independent package format aimed to simplify overall
# app distribution and usage in Linux systems. Previously known as xdg-app, the framework was based
# on the concept of running applications in a secure virtual sandbox without requiring root privileges
# or posing a security threat to the system.
#
#	*	---       PREFFERRED Software install for GUI apps           ----		*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation

	local app_name=""
	local remove_flag=""

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--remove)
			remove_flag="--remove"
			shift
		;;
		*)
			if [[ -z "$app_name" ]]; then
				app_name="$1"
			else
				write_error "Error: Invalid parameter '$1'"
				write_information "Usage: software::from_flathub.org [app_name] [--remove]"
				return 1
			fi
			shift
		;;
		esac
	done

	ensure_flatpak_package_managment

	if [[ -z "$app_name" ]]; then
		write_error "Error: App name is missing."
		write_information "Usage: software::from_flathub.org [app_name] [--remove]"
		return 1
	fi

	if [[ "$remove_flag" == "--remove" ]]; then
		system::log_item "Request to remove Flatpak app '$app_name'"

		if flatpak uninstall -y "$app_name"; then
			system::log_item "Flatpak app '$app_name' has been uninstalled."
		else
			system::log_item "Error: Failed to uninstall Flatpak app '$app_name'"
			return 1
		fi
	else
		system::log_item "Request to install Flatpak app '$app_name'"

		if flatpak info "$app_name" >/dev/null 2>&1; then
			write_information "Flatpak app '$app_name' is already installed."
		else
			if flatpak install -y "$app_name"; then
				system::log_item "Flatpak app '$app_name' has been installed."
			else
				system::log_item "Error: Failed to install Flatpak app '$app_name'"
				return 1
			fi
		fi
	fi
}






software::from_snapcraft.io ()
{
# Description: Function to ensure that snap is installed.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs: stdout
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE:
# https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Snap is a distribution independent package format developed by Canonical and first released
# in 2014. It was initially developed for Ubuntu but has been adopted by other Linux distributions
# like Arch, Linux Mint, CentOS, Gentoo, and Fedora, and also included support for the Snap
# framework. The main aim behind this package format development was to come up with a
# single unified format for software packages to run in a wide range of devices.
# That includes IoT (IoT), embedded devices running Ubuntu Core (a minimalistic
# version of Ubuntu), and computer systems that ran some Ubuntu version.
# Snap also offers an online app store â€“ Snapcraft, where users can find and
# install the software packages. It creates a large pool where users can find all
# available a snap package. Snapcraft is itself controlled and maintained by the
# Canonical team.
#
#
#	*	---   PREFFERRED Software install for CLI apps        ----	*
#
#  CAPABILITY TABLE:
# +----------------------------------------------------+-------------+-------------+--------------+
# | Features                                           | Snap        | Flatpak     | AppImage     |
# +----------------------------------------------------+-------------+-------------+--------------+
# | Permission Controls Toggles                        | Yes         | Yes         | No           |
# | Sandboxing Support                                 | Yes         | Yes         | Yes          |
# | Sandboxing Mandatory                               | Yes         | Yes         | No           |
# | App Portability                                    | Yes         | Yes         | No           |
# | Native Theme Support                               | Yes (caveat)| Yes (caveat)| Yes (caveat) |
# | Support for Bundled Libraries                      | Yes         | Yes         | Yes          |
# | Fully Contained Single Executable Support          | No          | No          | Yes          |
# | Online App Store                                   | Yes         | Yes         | Yes          |
# | Multi-version Parallel Apps Support                | Yes         | Yes         | Yes          |
# | Automatic Updates                                  | Yes         | Yes         | Yes (caveat) |
# | Support for Chrome OS (through Crostini containers)| Yes         | Yes         | Yes          |
# | App Size                                           | higher than | higher than | Lowest       |
# | Number of Applications Available in the App Store  | Highest     | Lowest      | Somewhere in |
# | Plugins for Desktop App Store Software             | Yes         | Yes         | No           |
# +----------------------------------------------------+-------------+-------------+--------------+
# End of documentation


	local app_name=""
	local remove_flag=""
	local requires_classic=""

	# Parse command line arguments
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--remove)
			remove_flag="--remove"
			shift
		;;
		*)
			if [[ -z "$app_name" ]]; then
			app_name="$1"
			else
				write_error "Error: Invalid parameter '$1'"
				write_information "Usage: install_or_remove_snap_app [app_name] [--remove]"
				return 1
			fi
			shift
			continue  # Skip the remaining part of the loop
			;;
		esac
	done

	if [[ -z "$app_name" ]]; then
		write_error "Error: App name is missing."
		write_information "Usage: ${FUNCNAME[0]} [app_name] [--remove]"
		return 1
	fi

	hash snap || ensure_snap_package_managment

	if [[ "$remove_flag" == "--remove" ]]; then

		system::log_item "Request to remove Snap app '$app_name'"

		if snap remove "$app_name"; then
			system::log_item "Snap app '$app_name' has been removed."
		else
			system::log_item "Error: Failed to remove Snap app '$app_name'"
		fi
	else
		system::log_item "Request to install Snap app '$app_name'"

		if snap list "$app_name" >/dev/null 2>&1; then
			system::log_item "Snap app '$app_name' is already installed."
		else
			requires_classic=$(snap info "$app_name" | grep "latest/stable" | grep -o " classic")
			if [[ -n "$requires_classic" ]]; then
				system::log_item "The app '$app_name' requires classic confinement (less confined)..."
				if snap install "$app_name" --classic; then
					system::log_item "Snap app '$app_name' has been installed."
				else
					system::log_item "Error: Failed to install Snap app '$app_name'"
				fi
			else
				if snap install "$app_name"; then
					system::log_item "Snap app '$app_name' has been installed."
				else
					system::log_item "Error: Failed to install Snap app '$app_name'"
				fi
			fi
		fi
	fi
}





software::add_software_task ()
{
# Description: Display executed task and echo ON/NOK based on sucess
# This function is created to reduce the terminal output and create a more poliched output of
# the tasks executed. This function has no idea shat it is doing, it will simply call the function
# it was asked to call or execute the command ist was asked to, and echo OK or FAIL based on the
# return code.
# Globals:
# Arguments: function or command to execute
# Outputs:
# Returns:
# Usage: software::add_software_task function_name
# End of documentation

	PAD="---------------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	#display_spinner start
	echo -ne "Task: ${LINE/recipe_/}:" & ${*} &>>${_LOGFILE:-"/var/log/rtd/${FUNCNAME[0]}$(date +%Y-%m-%d-%H)-oem-setup.log"} && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] ${RED} FAILED $ENDCOLOR  \n"
	#display_spinner stop
}







software::ensure_restricted_codecs (){
# Description: simple function to ensure that restricted codecs are available on the system. 
# Globals: expects zypper, dnf, or apt available. 
# Arguments: none
# Outputs:
# Returns:
# Usage: software::ensure_restricted_codecs
# End of documentation	
	write_status "Install all the required multimedia codecs..."
	for i in libdvdcss2 ffmpeg ; do
		check_ependencies $i || write_error "Failed to install restricted codecs..."
	done
}







software::vendor_download_and_install ()
{
# Description: Function by Nate Beaken to ease and make consistent the downloading of the non repository
# packages and install them. It can install any package that Package Kit can manage (available on most Linux dists)
# It expects one parameter: the complete URL to download from.
# Globals:
# Arguments: URL to rpm or deb file and possibly some other formats of distributions that use package kit.
# Outputs:
# Depends:
#           - Functions; write_error, check_dependencies
#           - Software: wget, pkcon
# Returns: 0/1
# Usage:
# 	   software::vendor_download_and_install https://download.teamviewer.com/download/linux/teamviewer_amd64.deb
# 	   software::vendor_download_and_install https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm
# End of documentation

	download_url="$1"
	fetch_file () { wget -P ${_OEM_DIR}/cache "${download_url}"  ; }

	echo  "${FUNCNAME[0]}: getting package ${download_url}..."
	if hash wget ; then
		fetch_file
	elif check_dependencies wget ; then
		fetch_file
	else
		write_error "Unable to download requested file:  ${download_url}..."
		write_error "Please check if wget is available since this is used to download files..."
		write_error "You may also want to check that the internet is reachable from this computer?"
		return 1
	fi

	echo "${FUNCNAME[0]}: Installing package $(basename ${download_url}) ..."
	if hash pkcon ; then
		pkcon install-local -y ${_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	else
		check_dependencies packagekit-tools
		pkcon install-local -y ${_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	fi
}









SoftwareManagmentAvailabilityCHK ()
{
# Description: Function to check and see if the system software managment is available. In some cases
# the software managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	if hash apt ; then
		echo ""
		write_information "--- Checking if software maintenance system is available:"
		i=0
		tput sc
		while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
			case $((${i} % 4)) in
				0 ) j="-" ;;
				1 ) j="\\" ;;
				2 ) j="|" ;;
				3 ) j="/" ;;
			esac
			tput rc
			echo -en "\r[${j}] Waiting for other software managers to finish..."\

			sleep 5
			((i=i+1))
		done
		write_information "--- Software maintenance system is available."
	fi
}





software::native_managment_availability_check ()
{
# Description: Function to check and see if the system software managment is available. In some cases
# the software managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	if hash zypper ; then
		write_information "--- Checking if software maintenance system is available:"
	elif hash dnf ; then
		write_information "--- Checking if software maintenance system is available:"
	elif hash apt ; then
		echo ""
		write_information "--- Checking if software maintenance system is available:"
		i=0
		tput sc
		while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
			case $((${i} % 4)) in
				0 ) j="-" ;;
				1 ) j="\\" ;;
				2 ) j="|" ;;
				3 ) j="/" ;;
			esac
			tput rc
			echo -en "\r[${j}] Waiting for other software managers to finish..."\

			sleep 5
			((i=i+1))
		done
		write_information "--- Software maintenance system is available."
	fi
}




display_software_installation_choices_gtk ()
{
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACKTITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#                           DEPRECATED
#
# End of documentation

	DisplayMenu=( zenity  --list  --cancel-label="Go Back" --timeout 120 --width=800 --height=600 --text "$_BACKTITLE" --checklist \
	--column "ON/OFF" --column "Select Software to add:" --separator " " )
	SoftwareList=$(list_loaded_software_functions --nonum)
	MenuOptions=($(for i in $SoftwareList ; do echo -e "${zstatus:=false} ${i}" ; done ))

	declare -A choices
	choices=$("${DisplayMenu[@]}" "${MenuOptions[@]}" )

	for choice in ${choices}
		do
		# call each chosen software install (by function) & add recepie (removed for display purposes)
		software::add_software_task recipe_${choice}
	done
}




software::display_bundle_install_choices_gtk ()
{
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACK_TITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

	while true; do
		exec 3>&1
		local DisplayList=$(software::list_bundles --zformat-installable)
		local IFS_SAV=$IFS
		local IFS=$(echo -en "\n\b")

		selection=$(zenity --list --title="${FUNCNAME[1]}: Select Task" --cancel-label="Go Back" --checklist \
			--text=" Select a Software Bundle below that you want to add to this computer: \n NOTE: only bundles that are not yet installed are shown. \n" \
			--height=600 --width=980 \
			--print-column=2 --column="Selected" --column="Bundle" --column="Description" \
			--separator=" " ${DisplayList} )
		exit_status=$?
		IFS=$IFS_SAV
		exec 3>&-

		case $exit_status in
			1) clear && echo [Cancel] && break ;;
			255) clear && echo [ESC] && return ;;
		esac

		case "${selection}" in
			"${selection}" )
				_done=0 ; for i in $(cat ${completed_bundles_list}) ; do ((_done=_done+1)) ; done
				_count=0
				previously_completed_bundles="$(cat ${completed_bundles_list})"

				run_bundle_install () {
					selection_list=(${selection})
					total_count=${#selection_list[@]}
					for i in ${selection} ; do
						current_bundle="${i}"
						((_count=_count+1))
						echo "# Installing bundle ${_count} of ${total_count}: ${current_bundle}..."
						if recipe_Bundle:_${current_bundle} &>/dev/null  ; then
							echo "${current_bundle}" >> ${completed_bundles_list}
							system::log_item "Progress so far: $(( 100*${_count}/${total_count} ))% of bundles installed."
						else 
							system::log_item "ERROR: ${_count} of ${total_count}: ${current_bundle} may have installed with errors or failed to install." 
							echo "${current_bundle}" >> ${completed_bundles_list}
							system::log_item "Progress so far: $(( 100*${_count}/${total_count} ))% of bundles installed."
						fi
						echo $(( 100*${_count}/${total_count} ))
					done
				}
				run_bundle_install | zenity --progress --no-cancel --auto-close  \
				--title="Installing Software Prodictivity Bundles" \
				--text="Please wait for the bundle installs to complete..." \
				--percentage=10 --height=200 --width=600

				for i in $(cat ${completed_bundles_list}) ; do ((_count=_count+1)) ; done
				_diff=$(( ${_count} - ${_done} ))
				completed_bundles="$(tail -${_diff} ${completed_bundles_list} )"

				zenity --info --timeout 120 \
				--title "Bundles Installed: ${_count} Bundles Previously Installed: ${_done}" \
				--text="The following Software bundles have been installed: \n \n ${completed_bundles} \n \n Previouly installed bundles: \n \n ${previously_completed_bundles}" \
				--height=600 \
				--width=800

				for i in _done _count completed_bundles previously_completed_bundles selection_list total_count current_bundle ; do unset ${i} ; done
			;;
			* )
				# Trap unknown conditions so as to not do harm
				exit
			;;
		esac
	done
	return
}




software::display_bundle_removal_choices_gtk ()
{
# Function to display the Software Prodictivity Bundles removal otions. All software options are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populste
# the menu displayed to the user.
#
# Globals: ${_BACK_TITLE} ${zstatus}
# Dependencies: file: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

	while true; do
		exec 3>&1
			DisplayList=$(software::list_bundles --zformat-removable)
			IFS_SAV=$IFS
			IFS=$(echo -en "\n\b")
			selection=$(zenity --list --title="${FUNCNAME[1]}: Select Task" --cancel-label="Go Back" --checklist \
			--text=" Select a Software Bundle below that you want to REMOVE from this computer: \n \n" \
			--height=600 --width=980 \
			--print-column=2 --column="Selected" --column="Bundle" --column="Description" --separator=" " ${DisplayList} )
			exit_status=$?
			IFS=$IFS_SAV
		exec 3>&-

		case $exit_status in
			1) clear && echo [Cancel] && return ;;
			255) clear && echo [ESC] && return ;;
		esac

		case "${selection}" in
			"${selection}" )
				local d=0 ; for i in $(cat ${completed_bundles_list}) ; do ((d=d+1)) ; done
				local c=0
				selection_list=(${selection})
				total_count=${#selection_list[@]}
				removed_bundle_list="$(mktemp)"
				run_bundle_uninstall () {
					for i in ${selection} ; do
						current_bundle="${i}"
						((c=c+1))
						echo "# Removing bundle ${c} of ${total_count}: ${current_bundle}..."
						recipe_Bundle:_${i} --remove 
						sed -i "/${current_bundle}/d" "${completed_bundles_list}"
						echo ${current_bundle} >> "${removed_bundle_list}"
						echo $(( 100*${c}/${total_count} ))
					done
				}
				run_bundle_uninstall | zenity --progress --no-cancel --auto-close \
				--title="Removing Software Prodictivity Bundles" \
				--text="Please wait for the bundle removals to complete..." \
				--percentage=10 --height=200 --width=600

				zenity --info \
				--timeout 120 \
				--title "Bundles Removed: $c " \
				--text="The following Software bundles have been REMOVED: \n \n $(cat ${removed_bundle_list}) " \
				--height=600 \
				--width=800
			;;
			* )
				# Trap unknown conditions so as to not do harm
				exit
			;;
		esac

		for i in DisplayList selection_list total_count current_bundle removed_bundle_list ; do unset ${i} ; done
	done
	return
}



display_software_installation_choices_term ()
{
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACKTITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

echo Under construction...
	# DisplayMenu=( dialog --menu --text "$_BACKTITLE" $WIDTH $HEIGHT )
	# SoftwareList=$(list_loaded_software_functions --nonum)
	# count=1
	# MenuOptions=($(for i in $SoftwareList ; do echo -e "${count} ${i}" ;  count=$((count + 1)); done ))

	# declare -A choices
	# choices=$("${DisplayMenu[@]}" "${MenuOptions[@]}" )

	# for choice in ${choices}
	# 	do
	# 	# call each chosen software install (by function) & add recepie (removed for display purposes)
	# 	software::add_software_task recipe_${choice}
	# done
}







rtd_server_setup_choices_services ()
{
# Description: Function to display server installation options. This will install software that is usefull
# on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
#
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...
	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Server Role Options Menu" --separate-output --checklist "Please Select a role for this system below:" 22 85 16 )
	options=(1 "Install Minecraft Server" off
		 2 "Install LAMP Server" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)	write_status "Installing and configuring Minecraft server, launcher, auto startup, etc... "
					if java --version ; then
						echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
					else
						check_dependencies default-jre
					fi

					if cat /home/$SUDO_USER/minecraft-server |grep SLS ; then
						write_information "minecraft server launcher is already present..."
					else
						generate_minecraft_server_launcher "/home/$SUDO_USER/minecraft-server"
					fi

					if cat /etc/systemd/system/getty@tty1.service.d/override.conf |grep tangarora ; then
						write_information "Service auto login already setup..."
					else
						write_warning "Minecraft server startup is not enabled: seting up now..."
						toggle_oem_auto_login
					fi

					if cat /home/$SUDO_USER/.bashrc |grep minecraft-server ; then
						write_information "minecraft server is ready to start on login"
					else
						sudo -H -u tangarora bash -c 'echo ~/minecraft-server >> ~/.bashrc'
					fi

					dialog --backtitle "$BRANDING" --title "Install Status" --yesno "I am done installing Minecraft Server. What Do you want to run the Minecraft Server now? " "$HEIGHT" "$WIDTH"
					exit_status=$?

					case $exit_status in
						0 ) sudo -H -u tangarora bash -c 'bash ~/minecraft-server' ;;
						1 ) return ;;
					esac
				;;
				2)  for i in apache2 mysql-server php libapache2-mod-php php-mcrypt php-mysql phpmyadmin nodejs ; do InstallSoftwareFromRepo $i ; done ;;
			esac
		done
}








rtd_server_setup_choices_productivity ()
{
# Description: Function to display terminal software installation options. This will install
# software that is usefull on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
# NOTE:
# This may be a good usecase if you happen to be in an opressed geographic locaiton where
# your only option is to ssh to a remote server and access email and web that way.
# Perfomance in these cases may be very poor over the internet (as for example with
# the great firewall of China). In Such a case it would be usefull to have the good
# old CLI software! :)
# End of documentation

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Terminal Productivity Software Options" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on
		2 "Alpine email client" on
		3 "Vim text editor" on
		4 "Finch multi protocol chat" on
		5 "Word Grinder word precessor" on
		6 "Spreadsheet Calculator" on
		7 "TPP Presentation Program" on
		8 "Midnight Commander file manager (Norton Commander)" on
		9 "Cmus Music Player" on
		10 "Byobu Terminal Window Manger" on
		11 "W3M web Browser" on
		12 "LYNX Web Browser" on
		13 "Mega.nz command line tools (Mega-CMD)" on
		14 "Rtorrent torrent download software" off
		15 "Install the OpenVpn client Software" on
		16 "Games: Freesweep mine sweep game" on
		17 "Games: Bastet Tetris Game" on
		18 "OEM Customizatons" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			case $choice in
				1) for i in htop powertop iftop monit nethogs bmon darkstat mtr glances nmap multitail ncdu ; do InstallSoftwareFromRepo $i ; done ;;
				2)  InstallSoftwareFromRepo alpine ;;
				3)  InstallSoftwareFromRepo vim ;;
				4)  InstallSoftwareFromRepo finch ;;
				5)  InstallSoftwareFromRepo wordgrinder ;;
				6)  InstallSoftwareFromRepo sc ;;
				7)  InstallSoftwareFromRepo tpp ;;
				8)  InstallSoftwareFromRepo mc ;;
				9)  InstallSoftwareFromRepo cmus ;;
				10) InstallSoftwareFromRepo byobu ;;
				11) InstallSoftwareFromRepo w3m ;;
				12) InstallSoftwareFromRepo lynx ;;
				13) Single_Install_MEGA.nz_Encrypted_Cloud_Storage megacmd ;;
				14) InstallSoftwareFromRepo rtorrent ;;
				15) InstallSoftwareFromRepo openvpn ;;
				16) InstallSoftwareFromRepo freesweep ;;
				17) InstallSoftwareFromRepo bastet ;;
				18) echo 'export PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "' >> ~/.bashrc ;;
			esac
		done
}






rtd_setup_choices_server ()
{
# Description: Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "System Software Chooser" --menu "It looks like this is a server to me. Please Select a role for htis system below:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  )
	options=(1 "Select terminal apps to install (i.e. vim, Lynx, Midnight Commander etc.)"
		 2 "Select Role (i.e. SSH server, Minecraft Server, etc.)"
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)  rtd_server_setup_choices_productivity ;;
				2)  rtd_server_setup_choices_services ;;
			esac
		done
}








rtd_setup_choices_for_preseed () {
# Description: Function to write out a Debian preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# functoin_name          location        config          function
# system::make_preseed_cfg       /path/to/file   ssh-server      Minecraft
# End of documentation

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=$3
	: "${SRVFUNC:-Tasks}"
	: "${PRESEED:=preseed.cfg}"
	PRESEED_FILE="$SAVETO/$PRESEED"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$1/$PRESEED"

	cmd=("$RTD_GUI" --backtitle "$BRANDING" --title "VM Auto Answer Setup Questions" --separate-output --checklist "Please preconfiguration components below. You will be prompted to manually add information for sections that you de-select:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options" on
		 2 "rtd_oem_preseed_cfg_Unattended_Install" on
		 3 "rtd_oem_preseed_cfg_Network_Configuration" on
		 4 "rtd_oem_preseed_cfg_Prevent_Install_On_USB" on
		 5 "rtd_oem_cfg_Account_Setup" on
		 6 "rtd_oem_preseed_cfg_Localization" on
		 7 "rtd_oem_preseed_cfg_EFI" on
		 8 "rtd_oem_preseed_cfg_GRUB_Bootloader_Installation" on
		 9 "rtd_oem_preseed_cfg_Disk_Layout" on
		 10 "rtd_oem_preseed_cfg_Package_Selection" on
		 11 "rtd_oem_preseed_cfg_Addon_${SRVFUNC}" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO" ;;
			2) rtd_oem_preseed_cfg_Unattended_Install "$SAVETO" ;;
			3) rtd_oem_preseed_cfg_Network_Configuration "$SAVETO" ;;
			4) rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO" ;;
			5) rtd_oem_cfg_Account_Setup "$SAVETO" ;;
			6) rtd_oem_preseed_cfg_Localization "$SAVETO" ;;
			7) rtd_oem_preseed_cfg_EFI "$SAVETO" ;;
			8) rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO" ;;
			9) rtd_oem_preseed_cfg_Disk_Layout "$SAVETO" ;;
			10) rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG" ;;
			11) rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO" ;;
			esac
		done
}






































#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
#            . _..::__:  ,-"-"._        |7       ,     _,.__
#    _.___ _ _<_>`!(._`.`-.    /         _._     `_ ,_/  '  '-._.---.-.__
# >.{     " " `-==,',._\{  \  / {)      / _ ">_,-' `                mt-2_
#   \_.:--.       `._ )`^-. "'       , [_/(                       __,/-'
#  '"'     \         "    _L        oD_,--'                )     /. (|
#           |           ,'          _)_.\\._<> 6              _,' /  '
#           `.         /           [_/_'` `"(                <'}  )
#            \\    .-. )           /   `-'"..' `:.#          _)  '
#     `        \  (  `(           /         `:\  > \  ,-^.  /' '
#               `._,   ""         |           \`'   \|   ?_)  {\
#                  `=.---.        `._._       ,'     "`  |' ,- '.
#                    |    `-._         |     /          `:`<_|h--._
#                    (        >        .     | ,          `=.__.`-'\
#                     `.     /         |     |{|              ,-.,\     .
#                      |   ,'           \   / `'            ,"     \
#                      |  /              |_'                |  __  /
#                      | |                                  '-'  `-'   \.
#                      |/                                         "    /
#                      \.                                             '

#                       ,/            ______._.--._ _..---.---------._
#      ,-----"-..?----_/ )      __,-'"             "                  (
# -.._(                  `-----'                                       `-
# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----


#  ----------------------------------------------------------------
# __     ___      _               _   __  __            _     _
# \ \   / (_)_ __| |_ _   _  __ _| | |  \/  | __ _  ___| |__ (_)_ __   ___
#  \ \ / /| | '__| __| | | |/ _` | | | |\/| |/ _` |/ __| '_ \| | '_ \ / _ \
#   \ V / | | |  | |_| |_| | (_| | | | |  | | (_| | (__| | | | | | | |  __/
#    \_/  |_|_|   \__|\__,_|\__,_|_| |_|  |_|\__,_|\___|_| |_|_|_| |_|\___|

#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
#  ----------------------------------------------------------------











test_iso_boot_media ()
{
# Description: Function to test a created ISO file by booting it in a temporary VM using QEMU.
# This function requires one argument or one variable (iso_test) to be set; since it needs
# to now what media to test.
#
# QEMU is a free and open-source emulator and virtualizer that
# can perform hardware virtualization. QEMU is a hosted virtual machine monitor: it emulates
# the machine's processor through dynamic binary translation and provides a set of different
# hardware and device models for the machine, enabling it to run a variety of
# guest operating systems.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# test_iso_boot_media /path/to/media
# 	OR
# iso_test=/path/to/media
# test_iso_boot_media
#
# End of Documentation
	iso_test="${1}"
	if [[ -z "${iso_test}" ]]; then
		dialog::display_error "${FUNCNAME[0]}: requires one argument (ISO file to test). Please read ${_LOGFILE} for more information."
		return 1
	else
		system::log_item "Testing ${iso_test}..."
		if ($RTD_GUI --title "BOOT Media Testing" --yesno "\n Would you like to test your boot media ${iso_test} to see if it works?" 10 80); then
			clear
			write_information "TESTING ${iso_test}."
			if ! hash qemu-system-x86_64 ; then check_dependencies qemu-system-x86_64 ; fi
			: "${bin_qemu_img:=$(type -P qemu-img)}"
			: "${bin_qemu_system_x86_64:=$(type -P qemu-system-x86_64 )}"
			: "${put_qcow_file_here_when_done:="/home/$SUDO_USER/Virtual-HDs"}"
			: "${qcow2_file:="${put_qcow_file_here_when_done}/$(basename "$iso_test" .iso).qcow2"}"

			system::log_item "executing command: ${bin_qemu_img} create -f qcow2 ${qcow2_file} 10G"

			[[ -f ${qcow2_file} ]] && rm -f "${qcow2_file}"
			if ${bin_qemu_img} create -f qcow2 "${qcow2_file}" 10G 2>&1 | tee -a "${_LOGFILE}" ; then 
				write_information "Created QCOW2 file: ${qcow2_file}"
			else
				write_error "Failed to create QCOW2 file: ${qcow2_file}"
			fi

			system::log_item "Executing command: ${bin_qemu_system_x86_64} -smp 2 -enable-kvm -m 4G --cdrom ${iso_test} ${qcow2_file}" 
			if ${bin_qemu_system_x86_64} -smp 2 -enable-kvm -m 4G --cdrom "${iso_test}" "${qcow2_file}" 2>&1 | tee -a "${_LOGFILE}" ; then
				write_information "Successfully tested ${iso_test}."
			else
				write_error "Failed to test ${iso_test}."
			fi
		else
			clear
			dialog::display_notice "User selected No, exit status was $?."
			system::log_item "User selected No, exit status was $?."
		fi
	fi
}







make_kvm_virtual_machine_now_from_fedora_org ()
{
# Description: Function to create a Fedora KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals: ${FedoraVersion} ${PRESEED_FILE}
# Optional arguments: workstation|ssh-server|ansible-server [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]
# Outputs: std err
# Returns: 
# Usage:
# 	make_kvm_virtual_machine_now_from_fedora_org
# 			or
# 	make_kvm_virtual_machine_now_from_fedora_org -c 4 -m 4096 -d 100
# End of Documentation

	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	local OPTIND o a
	while getopts ':c:m:d:' OPTION; do
		case "$OPTION" in
		c )
			local _cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			local _mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			local _dsk="${OPTARG}"
			write_information "Custom disk sizee set to: ${OPTARG}"
		;;
		? )
			write_host --cyan  "Usage: ${FUNCNAME[0]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]"
			return 0
		;;
		esac
	done
	unset OPTIND

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: ${virt_net="$(system::find_vm_bridge)"}
	: ${BIN_VIRT_INSTALL:=$(type -p virt-install)}
	: ${_os_version=$( $RTD_GUI --title "Select Release Version of Fedora" --inputbox "Please pick an available OS version by entering it below. \
	If you are not sure just let me choose for you... \n ${fedoralogo} "  25 110 "${_DEFAULT_FEDORA_VER}" 3>&1 1>&2 2>&3)}
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	: ${_os_version:="${_DEFAULT_FEDORA_VER}"}
	: ${_mirrorlist_url="https://mirrors.fedoraproject.org/mirrorlist?repo=fedora-${_os_version}&arch=x86_64"}
	: ${_source_url:="https://dl.fedoraproject.org/pub/fedora/linux/releases/${_os_version}/Everything/x86_64/os/"}
	: ${_preseed_file="$( mktemp ).cfg"}
	: ${_config="${1:-"workstation"}"}
	system::generate_ks_cfg_file -u "${_source_url}" -c "${_config}" -p "${_preseed_file}" -e "@workstation-product-environment"

	local vm_name="#Template_VDI_Fedora_"${_config}"_"${RANDOM}""

	_summary_message="The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${_preseed_file} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${_source_url} \n
	ðŸŒŽ - ${_mirrorlist_url} \n
	âœ… - Using the network: ${virt_net:=default} \n
	âœ… - Memory: ${_mem} \n
	âœ… - CPU's: ${_cpu} \n
	âœ… - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I)"

	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant="fedora30" \
		--initrd-inject="${_preseed_file}" \
		--location="${_source_url}" \
		--extra-args "inst.ks=file:/$(basename $_preseed_file)" \
		--noautoconsole && dialog::display_summary_message "NOTICE!" \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	for i in  _preseed_file vm_kernel vm_initrd _source_url _config _mirrorlist_url _os_version _summary_message ; do unset $i ; done
}







kvm::make_vm_template_now_from_redhat_com ()
{
# Description: Function to create a Alma Linux KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals: ${FedoraVersion} ${PRESEED_FILE}
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	local OPTIND o a
	while getopts ':c:m:d:' OPTION; do
		case "$OPTION" in
		c )
			local _cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			local _mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			local _dsk="${OPTARG}"
			write_information "Custom disk sizee set to: ${OPTARG}"
		;;
		? )
			write_host --cyan  "Usage: ${FUNCNAME[0]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]"
			return 0
		;;
		esac
	done
	unset OPTIND

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: ${virt_net="$(system::find_vm_bridge)"}
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: ${_os_version:-$( $RTD_GUI --title "Select Release Version of RedHat" --inputbox "Please pick an available OS version by entering it below. \
	If you are not sure just let me choose for you... \n ${fedoralogo} "  25 110 "${_DEFAULT_REDHAT_VER}" 3>&1 1>&2 2>&3)}
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	: ${_os_version:="${_DEFAULT_REDHAT_VER}"}
	: ${_mirrorlist_url="https://mirrors.almalinux.org/mirrorlist/${_os_version}/baseos"}
	: ${_source_url="https://repo.almalinux.org/almalinux/${_os_version}/BaseOS/x86_64/kickstart/"}
	: ${_preseed_file="$( mktemp ).cfg"}
	: ${_config="${1:-"workstation"}"}
	system::generate_ks_cfg_file -u "${_source_url}" -c "${_config}" -p "${_preseed_file}" -e "@workstation-product-environment"

	local vm_name="RedHat_${_config}_${RANDOM}"

	_summary_message="The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${_preseed_file} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${_source_url} \n
	ðŸŒŽ - ${_mirrorlist_url} \n
	âœ… - Using the network: ${virt_net:=default} \n
	âœ… - Memory: ${_mem} \n
	âœ… - CPU's: ${_cpu} \n
	âœ… - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I)"

	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant="fedora30" \
		--initrd-inject="${_preseed_file}" \
		--location="${_source_url}" \
		--extra-args "inst.ks=file:/$(basename $_preseed_file)" \
		--noautoconsole && dialog::display_summary_message "NOTICE!"  \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	for i in  _preseed_file vm_kernel vm_initrd _source_url _config _mirrorlist_url _os_version ; do unset $i ; done
}






make_kvm_virtual_machine_now_from_opensuse_org ()
{
# Description: Function to create a SUSE KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	local OPTIND o a
	while getopts ':c:m:d:' OPTION; do
		case "$OPTION" in
		c )
			local _cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			local _mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			local _dsk="${OPTARG}"
			write_information "Custom disk sizee set to: ${OPTARG}"
		;;
		? )
			write_host --cyan  "Usage: ${FUNCNAME[0]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]"
			return 0
		;;
		esac
	done
	unset OPTIND

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	: ${virt_net="$(system::find_vm_bridge)"}
	: ${source_url:="${_SUSE_LEAP_SOURCE}"}

	local vm_name="SUSE_${CONFIG}_${RANDOM}"

	_summary_message="The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${source_url} \n
	ðŸŒŽ - ${vm_kernel:="DEFAULT"} \n
	ðŸŒŽ - ${vm_initrd:="DEFAULT"} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${_mem} \n
	âœ… - CPU's: ${_cpu} \n
	âœ… - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I))"

	# create image and run installer
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--os-variant=opensusetumbleweed \
		--initrd-inject="${PRESEED_FILE}" \
		--location="${source_url}" \
		--extra-args "AutoYaST=file:///$(basename ${PRESEED_FILE})"   \
		--noautoconsole && dialog::display_summary_message "NOTICE!"  \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	for i in  PRESEED_FILE vm_kernel vm_initrd source_url CONFIG ; do unset $i ; done
}








kvm::make_vm_template_now_from_debian_org ()
{
# Description: Function to create a Debian KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	system::process_vm_opt_args "${@}"

	# Set default values for VM T-Shirts sizes (may vary by OS)...
	: ${_role:="desktop"}
	: ${_task:="ssh-server"}
	: ${_cpu:="${_cpu:=2}"}
	: ${_mem:="${_mem:=2048}"}
	: ${_dsk:="${_dsk:=100}"}


	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet, and set variables.
	: "${bin_virt_install:=$(type -p virt-install)}"

	# Create a preseed file for the Debian installer
	#                           <gnome-desktop>   <dir path>     <minecraft>
	system::make_preseed_cfg -r "${_role}" -p "$( mktemp -d)" -t ${_task}


	case "${_role}" in
		desktop | Desktop | gnome-desktop | kde-desktop | lxde-desktop | xfce-desktop | mate-desktop | cinnamon-desktop )
				: "${vm_kernel="${_DEBIAN_FRONTEND_GTK_KERNEL}"}"
				: "${vm_initrd="${_DEBIAN_FRONTEND_GTK_INITRD}"}"
				: "${ui_diplay_style="theme=dark"}"
				: "${vm_usecase="VDI"}"
				;;
		* )
				: "${vm_kernel="${_DEBIAN_FRONTEND_DEFAULT_KERNEL}"}"
				: "${vm_initrd="${_DEBIAN_FRONTEND_DEFAULT_INITRD}"}"
				: "${ui_diplay_style="theme=light"}"
				: "${vm_usecase="Server"}"
				;;
		*)	;;
	esac

	write_status "ðŸ”Ž 	- Discovering what the appropriate VM net interface is (default or br'0 - n')"
	: ${virt_net="$(system::find_vm_bridge)"}
	: ${source_url:="${_DEBIAN_SOURCE_URL}"}

	local vm_name="#Template_Debian_${_task}_${vm_usecase}_$(date +%Y-%m-%d-%H-%M)"

	_summary_message="The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${source_url} \n
	ðŸŒŽ - ${vm_kernel} \n
	ðŸŒŽ - ${vm_initrd} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${_mem} \n
	âœ… - CPU's: ${_cpu} \n
	âœ… - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I))"


	# create image and run installer
	"${bin_virt_install}" --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--location="${source_url}" \
		--os-variant="debian10" \
		--video "virtio" --channel "spicevmc" \
		--initrd-inject="${PRESEED_FILE}" \
		--install kernel="${vm_kernel}",initrd="${vm_initrd}" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE) ${ui_diplay_style}" \
		--noautoconsole && dialog::display_summary_message "NOTICE!"  \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	for i in  PRESEED_FILE vm_kernel vm_initrd source_url CONFIG ui_diplay_style ; do unset $i ; done
}







kvm::make_vm_template_now_from_ubuntu_com ()
{
# Description: Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual machine disk images.
# QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]
# Outputs:
# Returns:
# Usage: kvm::make_vm_template_now_from_ubuntu_com (optional arguments)
#
# Example:	(may be set otherwise defaults are used)
#               
# kvm::make_vm_template_now_from_ubuntu_com [-c <#CPU>, -m <MB RAM>, -d <GB Disk>, -r <server|desktop>, -t <task>]
#
# If complete flexibility is needed simply use the virt-install binary and directly write the arguments.However
# this function is designed to make it easier to create a VM template by using the defaults and only changing
# the arguments that are needed.For example, if you want to create a VM template for a Ubuntu 20.04 desktop
# with 4 CPUs, 8GB of RAM and 100GB of disk space you would use the following command:
# kvm::make_vm_template_now_from_ubuntu_com -c 4 -m 8192 -d 100 -r desktop -t ubuntu-desktop
#
# Alternatively; edit the function with new defaults that suit the needs.
# End of Documentation


	# Evaluate override arguments to defaults...
	system::process_vm_opt_args "${@}"

	# Set default values for VM T-Shirts sizes (may vary by OS)...
	: ${ubuntu_flavor="ubuntu"}
	: ${_role:="desktop"}
	: ${_task:="ssh-server"}
	: ${_cpu:="${_cpu:=2}"}
	: ${_mem:="${_mem:=2048}"}
	: ${_dsk:="${_dsk:=100}"}

	dependency::virtualization

	# Fetch the relevand ISO if necessary...
	system::log_item "ðŸ”Ž Retreive list of available $ubuntu_flavor $_role versions..."

	declare -a all_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))
	dist_logo="$ubuntulogo"

	tgt_ubuntu_ver=$($RTD_GUI --colors --title "Select Release Version of $ubuntu_flavor $_role" --inputbox "\n ðŸ‘ Please pick an available \Z1 $ubuntu_flavor \Zn version by entering it below.
	Long Term Support Versions to choose from are the following:\Z4 ${all_lts_versions[*]} \Zn You may also enter an inbetween release version
	by typing its release number below as well. If you are not sure just let me choose intelligently for you... \n \Z1 ${dist_logo} \Zn"  30 90 "${all_lts_versions[-1]}" 3>&1 1>&2 2>&3)
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	# Return the version number selected
	[ "$tgt_ubuntu_ver" ] || tgt_ubuntu_ver=${all_lts_versions[-1]}

	# Set the role to server if the Ubuntu version is 23 or greater force using server media (using subiquity)...
	if [[ ${tgt_ubuntu_ver::2} -ge 23 ]] ; then
		system::log_item "Ubuntu version ${tgt_ubuntu_ver}: Using subiquity installer..."
		if [[ "${_role}" == "desktop" ]] ; then
			system::log_item "Ubuntu role = desktop: changing to server media due to subiquity..."
			system::generate_cloudconfig
		fi
	else
		${_saveto:="$( mktemp -d)"}
		system::log_item "Ubuntu version ${tgt_ubuntu_ver}: Using debian installer (d-i)..."
		system::make_preseed_cfg -r "${_role}" -p ${_saveto} -t ${_task}
	fi

	# Set key vars of where to find ubuntu ISO files...
	system::log_item "ðŸ”Ž Issuing search command: rtd_oem_find_live_release ${tgt_ubuntu_ver} ${ubuntu_flavor} ${_role}"
	: ${ubuntu_iso_url=$(rtd_oem_find_live_release ${tgt_ubuntu_ver} ${ubuntu_flavor} ${_role})}
	: ${iso_filename:="$(basename $ubuntu_iso_url)"}
	: ${permanent_download_dir:="/var/lib/libvirt/boot/"}
	
	# Ensure that the file is available for VM creation... 
	write_status "Checking if $iso_filename already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$iso_filename")
	if [ ! -e "$iso" ]; then
		write_warning "$iso_filename is not in cache, downloading..."
		wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "FATAL Problem: Failure to download ISO file $ubuntu_iso_url"
		iso="$permanent_download_dir/$iso_filename"
	fi

	# Detect and set variables for key programs
	: ${bin_virt_install:=$(type -p virt-install)}
	: ${virt_net="$(system::find_vm_bridge)"}
	local vm_name="#Template_${_task}-${tgt_ubuntu_ver}-$(date +%Y-%m-%d-%s)"

	
	
	_summary_message="
	The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} ${CloudConfig}\n
	ðŸ”§ - Configuring the following VM: \n
			${vm_name} \n
			cpus "${_cpu}" \n
			memory "${_mem}" \n
			network "${virt_net}" \n
			disk size="${_dsk}" \n
			disk= ${CloudConfig}/cidata.iso,device=cdrom \n
			os-variant="$tgt_ubuntu_ver" \n
			video= "virtio" --channel "spicevmc" \n
			Source="${iso}" \n
			kernel="casper/vmlinuz,initrd=casper/initrd" "
	system::log_item "${_summary_message}"

	# Create the appropriate VM as requested...
	case $_role in 
		server )
			system::log_item "Ubuntu version ${tgt_ubuntu_version}: Running install options for subiquity..."
			"${bin_virt_install}" --name ${vm_name} \
				--vcpus "${_cpu}" \
				--memory "${_mem}" \
				--network "${virt_net}" \
				--disk size="${_dsk}" \
				--os-variant="ubuntu21.10" \
				--video "virtio" --channel "spicevmc" \
				--disk path="${CloudConfig}/cidata.iso,device=cdrom" \
				--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
				--extra-args="autoinstall" \
				--noautoconsole  |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"  \
			|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
		;;
		desktop )
			system::log_item "Ubuntu version ${tgt_ubuntu_version}: Running install options for debian installer (d-i)..."
			"${bin_virt_install}" --name ${vm_name} \
				--vcpus "${_cpu}" \
				--memory "${_mem}" \
				--network "${virt_net}" \
				--disk size="${_dsk}" \
				--os-variant="ubuntu21.10" \
				--video "virtio" --channel "spicevmc" \
				--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
				--extra-args="ks=file:${_saveto}/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us \
				netcfg/get_hostname=${_task}${tgt_ubuntu_ver} console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US \
				localechooser/supported-locales=en_US.UTF-8 ubiquity/use_nonfree=true boot=casper automatic-ubiquity splash noprompt " \
				--initrd-inject="${_saveto}/preseed.cfg" \
				--initrd-inject="${_saveto}/ks.cfg" \
				--noautoconsole |tee -a ${_LOGFILE} && dialog::display_summary_message "NOTICE!"  \
			|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
		;;
		* ) write_error "Unknown option requested!"
		;;
	esac

	# Clean up residual variables...
	for i in  PRESEED_FILE vm_kernel vm_initrd source_url _task _role _cpu _dsk _mem tgt_ubuntu_ver ubuntu_iso_url iso_filename CloudConfig _summary_message ; do unset $i ; done
}










make_kvm_virtual_machine_now_from_microsoft ()
{
# Description:
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on. In the future
# scripting will be added to allow for acting on remote machines directly...
# At this time this functio takes no arguments but will prompt for what it needs if it is not available.
#
# Globals:
# Arguments: [ win11 | win10 | win8 | win7 ]
# Outputs: One VM running windows
# Returns:
# Usage: make_kvm_virtual_machine_now_from_microsoft target_winver
#
#
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation
	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	local OPTIND o a
	while getopts ':c:m:d:' OPTION; do
		case "$OPTION" in
		c )
			local _cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			local _mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			local _dsk="${OPTARG}"
			write_information "Custom disk sizee set to: ${OPTARG}"
		;;
		? )
			write_host --cyan  "Usage: ${FUNCNAME[0]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]"
			return 0
		;;
		esac
	done
	unset OPTIND

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-4098}"}
	: ${_dsk="${_dsk:-100}"}

	: ${target_winver="${1:-win10}"} || read -p "ðŸ’¥ - Failure to set variable target_winver"
	case $target_winver in
		win12 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win11_English_x64.iso"} 
			: ${uefi_option="--boot uefi"} 
			;;
		win11 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win11_English_x64.iso"} 
			: ${uefi_option="--boot uefi"} 
			;;
		win10 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win10_English_x64.iso"} ;;
		win8 )  : ${WindowsMedia="/var/lib/libvirt/boot/Win8_English_x64.iso"}  ;;
		win7 ) : ${WindowsMedia="/var/lib/libvirt/boot/Win7_English_x64v1.iso"} ;;
	esac

	: ${BIN_VIRT_INSTALL:="$(type -p virt-install)"}
	: ${CONFIG:="Workstation"}
	: ${WindowsInstructions:="/var/lib/libvirt/boot/win$(date +%Y-%m-%d-%H-%M-%S-%s).img"}
	: ${virt_net="$(system::find_vm_bridge)"}
	: ${AutoUnattend="/tmp/autounattend.xml"}
	: ${PostTasks="/tmp/rtd-me-sh.cmd"}
	: ${preferred_video="${5:-"qxl"}"}

	if [[ ! -e "${WindowsMedia}" ]]; then
		if ( $RTD_GUI --backtitle "..$BRANDING" --title "Windows Install Media Needed" \
			--no-button "NO: Just Cancel" \
			--yes-button "OK: I am done upploading" \
			--yesno "Windows install media was not found where expected ${WindowsMedia} \n Please place a copy of it in /home/$SUDO_USER/ and press [ OK ] \n Please name it Win**something**.iso NOTE: you can download Windows from Microsoft for free" 20 90 );
		then
			if ls /home/$SUDO_USER/Win*.iso ; then
				mv -v /home/$SUDO_USER/Win*.iso ${WindowsMedia} || rtd_oem_pause 1S
			else
				write_error "Could not find the file: /home/$SUDO_USER/Downloads/Win*.iso "
				rtd_oem_pause 1
				return
			fi
		else
			return
		fi
	fi

	if [[ ! -e "${WindowsInstructions}" ]]; then
		write_information "Generate Windows Instruction media..."
			if ! hash mkfs.msdos ; then check_dependencies dosfstools ; fi
			mkfs.msdos -C ${WindowsInstructions} 1440 || rtd_oem_pause 1

		write_information "Generate installations instructions for Windows..."
			generate_autounattend_xml "${AutoUnattend}" || rtd_oem_pause 1

		write_information "Generate post install bootstrap script..."
			generate_rtd_me_sh_cmd ${PostTasks}
			if ! hash mcopy ; then check_dependencies mtools ; fi
			mcopy -i ${WindowsInstructions} ${PostTasks} ::/ || rtd_oem_pause 1
			mcopy -i ${WindowsInstructions} ${AutoUnattend} ::/ || rtd_oem_pause 1

		for i in ${_OEM_DIR}/modules/windows.mod/_* ; do
			mcopy -i ${WindowsInstructions} ${i} ::/ || rtd_oem_pause 1
		done
	fi

	local vm_name="Windows${target_winver:(-2)}_${CONFIG}_${RANDOM}"

	_summary_message="The virtual machine (${vm_name}) \n
	ðŸ“‹ - Using the instructions in: ${AutoUnattend} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${WindowsMedia} \n
	ðŸŒŽ - ${WindowsInstructions} \n
	ðŸŒŽ - ${PostTasks} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${_mem} \n
	âœ… - CPU's: ${_cpu} \n
	âœ… - Disk Size: ${_dsk} \n You may attach to this server and see the progress at IP: $(hostname -I))"

	write_status "Creating and starting Virtual machine... "
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name "${vm_name}" \
		--vcpus "${_cpu}" \
		--memory "${_mem}" \
		--network "${virt_net}" \
		--disk size="${_dsk}" \
		--video ${preferred_video} \
		--os-variant="$( if osinfo-query -s -f os |grep ${target_winver} &>/dev/null ; then echo ${target_winver} ; else echo win10 ; fi )" \
		--cdrom "${WindowsMedia}" \
		--disk "${WindowsInstructions}",device=floppy \
		--livecd \
		--tpm default \
		${uefi_option} \
		--noautoconsole && dialog::display_summary_message "NOTICE!"  \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	for i in WindowsInstructions CONFIG WindowsMedia AutoUnattend PostTasks target_winver mem_size uefi_option cpu_count disk_size preferred_video ; do unset $i ; done
}







make_kvm_virtual_machine_now_from_iso ()
{
# Description: Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	dependency::virtualization

	# Check for optional default T-Shirts size overrides... 
	local OPTIND o a
	while getopts ':c:m:d:' OPTION; do
		case "$OPTION" in
		c )
			local _cpu="${OPTARG}"
			write_information "Custom CPU set to: ${OPTARG}"
		;;
		m )
			local _mem="${OPTARG}"
			write_information "Custom memory set to: ${OPTARG}"
		;;
		d )
			local _dsk="${OPTARG}"
			write_information "Custom disk sizee set to: ${OPTARG}"
		;;
		? )
			write_host --cyan  "Usage: ${FUNCNAME[0]} or ${FUNCNAME[0]} [-c <#CPU>, -m <MB RAM>, -d <GB Disk>]"
			return 0
		;;
		esac
	done
	unset OPTIND

	# Set default values for VM T-Shirts sizes...
	: ${_cpu="${_cpu:-2}"}
	: ${_mem="${_mem:-2048}"}
	: ${_dsk="${_dsk:-100}"}

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: "${target_iso:="/var/lib/libvirt/boot/ubuntu-21.04-desktop-amd64.iso"}"

	#Verify ISO presesnce
		if [[ ! -f "$target_iso" ]]; then
			$RTD_GUI --backtitle "${BRANDING:-"rtd"}" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
			clear
		fi
	# Discover if the appropriate VM net interface is (default or br'0 - n')
	: ${virt_net="$(system::find_vm_bridge)"}
	_summary_message="
	--vcpus ${2:-"2"}
	--memory ${3:-"2048"}
	--network ${virt_net}
	--disk size=${4:-"30"}
	--os-variant=${1:-"ubuntu20.04"}
	--location=${target_iso}
	--cdrom=${target_iso}
	--initrd-inject=$PRESEED_FILE
	--extra-args ks=file:/$(basename $PRESEED_FILE)"

	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Ubuntu_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${virt_net}" \
		--disk size="${4:-30}" \
		--os-variant="${1:-debian10}" \
		--cdrom="${target_iso}" \
		--cloud-init meta-data=
		--noautoconsole &&  dialog::display_summary_message "NOTICE!"  \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
}





backup_running_vm ()
{
# Description:
# Function to back up all running virtual machines on the host it is being run on.
# This function should be called from within this script and does not require any
# arguments passed.
#
# Globals: ${VM_BACKUP_TARGET} (defaults to /mnt/vmdsk/VM_BACKUP)
# Arguments: None
# Outputs: Backups of running vm's.
# Returns:
# Usage:
#
# backup_running_vm
#
# End of documentation

	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=$(date +%Y-%m-%d.%H:%M:%S)
		LOG="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=$(virsh list --all | grep $DOMAIN | awk '{print $3}')
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if [[ ! -d $BACKUPFOLDER ]] ; then
				$RTD_GUI
			fi
			mkdir -p "$BACKUPFOLDER"
			TARGETS="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $3}')"
			IMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain "$DOMAIN" --name "backup-$DOMAIN" --no-metadata --atomic --disk-only "$DISKSPEC" >> "$LOG"
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > "$LOG"
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > "$LOG"
				rsync -apvz --inplace "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				else
				echo "Backup does not exist, creating a full sparse copy" > "$LOG"
				rsync -apvz --sparse "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				fi
			done

			BACKUPIMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			for TARGET in $TARGETS; do
				if virsh blockcommit "$DOMAIN" "$TARGET" --active --pivot >> "$LOG"; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > "$LOG"
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > "$LOG"
				rm -f "$BACKUP"
				fi
			done

			virsh dumpxml "$DOMAIN" > "$BACKUPFOLDER"/"$DOMAIN".xml
			echo "-----------WORKER END $DOMAIN-----------" >> "$LOG"
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> "$LOG"
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}












#                        ---
#                     -        --
#                 --( /     \ )XXXXXXXXXXXXX
#             --XXX(   O   O  )XXXXXXXXXXXXXXX-
#            /XXX(       U     )        XXXXXXX\
#          /XXXXX(              )--   XXXXXXXXXXX\
#         /XXXXX/ (      O     )   XXXXXX   \XXXXX\
#         XXXXX/   /            XXXXXX   \   \XXXXX----
#         XXXXXX  /          XXXXXX         \  ----  -
# ---     XXX  /          XXXXXX      \           ---
#   --  --  /      /\  XXXXXX            /     ---=
#     -        /    XXXXXX              '--- XXXXXX
#       --\/XXX\ XXXXXX                      /XXXXX
#         \XXXXXXXXX                        /XXXXX/
#          \XXXXXX                         /XXXXX/
#            \XXXXX--  /                -- XXXX/
#             --XXXXXXX---------------  XXXXX--
#                \XXXXXXXXXXXXXXXXXXXXXXXX-
#                  --XXXXXXXXXXXXXXXXXX-

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Internal Confgiration Repository      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.













generate_rtd_me_sh_cmd ()
{
# Description:
# Generates an unattended install instruction file for Windows systems.
# As documentation at microsoft for CMD shell scripting is limited see the below suggestion:
# Reference https://www.amazon.com/Windows-Shell-Scripting-Timothy-Hill/dp/1578700477
# for more information.
#
# Globals:
# Arguments: [directory path]
# Outputs: one rtd-me.cmd.sh flobal bootsrap script
# Returns: na
# Usage:
#
# generate_rtd_me_sh_cmd /location/to/place/fiile
#
#
# NOTE: This file is generated from this library to limit the dependecies on external downloads.
# End of documentation

	cat > $1 <<-'EOF'
	#!/bin/bash
	cls
	:<<"::CMDLITERAL"
	@ECHO OFF
	GOTO :CMDSCRIPT
	::CMDLITERAL

	echo	[internal]	-	RTD System System Managment Bootstrap Script      -	[internal]
	#::
	#::
	#:: 						Shell Script Section
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
	#:: Version:	1.06
	#::
	#::
	#:: Purpose: 	The purpose of the script is to decide what scripts to download based
	#::          	on the host OS found; works with both Windows, MAC and Linux systems.
	#::		The focus of this script is to be compatible enough that it could be run on any
	#::		system and compete it's job. In this case it is simply to identify the OS
	#::		and get the appropriate script files to run on the system in question;
	#::		In its original configuration this bootstrap script was used to install and
	#::		configure software appropriate for the system in question. It accomplishes this
	#::		by using the idiosyncrasies of the default scripting languages found in
	#::		the most popular operating systems around *NIX (MAC, Linux, BSD etc.) and
	#::		CMD (Windows NT, 2000, 2003, XP, Vista, 8, and 10).
	#::
	#::
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#

	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are
	# set here. There should be no reason to change any of this.

	# Ensure administrative privileges.
	[ "$UID" -eq 0 ] || echo -e $YELLOW "This script needs administrative access..." $ENDCOLOR
	[ "$UID" -eq 0 ] || exec sudo DISPLAY=$DISPLAY bash "$0" "$@"

	# Put a convenient link to the logs where logs are normally found...
	# capture the 3 first letters as org TLA (Three Letter Acronym)
	export _SCRIPTNAME=$(basename $0)
	export _TLA=${_SCRIPTNAME:0:3}
	export _LOG_DIR=/var/log/${_TLA}
	mkdir -p ${_LOG_DIR}

	# Set the GIT profile name to be used if not set elsewhere:
	export _GIT_PROFILE="${_GIT_PROFILE:-vonschutter}"

	# Location of base administrative scripts and command-lets to get.
	_src_url=https://github.com/${_GIT_PROFILE}/${_TLA^^}-Setup.git

	# Determine log file names for this session
	export _ERRLOGFILE=${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup-error.log
	export _LOGFILE${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup.log
	export _STATUSLOG=${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup-status.log


	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Execute tasks                   ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	#:: Given that Bash or other Shell environment has been detected and the POSIX chell portion of this script is executed,
	#:: the second stage script must be downloaded from an online location. Depending on the distribution of OS
	#:: there are different methods available to get and run remote files.
	#::
	#:: Table of evaluating family of OS and executing the appropriate action fiven the OS found.
	#:: In this case it is easier to manage a straight table than a for loop or array:

	if echo "$OSTYPE" |grep "linux" ; then
		echo "Linux OS Found: Attempting to get instructions for Linux..."
		echo executing $0 >> ${_LOGFILE}
		for d in git zip ; do 
			if ! hash ${d} &>> ${_LOGFILE} ; then
				for pkgmgr in apt yum dnf zypper ; do hash ${pkgmgr} && ${pkgmgr} -y install ${d} | tee ${_LOGFILE} ; done
			fi
		done
		git clone --depth=1 ${_git_src_url} /opt/${_TLA,,}.tmp | tee ${_LOGFILE}
			if [ $? -eq 0 ]
			then
				echo "Instructions successfully retrieved..."
				if [[ -d /opt/${_TLA,,}  ]] ; then
					mv /opt/${_TLA,,} ${_BackupFolderName:="/opt/${_TLA,,}.$(date +%Y-%m-%d-%H-%M-%S-%s).bakup"}
					zip -m -r -5 ${_BackupFolderName}.zip  ${_BackupFolderName}
					rm -r ${_BackupFolderName}
				fi
				mv /opt/${_TLA,,}.tmp /opt/${_TLA,,} ; rm -rf /opt/${_TLA,,}/.git
				source /opt/${_TLA,,}/core/_rtd_library
				oem::register_all_tools
				ln -s -f ${_LOG_DIR} -T ${_OEM_DIR}/log
				bash ${_OEM_DIR}/core/rtd-oem-linux-config.sh ${@}
			else
				echo "Failed to retrieve instructions correctly! "
				echo "Suggestion: check write permission in "/opt" or internet connectivity."
				exit 1
			fi
		exit $?
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		echo "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		echo "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		echo "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
	else
	echo "This system is Unknown to this script"
	fi
	exit $?


	# -----------------------------------------------------------------------------------------------------------------------
	# Anything after this exit statment below will be dangerous and meaningless
	# command syntax to POSIX based systems...
	# Make sure to exit no matter what...
	exit $?
	:CMDSCRIPT
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	@echo off
	echo			-	RTD System System Managment Bootstrap Script      -
	::
	::
	::					Windows CMD Shell Script Section
	::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	:INIT
		:::::::::::::::::::::::::::::::::::::::::::::::::::
		::	Script startup components; tasks that always
		::	need to be done when the initializes.
		::
		ECHO Welcome to %COMSPEC%
		ECHO This is a windows script!
		:: setlocal &  pushd %~dp0
		:: %debug%

	:SETINGS
		::::::::::::::::::::::::::::::::::::::::::::::::::::::
		::  ***             Settings               ***      ::
		::::::::::::::::::::::::::::::::::::::::::::::::::::::
		::
		set temp=c:\rtd\temp
		::if not exit %temp% md %temp%
		::set _LOGDIR=c:\rtd\log
		::if not exist %_LOGDIR% md %_OGDIR%
		set _STAGE2LOC=https://raw.githubusercontent.com/vonschutter/RTD-Setup/main/core/
		set _STAGE2FILE=rtd-oem-win10-config.ps1
		echo Stage 2 file is located at:
		echo %_STAGE2LOC%\%_STAGE2FILE%


	:GetInterestingThigsToDoOnThisSystem
		:: Given that Microsoft Windows has been detected and the CMD chell portion of this script is executed,
		:: the second stage script must be downloaded from an online location. Depending on the version of windows
		:: there are different methods available to get and run remote files. All versions of windows do not neccesarily
		:: support powershell scripting. Therefore the base of this activity is coded in simple command CMD.EXE shell scripting
		::
		:: Table of evaluating verson of windos and calling the appropriate action fiven the version of windows found.
		:: In this case it is easier to manage a straight table than a for loop or array:

		:: DOS Based versions of Windows:
		:: ver | find "4.0" > nul && goto CMD1 	rem Windows 95
		:: ver | find "4.10" > nul && goto CMD1 rem Windows 98
		:: ver | find "4.90" > nul && goto CMD1	rem Windows ME

		:: Windows 32 and 64 Bit versions:
		ver | find "NT 4.0" > nul && call :CMD1 Windows NT 4.0
		ver | find "5.0" > nul && call :CMD1 Windows 2000
		ver | find "5.1" > nul && call :CMD1 Windows XP
		ver | find "5.2" > nul && call :CMD1 Windows XP 64 Bit
		ver | find "6.0" > nul && call :DispErr Vista is not supported!!!
		ver | find "6.1" > nul && call :PS1 Windows 7
		ver | find "6.2" > nul && call :PS2 Windows 8
		ver | find "6.3" > nul && call :PS2 Windows 8
		ver | find "6.3" > nul && call :PS2 Windows 8
		ver | find "10.0" > nul && call :PS2 Windows 10

		:: Windows Server OS Versions:
		ver | find "NT 6.2" > nul && call :PS2 Windows Server 2012
		ver | find "NT 6.3" > nul && call :PS2 Windows Server 2012 R2
		ver | find "NT 10.0" > nul && call :PS2 Windows Server 2016 and up...

		goto end


	:PS1
		:: Procedure to get the second stage in Windows 7. Windows 7, by default has a different version of
		:: PowerShell installed. Therefore a slightly different syntax must be used.
		:: get stage 2 and run it...
		echo Found %*
		echo Fetching %_STAGE2FILE%...
		echo Please wait...
		powershell -Command "(New-Object Net.WebClient).DownloadFile('%_STAGE2LOC%\%_STAGE2FILE%', '%_STAGE2FILE%')"
		powershell -ExecutionPolicy UnRestricted -File .\%_STAGE2FILE%
		goto end


	:PS2
		:: Procedure to get the second stage configuration script in all version of windows after 7.
		:: These version of windows have a more modern version of PowerShell.
		:: get stage 2 and run it...
		echo Found %*
		echo Fetching %_STAGE2FILE%...
		echo Please wait...
		powershell -Command "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;Invoke-WebRequest %_STAGE2LOC%\%_STAGE2FILE% -OutFile %_STAGE2FILE%"
		powershell -ExecutionPolicy UnRestricted -File .\%_STAGE2FILE%
		goto end




	:CMD1
		:: Pre windows 7 instruction go here (except vista)...
		:: Windows NT, XP, and 2000 etc. do not have powershell and must find a different way to
		:: fetch a script over the internet and execute it.

		echo Detected %* ...
		echo executing PRE Windows 7 instructions...

		goto end




	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::                                          ::::::::::::::::::::::
	::::::::::::::            ERROR handling Below          ::::::::::::::::::::::
	::::::::::::::                                          ::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



	:DispErr
		set _ERRMSG=%*
		@title %0 -- !!%_ERRMSG%!!
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo ::                            Message                                          ::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo.
		echo.
		echo        %_ERRMSG%
		echo        Presently I know what to do for Linux, and Windows 7 and beyond...
		echo.
		echo ::                                                                             ::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	goto eof



	:end
	:eof

	EOF
}






generate_autounattend_xml ()
{
# Description:
# Generates an unattended install instruction file for Windows systems.
# Reference https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/automate-windows-setup
# for more information.
#
# Globals:
# Arguments: [directory path]
# Outputs: one autounattend.cfg file
# Returns: na
# Usage:
#
# generate_autounattend_xml /location/to/place/fiile
#
# End of documentation

	case $target_winver in
		win11 )
		cat > $1 <<-'EOF-GPT'
		<?xml version="1.0" encoding="utf-8"?>
	<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
	<settings pass="offlineServicing" />
	<settings pass="windowsPE">
	<component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
		<SetupUILanguage>
			<UILanguage>en-US</UILanguage>
		</SetupUILanguage>
		<InputLocale>0409:00000409</InputLocale>
		<SystemLocale>en-US</SystemLocale>
		<UILanguage>en-US</UILanguage>
		<UserLocale>en-US</UserLocale>
	</component>
	<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
	<ImageInstall>
		<OSImage>
		<InstallTo>
		<DiskID>0</DiskID>
		<PartitionID>3</PartitionID>
		</InstallTo>
		</OSImage>
	</ImageInstall>
	<UserData>
		<ProductKey>
		<Key>VK7JG-NPHTM-C97JM-9MPGT-3V66T</Key>
		</ProductKey>
		<AcceptEula>true</AcceptEula>
	</UserData>
	<RunSynchronous>
		<RunSynchronousCommand>
		<Order>1</Order>
		<Path>cmd.exe /c echo SELECT DISK=0 &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>2</Order>
		<Path>cmd.exe /c echo CLEAN &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>3</Order>
		<Path>cmd.exe /c echo CONVERT GPT &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>4</Order>
		<Path>cmd.exe /c echo CREATE PARTITION EFI SIZE=100 &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>5</Order>
		<Path>cmd.exe /c echo FORMAT QUICK FS=FAT32 LABEL="System" &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>6</Order>
		<Path>cmd.exe /c echo CREATE PARTITION MSR SIZE=16 &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>7</Order>
		<Path>cmd.exe /c echo CREATE PARTITION PRIMARY &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>8</Order>
		<Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="Windows" &gt;&gt; X:\diskpart.txt</Path>
		</RunSynchronousCommand>
		<RunSynchronousCommand>
		<Order>9</Order>
		<Path>cmd.exe /c diskpart /s X:\diskpart.txt &gt;&gt; X:\diskpart.log</Path>
		</RunSynchronousCommand>
		</RunSynchronous>
		</component>
		</settings>
		<settings pass="generalize" />
		<settings pass="specialize" />
		<settings pass="auditSystem" />
		<settings pass="auditUser" />
		<settings pass="oobeSystem">
		<component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
			<InputLocale>en-US;fr-FR;sv-SE</InputLocale>
			<SystemLocale>en-US</SystemLocale>
			<UILanguage>en-US</UILanguage>
			<UserLocale>en-US</UserLocale>
		</component>

		<component name="Microsoft-Windows-LUA-Settings" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
			<EnableLUA>false</EnableLUA>
		</component>

		<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
		<UserAccounts>
			<LocalAccounts>
			<LocalAccount wcm:action="add">
			<Name>tangarora</Name>
			<Group>Administrators</Group>
			<Password>
			<Value>letmein1234</Value>
			<PlainText>true</PlainText>
			</Password>
			</LocalAccount>
			<LocalAccount wcm:action="add">
			<Name>RTDUser</Name>
			<Group>Users</Group>
			<Password>
			<Value>letmein1234</Value>
			<PlainText>true</PlainText>
			</Password>
			</LocalAccount>
			</LocalAccounts>
		</UserAccounts>

		<OOBE>
			<ProtectYourPC>3</ProtectYourPC>
			<HideEULAPage>true</HideEULAPage>
			<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
		</OOBE>

		<AutoLogon>
			<Enabled>true</Enabled>
			<LogonCount>1</LogonCount>
			<Username>tangarora</Username>
			<Password>
			<Value>letmein1234</Value>
			<PlainText>true</PlainText>
			</Password>
		</AutoLogon>

		<FirstLogonCommands>
			<SynchronousCommand wcm:action="add">
			<CommandLine>a:\rtd-me-sh.cmd</CommandLine>
			<Description>Run Software install</Description>
			<Order>1</Order>
			</SynchronousCommand>
		</FirstLogonCommands>

		</component>
		</settings>
		</unattend>
		EOF-GPT
		;;
		* )
		cat > $1 <<-'EOF-MBR'
<?xml version="1.0" encoding="utf-8"?>
<unattend xmlns="urn:schemas-microsoft-com:unattend" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State">
  <settings pass="offlineServicing" />
  <settings pass="windowsPE">
    <component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <SetupUILanguage>
        <UILanguage>en-US</UILanguage>
      </SetupUILanguage>
      <InputLocale>0409:00000409</InputLocale>
      <SystemLocale>en-US</SystemLocale>
      <UILanguage>en-US</UILanguage>
      <UserLocale>en-US</UserLocale>
    </component>
    <component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <ImageInstall>
        <OSImage>
          <InstallTo>
            <DiskID>0</DiskID>
            <PartitionID>2</PartitionID>
          </InstallTo>
        </OSImage>
      </ImageInstall>
      <UserData>
        <ProductKey>
          <Key>VK7JG-NPHTM-C97JM-9MPGT-3V66T</Key>
        </ProductKey>
        <AcceptEula>true</AcceptEula>
      </UserData>
      <RunSynchronous>
        <RunSynchronousCommand>
          <Order>1</Order>
          <Path>cmd.exe /c echo SELECT DISK=0 &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>2</Order>
          <Path>cmd.exe /c echo CLEAN &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>3</Order>
          <Path>cmd.exe /c echo CREATE PARTITION PRIMARY SIZE=100 &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>4</Order>
          <Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="System Reserved" &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>5</Order>
          <Path>cmd.exe /c echo ACTIVE &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>6</Order>
          <Path>cmd.exe /c echo CREATE PARTITION PRIMARY &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>7</Order>
          <Path>cmd.exe /c echo FORMAT QUICK FS=NTFS LABEL="Windows" &gt;&gt; X:\diskpart.txt</Path>
        </RunSynchronousCommand>
        <RunSynchronousCommand>
          <Order>8</Order>
          <Path>cmd.exe /c diskpart /s X:\diskpart.txt &gt;&gt; X:\diskpart.log</Path>
        </RunSynchronousCommand>
      </RunSynchronous>
    </component>
  </settings>
  <settings pass="generalize" />
  <settings pass="specialize" />
  <settings pass="auditSystem" />
  <settings pass="auditUser" />
  <settings pass="oobeSystem">
    <component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <InputLocale>0409:00000409</InputLocale>
      <SystemLocale>en-US</SystemLocale>
      <UILanguage>en-US</UILanguage>
      <UserLocale>en-US</UserLocale>
    </component>
    <component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS">
      <UserAccounts>
        <AdministratorPassword>
          <Value>letmein1234</Value>
          <PlainText>true</PlainText>
        </AdministratorPassword>
        <LocalAccounts>
          <LocalAccount wcm:action="add">
            <Name>tangarora</Name>
            <Group>Administrators</Group>
            <Password>
              <Value>letmein1234</Value>
              <PlainText>true</PlainText>
            </Password>
          </LocalAccount>
          <LocalAccount wcm:action="add">
            <Name>RTDUser</Name>
            <Group>Users</Group>
            <Password>
              <Value>letmein1234</Value>
              <PlainText>true</PlainText>
            </Password>
          </LocalAccount>
        </LocalAccounts>
      </UserAccounts>
      <AutoLogon>
        <Username>Administrator</Username>
        <Enabled>true</Enabled>
        <LogonCount>1</LogonCount>
        <Password>
          <Value>letmein1234</Value>
          <PlainText>true</PlainText>
        </Password>
      </AutoLogon>
      <OOBE>
        <ProtectYourPC>3</ProtectYourPC>
        <HideEULAPage>true</HideEULAPage>
        <HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
      </OOBE>
      <FirstLogonCommands>
        <SynchronousCommand wcm:action="add">
        <CommandLine>a:\rtd-me-sh.cmd</CommandLine>
        <Description>Run Software install</Description>
        <Order>1</Order>
        </SynchronousCommand>
      </FirstLogonCommands>
    </component>
  </settings>
</unattend>
		EOF-MBR
		;;
	esac
}





rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ()
{
# Description: generates a preseed section [Ubuntu only] (ks.cfg)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: instruction for Ubuntu's convoluted support for both preseed and kickstart files.
# Usage: rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "directory"
# End of documentation
	system::log_item "Saving preeseed file as $1/ks.cfg for legacy Ubuntu installs..."
	cat $1/preseed.cfg >$1/ks.cfg
}








generate_minecraft_server_launcher ()
{
# Description: Generates preseed file to build a minecraft server.
# Globals:
# Arguments: [file location]
# Outputs: one preseed file
# Returns: error level of last command
# Usage: generate_minecraft_server_launcher /tmp/preseed.cfg
# End of documentation

cat >> $1 <<-'MINECRAFT_EOF'
	#!/bin/bash
	#::             RTD System System Managment Script
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author:     RTD Library
	#:: Version:	1.03
	#::
	#::
	#:: Purpose: The purpose of the script is to perform managment tasks on Linux systems
	#::
	#:: This is a script that will start Minecraft Server on an Ubuntu or Debian (Ubuntu) based server. It will start
	#:: multiple panes using "byobu", and start the server etc there...
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are
	# set here. There should be no reason to change any of this to setup and
	# get a working Minecraft server on Ubuntu. However, if you have updated scripts
	# and need to download yours from someplace else you only need to change these
	# setings.

	# Your Minecraft version (this is a preference only), script will always
	# get the latest Minecraft if it does not find a local server.
	MINECRAFT_VERSION=Latest

	# Your local Minecraft directory.
	MINECRAFT_HOME=~/bin/minecraft.server/Minecraft.$MINECRAFT_VERSION
	MINECRAFT_JAR=server.jar





	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Functions                ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#

	function check_dependencies (){
		# Simple function to check if software is available and take action
		# if it is not. Software name must match command to envoke it.
		#---------------------------------------------------------------
		echo "Checking for script dependencies and install if not there..."
		#---------------------------------------------------------------
		if hash "$1" 2>/dev/null; then
			echo "I found that $1 is present on this system... thankyou for that! "
		else
			echo "You seem to have no $1... I will try to get it... "
			install_software "$1"
			if [ $? != 0 ];
			then
				echo "That install didn't work out so well."
				echo "Please manually try to add the software since I couldn't do it."
				exit
			fi
			echo "OK Done! Continuing..."
		fi
	}

	function install_software (){
		# Simple function to help installing software on several linux distributions
		# Should work on Fedora, SUSE, RedHat, Ubuntu, Debian etc. unless the naming
		# convention of the software package is different between distributions.
		if hash pkcon 2>/dev/null; then
			sudo pkcon -y  install "$@"
		elif hash yum 2>/dev/null; then
			sudo yum -y  install "$@"
		elif hash zypper 2>/dev/null; then
			sudo zypper install -y "$@"
		elif hash apt-get 2>/dev/null; then
			export DEBIAN_FRONTEND=noninteractive
			sudo apt-get -y -qq --allow-change-held-packages --ignore-missing install "$@"
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			_cleanup
			exit 1
		fi
	}

	function setup_minecraft_root (){
		# Setup and initiate the location of the mincraft server.
		# For us i likes to live in /home/$USER/bin/minecraft.server/Minecraft.$VERSION
		# This tests if the script files are available and downloades them if not.
		mkdir -p $MINECRAFT_HOME

		for i in start.sh announce.py server.properties eula.txt
		do
			if [ ! -f "$MINECRAFT_HOME/$i" ]; then
			$i $MINECRAFT_HOME
			fi
		done

		if [ ! -f "$MINECRAFT_HOME/$MINECRAFT_JAR" ]; then
			minecraft_update
		fi
	}


	function run_minecraft_server_manager (){

		# Start byobu multi screen app...
		byobu new-session -d -s $USER

		# status screen
		byobu rename-window -t $USER:0 'Minecraft Server Manager'
		byobu send-keys "bash $MINECRAFT_HOME/start.sh" C-m

		# Create new pane vertically and display htop
		byobu split-window -v
		byobu send-keys "htop " C-m

		# Split the "htop" window in 2, and start spedometer there.
		byobu split-window -h
		byobu send-keys "speedometer -r $NETINT  -t $NETINT" C-m

		# Create new window...
		byobu new-window -t $USER:1 -n 'Anouncing on Network (Press F4 to switch between windows)'
		byobu send-keys "python3 $MINECRAFT_HOME/announce.py" C-m

		# Set default window as the dev split plane
		byobu select-window -t $USER:0
		byobu-tmux select-pane -t 0

		# Attach to the session you just created
		byobu attach-session -t $USER
	}


	function check_java (){
		~/bin/java/bin/java --version >/dev/null
		if [ $? -eq 0 ]; then
			echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
		else
			echo Java is not present where expected... will now download:
			wget https://download.oracle.com/java/20/latest/jdk-20_linux-x64_bin.tar.gz
			mkdir ~/bin/java && tar xzvf jdk-20_linux-x64_bin.tar.gz --directory ~/bin/java/ --strip 1
			#check_dependencies default-jre
		fi
	}


	function find_active_newtork_interface (){
		# Detect the name of the active network interface.
		NETINT=$(ip addr | awk '/state UP/ {print $2}' |grep -v "br*" |grep -v "wlp*" | head --bytes -2 )
		echo "Active network interface is: $NETINT"
		export NETINT
	}


	function minecraft_update() {
		# Get minecraft version publication file and get the latest server URL
		# This is an unneccessarily complicated way by Mojang!
		cd $MINECRAFT_HOME || { echo "Failure change to Minecraft folder. Is it there?"; exit 1; }
		wget -q -O $MINECRAFT_HOME/versions --no-check-certificate https://launchermeta.mojang.com/mc/game/version_manifest.json
		JSONVERSION=$(cat versions | python3 -c "exec(\"import json,sys\nobj=json.load(sys.stdin)\nversion=obj['latest']['release']\nfor v in obj['versions']:\n   if v['id']==version:\n    print(v['url'])\")")
		wget -q -O $MINECRAFT_HOME/versions --no-check-certificate $JSONVERSION
		MC_SERVER_URL=$(cat versions | python3 -c 'import json,sys;obj=json.load(sys.stdin);print(obj["downloads"]["server"]["url"])')
		rm $MINECRAFT_HOME/versions

		# Download the latest minecraft vesrion and check if it is the same as the one installed
		wget -q -O $MINECRAFT_HOME/minecraft_server.jar.update --no-check-certificate $MC_SERVER_URL
		if [ -f $MINECRAFT_HOME/minecraft_server.jar.update ] ; then
			if diff $MINECRAFT_HOME/$MINECRAFT_JAR $MINECRAFT_HOME/minecraft_server.jar.update >/dev/null ; then
				dialog --title 'Minecraft Update' --msgbox "You are already running the latest version of $MINECRAFT_JAR." 0 0
		else
			mv $MINECRAFT_JAR $MINECRAFT_JAR.previous
			mv $MINECRAFT_HOME/minecraft_server.jar.update $MINECRAFT_HOME/$MINECRAFT_JAR
			dialog --title 'Minecraft Update' --msgbox "Minecraft successfully updated." 0 0
		fi
		else
			dialog --title 'Minecraft Update' --msgbox "Minecraft update could not be downloaded." 0 0
			echo
		fi
	}


	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::    Script internal config repository     ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# This section contains content to written out to several configuration
	# files and external scripts.


	announce.py () {
		cat >> $1/announce.py <<-'EOF'
	#!/bin/python3
	#              RTD System System Managment Script
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :: Author:     generated by minecraft.server
	# :: Version 1.02
	# ::
	# ::
	# :: Purpose: The purpose of the script is to:
	# ::          1 - Broadcast service availability to the local network.
	# ::              This script is used to broadcast the minecraft server on the
	# ::              same machine (see "servers"). You may have as many minecraft
	# ::              servers running and broadcast as you like.
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	import socket
	import time
	import sys
	import os
	import urllib.request

	servers = [
	["Local Network - Minecraft Server", 25565],
	]

	BROADCAST_IP = "255.255.255.255"
	BROADCAST_PORT = 4445

	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

	print("Broadcasting Minecraft servers to LAN on: " + os.environ['NETINT'])
	print("Local IP adress: ")
	print((([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")] or [[(s.connect(("8.8.8.8", 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]]) + ["no IP found"])[0])

	print("External IP address visible on the internet: ")
	external_ip = urllib.request.urlopen('https://ident.me').read().decode('utf8')
	print(external_ip)

	while True:
	for server in servers:
		msg = "[MOTD]%s[/MOTD][AD]%d[/AD]" % (server[0], server[1])
		encode = str.encode(msg)
		sock.sendto(encode, (BROADCAST_IP, BROADCAST_PORT))
	time.sleep(3)
		EOF
	}


	start.sh () {
		cat >> $1/start.sh <<-'EOF'
	#!/bin/bash
	#::             RTD System System Managment Script
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author:     generated by minecraft.server
	#:: Version 1.00
	#::
	#::
	#:: Purpose: The purpose of the script is to:
	#::          1 - Launch Minecraft
	#::          2 - Check that Minecraft runs for at least one minute
	#::          3 - If Minecraft crashes or quits after one minute, restart Minecraft
	#::
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	pushd $(dirname "$0")

	MC_SERVER_NAME=`cat server.properties |grep "motd=.*" `
	export $MC_SERVER_NAME

	while true; do

	start_epoch=$(date +%s)
	echo Starting Minecraft server $MC_SERVER_NAME ....
	~/bin/java/bin/java -Xmx2048M -Xms2048M -jar $(dirname "$0")/server.jar noggui broadcast

	# Abort if the application exited too quickly
	duration=$(( $(date +%s) - $start_epoch ))
	if [[ "$duration" < 60 ]]; then
		echo "Program exited too quickly! Aborting Minecraft Launcher...."
		exit
	fi

	done

	exit
		EOF
	}


	server.properties () {
		cat >> $1/server.properties <<-'EOF'
	# Minecraft server properties
	# generated by minecraft.server
	broadcast-rcon-to-ops=true
	view-distance=6
	max-build-height=256
	server-ip=
	rcon.port=25575
	level-seed=
	allow-nether=true
	gamemode=survival
	enable-command-block=true
	server-port=25565
	enable-rcon=false
	enable-query=true
	op-permission-level=3
	prevent-proxy-connections=false
	generator-settings=
	resource-pack=
	player-idle-timeout=0
	level-name=world
	rcon.password=
	motd=\u00A7d CuteWorld
	query.port=25565
	force-gamemode=true
	debug=false
	hardcore=false
	white-list=false
	broadcast-console-to-ops=true
	pvp=true
	spawn-npcs=true
	spawn-animals=true
	generate-structures=true
	snooper-enabled=false
	difficulty=normal
	network-compression-threshold=256
	level-type=default
	max-tick-time=-1
	spawn-monsters=true
	enforce-whitelist=false
	max-players=10
	use-native-transport=true
	spawn-protection=16
	resource-pack-sha1=
	online-mode=true
	allow-flight=false
	max-world-size=29999984
		EOF
	}

	eula.txt () {
		cat >> $1/eula.txt <<-'EOF'
	#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://account.mojang.com/documents/minecraft_eula).
	#Sun Feb 26 16:57:58 CET 2017
	eula=true
		EOF
	}


	# File write template. Takes one argument "where to put the file"
	filetowrite.txt () {
		cat >> $1/filetowrite.txt <<-'EOF'

		EOF
	}

	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Executive                ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	# Check that the software components of this script are available.
	# iff they are not, attempt to install them.
	for i in byobu speedometer htop python3 dialog
	do
		check_dependencies $i
	done

	if echo "$@" | grep "update" ;then
		dialog --title "Update to latest Minecraft?"  --yesno "You have requested that I try to get the latest verion of Minecraft from Mojang. This means that the people playing in the server also will need the latest version. Is this OK?" 0 0
			case $? in
			0)
			minecraft_update ;;
			1)
			echo "Proceeding without update...";;
			255)
			echo "ESC pressed.";;
			esac
	fi

	# Basic check to see that the Minecraft folder is present and
	# if not crate it and download the scripts and the server jar file
	# to enable the server.
	setup_minecraft_root
	check_java

	# Start the server and monitor the server performance
	find_active_newtork_interface
	run_minecraft_server_manager

MINECRAFT_EOF
}






system::generate_ks_cfg_file ()
{
# Description: Function to generate an installation configuration file for Fedora/Red Hat.
# Globals: 
# Arguments: [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]
# Outputs: One kick start configuration file.
# Returns: 0/1
# Usage: system::generate_ks_cfg_file [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]
# End of documentation

	system::log_item "Function : ${FUNCNAME[0]}"
	system::log_item "Called by: ${FUNCNAME[-1]}"

	local OPTIND o a
	while getopts ':u:c:p:e:' OPTION; do
		case "$OPTION" in
		u )
			local _repo_url="${OPTARG}"
			write_host --cyan "${FUNCNAME[0]}: Using URL: ${OPTARG}"
		;;
		c )
			local _config="${OPTARG}"
			write_host --cyan  "${FUNCNAME[0]}: Using Config for: ${OPTARG}"
		;;
		p )
			local _ks_file="${OPTARG}"
			write_host --cyan  "${FUNCNAME[0]}: Creating KS.CFG Instructions: ${_ks_file}"
		;;
		e )
			local _wks_env="${OPTARG}"
			write_host --cyan  "${FUNCNAME[0]}: Received optioinal option: ${_wks_env}"
		;;
		? )
			write_host --cyan  "${FUNCNAME[0]}: Usage: $(FUNCNAME[0]) [-p <filename> ] [-u URL ] [-c workstation|ssh-server|ansible-server ]"
			return 1
		;;
		esac
	done
	unset OPTIND

	[[ -v _repo_url && -v _config && -v _ks_file   ]] || ( echo missing mandatory parameters! ; return 1 )

	case ${_config} in
	ssh-server )
		write_information "${FUNCNAME[0]}: Selected configuration is ssh-server..."
		cat >> "${_ks_file}" <<-KS_EOF
		# Generated by: system::generate_ks_cfg_file by RTD Power Tools
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		text
		url --mirrorlist="${_repo_url}"
		firstboot --enable
		keyboard --vckeymap=us --xlayouts='us'
		lang en_US.UTF-8
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org
		network --onboot=yes --bootproto=dhcp
		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		zerombr
		clearpart --all
		autopart --nohome
		reboot

		%packages --retries 5 --timeout 20
		openssh-server
		spice-vdagent
		git
		curl
		dialog
		%end
		KS_EOF
		return
	;;
	ansible-server )
		write_information "${FUNCNAME[0]}: Selected configuration is ansible-server..."
		cat >> "${_ks_file}" <<-KS_EOF
		# Generated by: system::generate_ks_cfg_file by RTD Power Tools
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		text
		url --mirrorlist="${_repo_url}"
		firstboot --enable
		keyboard --vckeymap=us --xlayouts='us'
		lang en_US.UTF-8
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org
		network --onboot=yes --bootproto=dhcp --hostname=ansible.localdomain
		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		zerombr
		clearpart --all
		autopart --nohome
		reboot

		%packages --retries 5 --timeout 20
		openssh-server
		spice-vdagent
		git
		curl
		dialog
		ansible
		%end
		KS_EOF
		return
	;;
	workstation )
		write_information "${FUNCNAME[0]}: Selected configuration is workstation..."
		cat >> "${_ks_file}" <<-KS_EOF
		# Generated by: system::generate_ks_cfg_file by RTD Power Tools
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		graphical
		# url --mirrorlist="${_repo_url}"
		url --url "${_repo_url}"
		firstboot --disable
		keyboard --xlayouts='se'
		lang en_US.UTF-8
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org
		network --onboot=yes --bootproto=dhcp
		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		zerombr
		clearpart --all
		autopart --nohome --encrypted --passphrase letmein1234
		reboot

		%packages --retries 5 --timeout 20
		${_wks_env}
		openssh-server
		spice-vdagent
		git
		curl
		dialog
		%end

		# Post-installation Script
		%post --interpreter=/bin/bash
		git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd
		chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
		bash /opt/rtd/core/rtd-oem-enable-config.sh
		%end
		KS_EOF
		return
	;;
	* )
		write_information ": No valid OS configuration requested: 
		Valid requests are: workstation, ssh-server, ansible-server
		skipping..."
		return 1
	;;
	esac
}








generate_autoyast_file ()
{
# Description: Function to generate an installation configuration file for SUSE builds.
# Globals:
# Arguments: [file path] [workstation, ssh-server, ansible-server]
# Outputs: One configuration file.
# Returns: 0/1
# Usage: generate_autoyast_file $(mktemp) workstation
# End of documentation
	FILE="$1"
	CONFIG="$2"
	suse_product="Leap"
	write_host --cyan "Creating AUTOYAST Instructions (XML): ${FILE}"


	# Localized variables based on User preferences, but with suse speciffic defaults:
	Preference_DiskEncryption_SUSE="$( [[ "$_EncryptDisk" == "YES" ]] && echo "<encryption_password>${PreferredDiskPassword:-"letmein1234"}</encryption_password>" )"
	Preference_Password_SUSE=$( [[ -n "${PrefferredUserPassword}" ]] && echo "<user_password>${PrefferredUserPassword}</user_password>" || echo '<user_password>$6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1</user_password>' )
	Preference_Desktop_DE_SUSE=${_UserDesktopEnvironemtSelection:-"<pattern>kde</pattern>"}
	Preference_InitialUser_SUSE="<username>${_OEM_USER:-"tangarora"}</username>"
	Preference_Product_SUSE="<product>${suse_product:="openSUSE"}</product>"

	cat >> ${FILE} <<-AUTOYAST_EOF
<?xml version="1.0"?>
<!DOCTYPE profile>
<profile
	xmlns="http://www.suse.com/1.0/yast2ns"
	xmlns:config="http://www.suse.com/1.0/configns" >
	<general>
		<mode>
			<confirm config:type="boolean">false</confirm>
			<final_reboot config:type="boolean">true</final_reboot>
			<final_halt config:type="boolean">false</final_halt>
			<halt config:type="boolean">false</halt>
			<second_stage config:type="boolean">false</second_stage>
			<forceboot config:type="boolean">true</forceboot>
		</mode>
	</general>

	<storage>
		<proposal>
		<confirm config:type="boolean">false</confirm>
		<lvm config:type="boolean">true</lvm>
		<windows_delete_mode config:type="symbol">all</windows_delete_mode>
		<linux_delete_mode config:type="symbol">all</linux_delete_mode>
		<other_delete_mode config:type="symbol">all</other_delete_mode>
		${Preference_DiskEncryption_SUSE}
		</proposal>
	</storage>

	<networking>
	<keep_install_network config:type="boolean">true</keep_install_network>
	</networking>

	<deploy_image>
	<image_installation config:type="boolean">true</image_installation>
	</deploy_image>

	<software>
		<install_recommended config:type="boolean">true</install_recommended>
		<patterns config:type="list">
			<pattern>base</pattern>
			${Preference_Desktop_DE_SUSE}
		</patterns>

		<packages config:type="list">
			<package>wget</package>
			<package>curl</package>
			<package>dialog</package>
			<package>vim</package>
			<package>spice-vdagent</package>
			<package>git</package>
			<package>pkexec</package>
			<package>zip</package>
			<package>zenity</package>
			<package>yad</package>
			<package>acpi</package>
			<package>pciutils</package>
		</packages>

		<products config:type="list">
			${Preference_Product_SUSE}
		</products>

	</software>

	<firstboot>
		<firstboot_enabled config:type="boolean">false</firstboot_enabled>
	</firstboot>

	<users config:type="list">
		<user>
			<encrypted config:type="boolean">true</encrypted>
			<fullname>root</fullname>
			<gid>0</gid>
			<home>/root</home>
			<shell>/bin/bash</shell>
			<uid>0</uid>
			${Preference_Password_SUSE}
			<username>root</username>
		</user>
		<user>
			<encrypted config:type="boolean">true</encrypted>
			<fullname>RTD User</fullname>
			<shell>/bin/bash</shell>
			${Preference_Password_SUSE}
			${Preference_InitialUser_SUSE}
		</user>
	</users>

	<login_settings>
		<autologin_user>tangarora</autologin_user>
		<password_less_login config:type="boolean">true</password_less_login>
	</login_settings>

	<services-manager>
		<default_target>graphical</default_target>
		<services>
			<enable config:type="list">
				<service>sshd</service>
				<service>spice-vdagent</service>
			</enable>
		</services>
	</services-manager>

	<scripts>
	    <init-scripts config:type="list">
	      <script>
		<source><![CDATA[
#!/bin/bash
git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd
chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
/opt/rtd/core/rtd-oem-enable-config.sh
cp *.xml /opt/rtd/
sudo zypper ar -cfp 90 ${_SUSE_PACKMAN_LEAP} packman
zypper --gpg-auto-import-keys refresh
zypper dup --from packman -y --force-resolution
]]>
		</source>
	      </script>
	    </init-scripts>
	</scripts>

	<security>
		<displaymanager_remote_access>no</displaymanager_remote_access>
		<fail_delay>3</fail_delay>
		<faillog_enab>yes</faillog_enab>
		<gid_max>60000</gid_max>
		<gid_min>101</gid_min>
		<lastlog_enab>yes</lastlog_enab>
		<obscure_checks_enab>no</obscure_checks_enab>
		<permission_security>secure</permission_security>
		<run_updatedb_as>nobody</run_updatedb_as>
		<uid_max>60000</uid_max>
		<uid_min>500</uid_min>
		<selinux_mode>permissive</selinux_mode>
		<lsm_select>selinux</lsm_select>
	</security>


</profile>

AUTOYAST_EOF
}






system::generate_cloudconfig (){
# Description:
# Function to generate a cloud config file for use in deploying servers
#
# Globals:
# Arguments: 
# Outputs: 
# Returns:
# Usage: gen_cloudconfig 
#
#
# With the introduction of the DigitalOcean metadata service, it is possible to start configuring your 
# servers before you even log in. In short, the metadata service is an HTTP location that your server 
# can access during the boot process.
#
# The metadata location will contain basic data about the serverâ€™s configuration and environment, 
# such as network addresses, hostname, etc. During the initial setup, these values can be pulled 
# down by a program called cloud-init to help configure essential services.
#
# The most powerful feature is that you can pass a script to the metadata service when you create a 
# server using a field called user-data. This will be run during the initial boot process and is very 
# flexible, allowing you to accomplish whatever you can script.
#
# The most common type of script to pass in is called a cloud-config script. This is a 
# YAML formatted file that provides simple, readable methods of setting up common configuration 
# items by declaration. It also has the ability to run arbitrary commands for other tasks.
#
# In this guide, we will get familiar with the DigitalOcean metadata service and cloud-config 
# files by trying out a simple example. We will be recreating some of the steps outlined 
# in the initial server setup for Ubuntu 14.04 guide in order to demonstrate.
#
# End of Documentation

	# Localized variables based on User preferences, but with speciffic defaults should all fail:
	local Preference_DiskEncryption="$( [[ "$_EncryptDisk" == "YES" ]] && echo "${PreferredDiskPassword:-"letmein1234"}" )"
	local Preference_Password=$( [[ -n "${PrefferredUserPassword}" ]] && echo "${PrefferredUserPassword}" || echo '$6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1' )
	local Preference_InitialUser="${_OEM_USER:="tangarora"}"

	CloudConfig=$( mktemp -d /tmp/CloudConfig.XXXXXX )
	local _git_src_url="${GIT_RTD_SRC_URL:="https://github.com/${GIT_Profile:=vonschutter}/${_TLA^^}-Setup.git"}"
	touch ${CloudConfig}/meta-data

# -----------------------------------------------------------------------------------------
# add common section to the cloud config file
# -----------------------------------------------------------------------------------------


cat >> ${CloudConfig}/user-data << CloudConfigCommon
#cloud-config
autoinstall:
  version: 1
  apt:
    mirror-selection:
      primary:
        - uri: http://mymirror.local/repository/Apt/ubuntu/
        - country-mirror
        - uri: http://archive.ubuntu.com/ubuntu
  shutdown: reboot
  timezone: geoip
  drivers:
    install: true
  ssh:
    allow-pw: true
    install-server: true
    authorized-keys:
      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDaHrQkReAZYQrf4LGGL9O7M5jV/ckR7XCVq/TJFHSvnV8l7RiT0MmXAHNcDxbdkERicv8Yc0OSz2cLeJtHaBoh7gW1y5h2pDKDKuY9NUkkvl6AaWHWdqPY76I7iRmMSYCXJ9qUGkI/XPyihQUP+h7sTYY+zXJyigi8BECJRaEKB5CPUsw7VFFUOewmQ5Dn6qIrpBSwyFWjI9Qs+1EdlXZ+VwyfToPL9JrhCYimqqWC5c15pt9KfYIRJYALezKgcIsjOUcGcfR3Hg/3Ul/3695rmLYFWsRF1xHy+3+PfhdQZVfBXOorBcsXnEVsJBEsPH/ZQJdYWkP/C79P4KdoUXUq0ghmDiazM/y9iggEcZNoT8qY0dWqItITVhFM6JMIUuJoAWaYUgaw3a4EAEL2+OJ8Go+iipinP9VAXQ+vVbZcHXU5xE/l965SfaXCf0MngwhzvpHtijLc54O/z6VP2ArPTAOzBKnGqEYUA/wt8LzAQTwsbYiQshYQrnE8A5z8Vkk=
      - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACZQDMbsjrigCpMbWRXdssBe0dg7nJZzXzlEN+GHNg1vJH6W1lrLYhlXyQtflF/tUylFfYVNakRvC/KZ5qdl4Zbkb7OQ1A+AyT/Ln54zvilZSp3x+NsUgqPbWDmopzNrTxZyT3btZQG7Rz0hn7Pq0eA6ViIwldQkwwyl5QQg3NkYaE9Vwdz6upXUJsAHUCEDW0ygHggLSUYeA5HMuNgaBrrwLaEptlasYwFyghov+jJoO/EERFLmdfDdF8A6q44iZ2jY5BXeASdnZ0kqPj/sYkmHNcV1bh4e86lp77YDuxBPPeoj9hWpPWvxgPIMT0gvfw8PWgaQNC++kyRGEF6q6eij3MLWXGBrTngu7qSTjQSg5B8UKwcEXGc7cpzW+oT0qYx8hnDCLfESbbn/fZawMFS/uTqV3/VqyknKe8S8tgdyOFNy74IIAkx+pVm5jrlC0gTaNehgH4XWasYZo+Ab8eiJpSCtkTk/1QvmSOczVrRKhkn5gy7t4reMfn7P2RR43JkuaGNx8J9wp7K+H5VRPi/JCMfT0dTy3evQSK59/gOI6J69+zi5mfjMZK/UY7wd6cuAbjH/edilm8ciexkyCtLuDE8dh3Rw/oeerA2HZJs8JulKjEE83B2r1kv2pneV7oIZ3+hI+UZFC1Qg2Gw6OFEjO876VQWAI5aDDQFUiMIhNerEWjULEvPtLZENz0zUGV3UxMHryVAyvlNfu8q6TeRZ+9uwuHpfnIZvlpYifGSQCX3lkYIHC/5h0eMsW1Wxg3YQCBHKf7ycMyiEw2QcjvsEsiS/gV4ZDYlmh74upFlOhmpe13Nds=
  keyboard:
    layout: se
CloudConfigCommon

# Add identity section
cat >> ${CloudConfig}/user-data << CloudConfigID
  identity:
    hostname: "${vm_name}"
    username: "${Preference_InitialUser}"
    password: "${Preference_Password}"
CloudConfigID

# -----------------------------------------------------------------------------------------
# end common section to the cloud config file
# -----------------------------------------------------------------------------------------



if [[ ${_role} == "server" ]] ; then
	system::log_item "Generating cloud-config for Ubuntu server media..."



	case ${_task} in
	# -----------------------------------------------------------------------------------------
	ubuntu-desktop )
	system::log_item "Generating cloud-config for the role: ubuntu-desktop"
	# -----------------------------------------------------------------------------------------

cat >> ${CloudConfig}/user-data << CloudConfig_server-desktop
  snaps:
    - name: nvim
      channel: latest/stable
      classic: true
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
    - ubuntu-desktop
  late-commands:
    - >-
      curtin in-target --
      sed -i /etc/default/grub -e
      's/GRUB_CMDLINE_LINUX_DEFAULT=".*/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"/'
    - curtin in-target -- update-grub
    - rm /target/etc/netplan/00-installer-config*yaml
    - >-
      printf "network:\n  version: 2\n  renderer: NetworkManager" 
      > /target/etc/netplan/01-network-manager-all.yaml
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
CloudConfig_server-desktop
	;;

	# -----------------------------------------------------------------------------------------
	kubuntu-desktop )
	system::log_item "Generating cloud-config for the role: kubuntu-desktop"
	# -----------------------------------------------------------------------------------------
cat >> ${CloudConfig}/user-data << CloudConfig_server-desktop
  snaps:
    - name: nvim
      channel: latest/stable
      classic: true
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
    - kubuntu-desktop
  late-commands:
    - >-
      curtin in-target --
      sed -i /etc/default/grub -e
      's/GRUB_CMDLINE_LINUX_DEFAULT=".*/GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"/'
    - curtin in-target -- update-grub
    - rm /target/etc/netplan/00-installer-config*yaml
    - >-
      printf "network:\n  version: 2\n  renderer: NetworkManager" 
      > /target/etc/netplan/01-network-manager-all.yaml
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
CloudConfig_server-desktop
	;;
	# -----------------------------------------------------------------------------------------
	ubuntu-server | ubuntu-server-minimal )
	system::log_item "Generating cloud-config for ubuntu-server"
	# -----------------------------------------------------------------------------------------
cat >> ${CloudConfig}/user-data << CloudConfig_ubuntu-server
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
  late-commands:
    - echo ******************* Ubuntu Server Generic Config ***********
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
CloudConfig_ubuntu-server
	;;
	# -----------------------------------------------------------------------------------------
	ssh-server )
	system::log_item "Generating cloud-config for ubuntu-ssh-server"
	# -----------------------------------------------------------------------------------------
cat >> ${CloudConfig}/user-data << CloudConfig_ssh-server
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
    - p7zip-full
    - byobu
  late-commands:
    - echo ******************* SSH Server Config ********************
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
CloudConfig_ssh-server
	;;
	ansible-server )
	system::log_item "Generating cloud-config for ubuntu-ssh-server"
	# -----------------------------------------------------------------------------------------
cat >> ${CloudConfig}/user-data << CloudConfig_ssh-server
  packages:
    - dialog
    - git
    - curl
    - wget
    - zip
    - p7zip-full
    - ansible
    - byobu
  late-commands:
    - echo ******************* SSH Server Config ********************
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
CloudConfig_ssh-server
	;;
	# -----------------------------------------------------------------------------------------
	minecraft-server )
	system::log_item "Generating cloud-config for minecraft-server"
	# -----------------------------------------------------------------------------------------
cat >> ${CloudConfig}/user-data << CloudConfig_minecraft-server
  packages:
    - dialog
    - git
    - wget
    - ansible
  late-commands:
    - echo ******************* Minecraft Server Config ***************
    - mkdir /target/opt/rtd
    - git clone --depth=1 https://github.com/vonschutter/RTD-Setup.git /target/opt/rtd
    - /usr/bin/chmod 755 /target/opt/rtd/core/rtd*
    - curtin in-target --target=/target -- /opt/rtd/core/rtd-oem-enable-config.sh
    - mkdir /target/etc/rtd
    - cp /autoinstall.yaml /target/etc/rtd/
    - mkdir -p /target/etc/systemd/system/getty@tty1.service.d
    - touch /target/etc/systemd/system/getty@tty1.service.d/override.conf
    - echo [Service] > /target/etc/systemd/system/getty@tty1.service.d/override.conf
    - echo ExecStart=  >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
    - echo 'ExecStart=-/sbin/agetty --noissue --autologin tangarora %I \$TERM' >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
    - echo Type=idle >> /target/etc/systemd/system/getty@tty1.service.d/override.conf
    - echo NAutoVTs=1 >> /etc/systemd/logind.conf
    - echo "Please run rtd-minecraft-server to start the Minecraft Server!" >> /target/etc/update-motd.d/00-header
    - echo rtd-minecraft-server >> /target/etc/profile
CloudConfig_minecraft-server
	;;

	# -----------------------------------------------------------------------------------------
	* )
		system::log_item "Got: (${_task}) No valid task selected, skipping late commands..."
	;;
	esac
	# -----------------------------------------------------------------------------------------
elif [[ ${_role} == "desktop" ]] ; then
	system::log_item "Generating cloud-config for Ubuntu desktop media..."

else
	system::log_item "Got: (${_role}) No valid role selected, no role speciffic instructions will be created..."
fi




	system::log_item "Configuration data supplied: 
	$(cat ${CloudConfig}/user-data)"
	write_information "Generate Ubuntu autoinstall instruction media: "
	#software::check_native_package_dependency genisoimage
	genisoimage -output ${CloudConfig}/cidata.iso -volid cidata -joliet -rock ${CloudConfig}/user-data ${CloudConfig}/meta-data  &>>${_LOGFILE}
	chmod 777 -R ${CloudConfig}

}









system::get_vm_config() 
{
# Description: This function gets a value from a configuration file.
# Parameters:
#   - config_file: The path to the configuration file.
#   - key: The key to get the value for.
# Returns: The value for the key.
#
# Example:
#
# End of documentation
	local _config_file=${_OEM_USER_VM_PREFERENCES:-"/home/${SUDO_USER}/.config/${_TLA,,}/build_defaults.inf"}
	[[ "$1" == "--ask" ]] && local _ask="YES" || local _ask="NO"

	system::log_item "Loading Global Config if available otherwise use defaults..."
	Preference_DiskEncryption="${_ENCRYPT_DISK:-"YES"}"
	Preference_Disk_Password="${_TEMP_DISK_PASSWORD:-"letmein1234"}"
	Preference_InitialUser="${_OEM_USER:-"tangarora"}"
	Preference_InitialUserFullName="${_OEM_USER_FULLNAME:-"RTD User"}"
	Preference_InitialUserGroup="${_OEM_USER_GROUP:-"sudo"}"
	Preference_InitialUserPassword="${_OEM_USER_PASSWORD:-"letmein1234"}"
	Preference_InitialKeyboardLayout="${_OEM_USER_KEYBOARD_LAYOUT:-"us"}"
	Preference_InitialTimeZone="${_OEM_USER_TIMEZONE:-"Etc/UTC"}"
	Preference_Wireless_ID="${_OEM_WIRELESS_ID:-"loader"}"
	Preference_Wireless_Password="${_OEM_WIRELESS_PASSWORD:-"letmein1234"}"
	Preference_Role="${_role:-"default"}"
	Preference_CopySSHKey="${_OEM_COPY_SSH_KEY:-"NO"}"

	system::log_item "Load saved preferences from the config file everriding the _branding global config or defaults for preseed file..."
	[[ -f "${_config_file}" ]] && system::read_config "${_config_file}" || system::log_item "Failed to load config file: ${_config_file}"
        
        # If OS Role is set (by function for auto install), then override the config file with the role:
        [[ -n $_role ]] && Preference_Role="${_role}" 

        # If the user has requested to be asked for the preseed file, then ask them:
	if [[ -n $_ask ]] ; then

		system::log_item "'ask' is requested, requesting user input for the preseed file:"
		preseed_choices=$(dialog --backtitle "$BRANDING" --title "RTD Preseed Creator" --mixedform "Enter your preferences in to the form below. Please note that the password fields do not show anything but will capture what you type in" 22 80 0 \
		"DiskEncryption (YES/NO):" 	        1 1 "${Preference_DiskEncryption}" 1 40 40 0 0 \
		"Disk Unlock Password (temp):"          2 1 "${Preference_Disk_Password}" 2 40 40 0 0 \
		"Admin User Name:"                      3 1 "${Preference_InitialUser}" 3 40 40 0 0 \
		"Admin User Full Name:"                 4 1 "${Preference_InitialUserFullName}" 4 40 40 0 0 \
		"Admin User Initial UserGroup:"         5 1 "${Preference_InitialUserGroup}" 5 40 40 0 0 \
		"Admin User Password (8 30 char):"      6 1 "${Preference_InitialUserPassword}" 6 40 128 0 0 \
		"Initial Keyboard Layout:"              7 1 "${Preference_InitialKeyboardLayout}" 7 40 40 0 0 \
		"Initial Time Zone:"                    8 1 "${Preference_InitialTimeZone}" 8 40 40 0 0 \
		"Wireless Network SSID:"                9 1 "${Preference_Wireless_ID}" 9 40 40 0 0 \
		"Wireless Network Password:"           10 1 "${Preference_Wireless_Password}" 10 40 40 0 0 \
		"Role (Default, KVM, Minecraft):"      11 1 "${Preference_Role}" 11 40 40 0 0 \
		"Copy you ssh public key to host?"     12 1 "${Preference_CopySSHKey}" 12 40 40 0 0 \
		3>&1 1>&2 2>&3)
		exit_status=$?

		clear

		case $exit_status in
		0 )   system::log_item "Save coices and continue..." ;;
		1 )   system::log_item "[Cancel] pressed; not updating or changing any configuration items..." ; return 1 ;;
		255 ) system::log_item "[ESC] pressed, exiting the dialog immediatley..." ; return 1 ;;
		* )   system::log_item "[ERROR] Dialog closed or unexpected error." ; rtd_oem_pause 1 "Dialog closed or unexpected error." ;;
		esac
		
		# Convert the dialog output to an array and asign the variables:
		IFS=$'\n' read -r -d '' -a input_array <<< "$preseed_choices"
		Preference_DiskEncryption=${input_array[0]}
		Preference_Disk_Password=${input_array[1]}
		Preference_InitialUser=${input_array[2]}
		Preference_InitialUserFullName=${input_array[3]}
		Preference_InitialUserGroup=${input_array[4]}
		Preference_InitialUserPassword=${input_array[5]}
		Preference_InitialKeyboardLayout=${input_array[6]}
		Preference_InitialTimeZone=${input_array[7]}
		Preference_Wireless_ID=${input_array[8]}
		Preference_Wireless_Password=${input_array[9]}
		Preference_Role=${input_array[10]}
		Preference_CopySSHKey=${input_array[11]}

		# Encrypt the user/admin password before saving & for use in the preseed file
		# If the password is already encrypted, then skip this step:
		if [[ ${#Preference_InitialUserPassword} -ge 30 ]] ; then
			system::log_item "Password appears to be encrypted already so skipping encryption..."
		else
			system::log_item "Password appears to be clear text, encrypting password..."
			Preference_InitialUserPassword=$(printf "%s" "$Preference_InitialUserPassword" | mkpasswd -s -m sha-512)
			if system::update_config "$_config_file" "Preference_InitialUserPassword" "${Preference_InitialUserPassword}" ; then
				system::log_item "Stored encrypted password in user preferences: $_config_file"
			else 
				system::log_item "[ERROR] Failed to store encrypted password in user preferences: $_config_file"
			fi
		fi

		system::log_item "Save as defaults and continue..."
		write_information "Saving preferences to: $_config_file"
		
		system::update_config "$_config_file" "Preference_DiskEncryption" "${Preference_DiskEncryption}" \
		"Preference_Disk_Password" "${Preference_Disk_Password}" \
		"Preference_InitialUser" "${Preference_InitialUser}" \
		"Preference_InitialUserFullName" "${Preference_InitialUserFullName}" \
		"Preference_InitialUserGroup" "${Preference_InitialUserGroup}" \
		"Preference_InitialKeyboardLayout" "${Preference_InitialKeyboardLayout}" \
		"Preference_InitialTimeZone" "${Preference_InitialTimeZone}" \
		"Preference_Wireless_ID" "${Preference_Wireless_ID}" \
		"Preference_Wireless_Password" "${Preference_Wireless_Password}" \
		"Preference_Role" "${Preference_Role}" \
		"Preference_CopySSHKey" "${Preference_CopySSHKey}" 
		
		return $?
	else
		write_information "Generating preseed.cfg for: ${_role} ${_task} automatically using defaults..."
		return 0
	fi

}







system::make_preseed_cfg ()
{
# Description: Function to write out a debina preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Globals:
# Arguments: [-p <path> ] [-r server|desktop|minecraft ] [-t gnome-desktop|kde-desktop|xfce-desktop|mate-desktop|cinnamon-desktop ]
# Outputs: /path/to/preseed.cfg
# Returns:
# Usage: system::make_preseed_cfg -r "${_role}" -p "$( mktemp -d)" -t ${_task}
# Example:
# 
# system::make_preseed_cfg -r "${_role}" -p "$( mktemp -d)" -t ${_task}
#
# To install a basic server: 
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t ssh-server
#
# To install a basic ansible server:
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t ansible-server
#
# To autoinstall a basic minecraft server:
# system::make_preseed_cfg -r "minecraft-server" -p "$( mktemp -d)" -t ssh-server
# 
# To autoinstall a basic desktop with gnome:
# system::make_preseed_cfg -r "default" -p "$( mktemp -d)" -t gnome-desktop
# 
# End of documentation

	system::log_item "Called by: ${FUNCNAME[-1]}"

	# Defaults:
	local _saveto="$( mktemp -d )"	# Where to save the preseed file
	local _role="default"		# selects d-i preseed/late_command actions based on role.
	local _task="ssh-server"	# Package selection: What DE to install, or ssh-server
	unset _ask			# If set to "YES" then ask for user input to generate preseed file.

	local OPTIND o a
	while getopts ':r:p:t:a:' OPTION; do
		case "$OPTION" in
		r )
			_role="${OPTARG}"
			system::log_item "Using Config for: ${_role}"
		;;
		p )
			local _saveto="${OPTARG}"
			write_information "Overriding default save location: ${_saveto} with user supplied: ${OPTARG}"
			system::log_item  "Saving configuration instructions to: ${_saveto}"

		;;
		t )
			local _task="${OPTARG}"
			system::log_item "Received optioinal option: ${_task}"
		;;
		a )
			local _ask="${OPTARG}"
			system::log_item "Received optioinal option: ${_ask}"
		;;
		? )
			write_error "Usage: $(FUNCNAME[0]) [-p <path> ] [-r server|desktop|minecraft ] [-t gnome-desktop | kde-desktop | ...-desktop | xfce-desktop | mate-desktop | cinnamon-desktop ]"
			return 1
		;;
		esac
	done
	unset OPTIND

	export PRESEED_FILE="${_saveto}/preseed.cfg"	# The name of the preseed file to be created
	export TASK_FILE="${_saveto}/task.sh"		# The name of the task file to be created (if needed)

	touch "${PRESEED_FILE}" 2>&1 | tee -a "${_LOGFILE}"
	touch "${TASK_FILE}"    2>&1 | tee -a "${_LOGFILE}"

        # system::get_vm_config will load the preferences from the config file if it exists
        # otherwise it will use the defaults set in the function.
        # it will return predefined variables that can be used in the preseed file.
	if [[ -n $_ask ]] ; then
		system::log_item "Prompting for configuration options..."
		system::get_vm_config --ask || dialog::yesno "Cancelled or sommething went wrion... continue with defaults?"
                exit_status=$?

                case $exit_status in
                0 )   system::log_item "Save coices and continue..." ;;
                1 )   system::log_item "[Cancel] pressed; not updating or changing any configuration items..." ;;
                255 ) system::log_item "[ESC] pressed, exiting the dialog immediatley..." ; return 1 ;;
                * )   system::log_item "[ERROR] Dialog closed or unexpected error." ; rtd_oem_pause 1 "Dialog closed or unexpected error." ;;
                esac
	else
		system::log_item "Using default configuration options..."
		system::get_vm_config || system::log_item "Failed to get configuration options..."
                exit_status=$?
	fi

	# If the user has requested to copy their SSH key to the host, then do so:
	if [[ "${Preference_CopySSHKey}" == "yes" || "${Preference_CopySSHKey}" == "YES" ]] ; then
		Preference_ssh_pub_key="$(cat /home/$SUDO_USER/.ssh/*.pub | head -1)"
	fi

	# Write out the preseed file header with 'EOF' to prevent variable expansion:
	cat >> ${PRESEED_FILE} <<-'EOF'

		# --------------------------------------------------- #
		# C.4.1. Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string \
		# 	USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
		# 	BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
		# 	debconf-set partman-auto/disk $BOOTDEV;\
		# 	debconf-set grub-installer/bootdev $BOOTDEV;
                d-i partman/early_command string \
                        USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/"); \
                        BOOTDEV=$(list-devices disk | grep -v \$USBDEV | while read -r DEV; do \
                                if [ $(cat /sys/block/${DEV##*/}/queue/rotational) -eq 0 ]; then \
                                echo $DEV; break; \
                                fi; \
                        done); \
                        if [ -z "$BOOTDEV" ]; then \
                                BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1); \
                        fi; \
                        debconf-set partman-auto/disk $BOOTDEV; \
                        debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #

	EOF


	# Write out configurable protions of the preseed file:
	cat >> ${PRESEED_FILE} <<-EOF

		# --------------------------------------------------- #
		# C.4.2. Unattended Installation $(date)
		# --------------------------------------------------- #
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.3. Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp.
		# The RTD default prefferred config is to rely on DHCP,
		# and for wireless networks (systems with only wireless cards)
		# default to an SSID named "loader" and the guest wpa string
		# "letmein1234". This allows supported systems to be
		# installed directly over WiFi with no user input.
		d-i netcfg/choose_interface select manual
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string ${Preference_Wireless_ID}
		d-i netcfg/wireless_essid_again string ${Preference_Wireless_ID}
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string ${Preference_Wireless_Password}

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.4. Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string ${Preference_InitialUser}
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password ${Preference_InitialUserPassword}
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.5. Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to
		# the MUI in Microsoft environments.
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, sv_SE.UTF-8
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.6. Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select ${Preference_InitialKeyboardLayout}
		d-i keyboard-configuration/layoutcode string ${Preference_InitialKeyboardLayout}
		d-i debian-installer/keymap select ${Preference_InitialKeyboardLayout}
		d-i keymap select ${Preference_InitialKeyboardLayout}
		d-i console-setup/layoutcode string ${Preference_InitialKeyboardLayout}
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# C.4.7. Clock and time zone setup
		# --------------------------------------------------- #
		d-i clock-setup/utc boolean true
		d-i time/zone string ${Preference_InitialTimeZone}
		d-i clock-setup/ntp boolean true
		d-i clock-setup/ntp-server string ntp.ubuntu.com

		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.8. GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it 
		# also finds some other OS, which is more likely to allow 
		# the newly installed Linux OS to boot without issue.
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.9. EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition 
		# is a partition on a data storage device. UEFI provides 
		# backward compatibility with legacy systems by reserving 
		# the first block (sector) of the partition for compatibility 
		# code, effectively creating a legacy boot sector. On 
		# legacy BIOS-based systems, the first sector of a partition 
		# is loaded into memory and execution is transferred to this 
		# code. Here we tell setup to install EFI boot setup if 
		# possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# --------------------------------------------------- #

		# --------------------------------------------------- #
		# C.4.10. Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like 
		# kde-desktop or as individual packages. Only one "pkgsel/include" 
		# string will be used though! remembder to fit all the 
		# packages you want on one line.
		#
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop,
		# lubuntu-desktop, ubuntu-mate-desktop, gnome-desktop, 
		# kde-desktop, cinnamon-desktop, mate-desktop, lxde-desktop, 
		# web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the 
		# line with a relevant chice of debian role using "sed" or similar.
		tasksel tasksel/first multiselect ${_task}
		d-i pkgsel/include string openssh-server dialog virt-what curl wget spice-vdagent git

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select safe-upgrade
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the systemâ€™s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you donâ€™t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #


		# --------------------------------------------------- #
		#   C.4.11. Disk layout (default encrypted disk)
		# --------------------------------------------------- #
		#
		# Set option to encrypt the hard disk:
		# By default the harddisk will be encrypted to pretect data
		# and will need to be unlocked with a password when the
		# system is booted. In addition a default is prefferred
		# where the swap space is set to 200% of RAM so that
		# hibernate can be supported.
		# d-i partman-auto/choose_recipe select root-encrypted

		$( if [ "${Preference_DiskEncryption}" = "YES" ] || [ "${Preference_DiskEncryption}" = "yes" ]; then
			echo "d-i partman-auto/method string crypto
			d-i partman-crypto/passphrase password ${Preference_Disk_Password}
			d-i partman-crypto/passphrase-again password ${Preference_Disk_Password}
			d-i partman-auto-crypto/erase_disks boolean false
			d-i partman-auto-lvm/new_vg_name string rtd-crypt"
		else
			echo "d-i partman-auto/method string lvm
			d-i partman-auto-lvm/new_vg_name string rtd-lvm"
		fi )
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true
		# You can choose one of the three predefined partitioning recipes:
		# - atomic: all files in one partition
		# - home:   separate /home partition
		# - multi:  separate /home, /var, and /tmp partitions
		d-i partman-auto/choose_recipe select atomic
	EOF

	# cat >> ${PRESEED_FILE} <<-'EOF'

	# 	d-i partman-auto/expert_recipe string                   \
	# 	multi-cnx ::                                            \
	# 		538 538 1075 free                               \
	# 			$primary                                \
	# 			$iflabel{ gpt }                         \
	# 			$reusemethod{ }                         \
	# 			method{ efi } format{ }                 \
	# 		.                                               \
	# 		3500 3500 3500 ext3                             \
	# 			$primary{ } $bootable{ }                \
	# 			method{ format } format{ }              \
	# 			use_filesystem{ } filesystem{ ext4 }    \
	# 			mountpoint{ /boot }                     \
	# 		.                                               \
	# 		200% 25000 200% linux-swap                      \
	# 		 	$lvmok{ } lv_name{ swap }               \
	# 		 	in_vg { crypt }                         \
	# 		 	$primary{ }                             \
	# 		 	method{ swap } format{ }                \
	# 		.                                               \
	# 		500 1000 1000000000 ext4                        \
	# 			$lvmok{ } lv_name{ root }               \
	# 			in_vg { crypt }                         \
	# 			$primary{ }                             \
	# 			method{ format } format{ }              \
	# 			use_filesystem{ } filesystem{ ext4 }    \
	# 			mountpoint{ / }                         \
	# 		.

	# 	# --------------------------------------------------- #
	# EOF
 


	# write out conditionsl elements of the preseed file:
	case $_role in
		minecraft-server | minecraft | Minecraft | MINECRAFT | minecraft_server | Minecraft-server)
			cat >> ${PRESEED_FILE} <<-EOF
			# --------------------------------------------------- #
			# C.4.12. Addon Tasks for Minecraft Server
			# --------------------------------------------------- #
			d-i preseed/late_command string \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			cp /*.cfg /target/opt/rtd/ ; \
			in-target mkdir -p "/etc/systemd/system/getty@tty1.service.d" ; \
			in-target echo "[Service]" > "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "ExecStart=-/sbin/agetty --noissue --autologin tangarora "%I" "$TERM"" >> "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "Type=idle" >> "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "bash /home/tangarora/minecraft.server" >> /home/tangarora/.bashrc ; \
			in-target wget https://github.com/vonschutter/RTD-Minecraft-Server-Manager/raw/master/minecraft-server -O /home/tangarora/minecraft.server ; \
			in-target chmod 777 /home/tangarora/minecraft.server ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			reboot; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to greacefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
		kvm_server | Kvm | KVM | kvm | kvm-server )
			cat >> ${PRESEED_FILE} <<-EOF
			# --------------------------------------------------- #
			# C.4.12. Addon Tasks for KVM Server
			# --------------------------------------------------- #
			d-i preseed/late_command string \
			in-target apt-get -y install qemu-system libvirt-daemon-system ; \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to gracefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
		* )
			cat >> ${PRESEED_FILE} <<-EOF

			# --------------------------------------------------- #
			# C.4.12. Default preseed Addon Tasks
			# --------------------------------------------------- #
			# for Debian to work (ignored by Ubuntu)...
			d-i preseed/late_command string \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
			in-target mkdir -p /root/.ssh ; \
			in-target mkdir -p /home/${Preference_InitialUser}/.ssh ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /root/.ssh/authorized_keys" ; \
			in-target /bin/sh -c "echo ${Preference_ssh_pub_key} >> /home/${Preference_InitialUser}/.ssh/authorized_keys" ; \
			cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

			# Answer the last question
			d-i debian-installer/splash boolean true

			# Option to try to gracefully eject the installation media:
			d-i cdrom-detect/eject boolean true

			# Shutdown machine
			d-i finish-install/reboot_in_progress note

			# --------------------------------------------------- #
			EOF
		;;
	esac

	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ${_saveto}
	system::log_item "Preseed file created: ${PRESEED_FILE}
	Containging DATA:
	$(cat ${PRESEED_FILE})"

	unset Preference_DiskEncryption \
	Preference_Password \
	Preference_InitialUser \
	Preference_InitialUserFullName \
	Preference_InitialUserGroup \
	Preference_InitialUserPassword \
	Preference_InitialKeyboardLayout \
	Preference_InitialTimeZone \
	Preference_Wireless_ID \
	Preference_Wireless_Password\
	PRESEED_FILE \
	TASK_FILE \
	_role \
	_task \
	Preference_InitialUserPasswordEncrypted 

}















#                 __
#               .'  '.
#              :      :
#              | _  _ |
#           .-.|(o)(o)|.-.        _._          _._
#          ( ( | .--. | ) )     .',_ '.      .' _,'.
#           '-/ (    ) \-'     / /' `\ \ __ / /' `\ \
#            /   '--'   \     / /     \.'  './     \ \
#            \ `"===="` /     `-`     : _  _ :      `-`
#             `\      /'              |(o)(o)|
#               `\  /'                |      |
#               /`-.-`\_             /        \
#         _..:;\._/V\_./:;.._       /   .--.   \
#       .'/;:;:;\ /^\ /:;:;:\'.     |  (    )  |
#      / /;:;:;:;\| |/:;:;:;:\ \    _\  '--'  /__
#     / /;:;:;:;:;\_/:;:;:;:;:\ \ .'  '-.__.-'   `-.

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Internal Functions       ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::









set_colors ()
{
# Description: Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message.
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# Usage:
#	Simply call this function by stating its name:
# 	set_colors
#
# Globals:
# Arguments: None
# Outputs: Sets usable variables: $picachu $music $chess $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# as well as: $[yellow, darkyellow, red, darkred, endcolor, green, darkgreen, blue, darkblue, cyan, darkcyan, gray, purple, darkpurple]
# Returns:
# Usage: echo -e $yellow "text to display" or echo -e $picachu
#
# "ðŸ”´  ðŸ”µ "
# The function will not return any sucess or failure codes. It will do its best and exit.
#
# Num  Colour    #define         R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1
# End of documentation

# Foreground & background colour commands: (uncomment to use)
#
# tput setab [1-7] # Set the background colour using ANSI escape
# tput setaf [1-7] # Set the foreground colour using ANSI escape
#
#
# Black        0;30     Dark Gray     1;30
# Red          0;31     Light Red     1;31
# Green        0;32     Light Green   1;32
# Brown/Orange 0;33     Yellow        1;33
# Blue         0;34     Light Blue    1;34
# Purple       0;35     Light Purple  1;35
# Cyan         0;36     Light Cyan    1;36
# Light Gray   0;37     White         1;37
#
#
# Text mode commands
#
# tput bold    # Select bold mode
# tput dim     # Select dim (half-bright) mode
# tput smul    # Enable underline mode
# tput rmul    # Disable underline mode
# tput rev     # Turn on reverse video mode
# tput smso    # Enter standout (bold) mode
# tput rmso    # Exit standout mode
#
# Cursor movement commands
#
# tput cup Y X # Move cursor to screen postion X,Y (top left is 0,0)
# tput cuf N   # Move N characters forward (right)
# tput cub N   # Move N characters back (left)
# tput cuu N   # Move N lines up
# tput ll      # Move to last line, first column (if no cup)
# tput sc      # Save the cursor position
# tput rc      # Restore the cursor position
# tput lines   # Output the number of lines of the terminal
# tput cols    # Output the number of columns of the terminal
#
# Clear and insert commands
#
# tput ech N   # Erase N characters
# tput clear   # Clear screen and move the cursor to 0,0
# tput el 1    # Clear to beginning of line
# tput el      # Clear to end of line
# tput ed      # Clear to end of screen
# tput ich N   # Insert N characters (moves rest of line forward!)
# tput il N    # Insert N lines
#
# Other commands
#
# tput sgr0    # Reset text format to the terminal's default
# tput bel     # Play a bell
#
# # Reset
# Color_Off='\033[0m'       # Text Reset
#
# # Regular Colors
# Black='\033[0;30m'        # Black
# Red='\033[0;31m'          # Red
# Green='\033[0;32m'        # Green
# Yellow='\033[0;33m'       # Yellow
# Blue='\033[0;34m'         # Blue
# Purple='\033[0;35m'       # Purple
# Cyan='\033[0;36m'         # Cyan
# White='\033[0;37m'        # White
#
# # Bold
# BBlack='\033[1;30m'       # Black
# BRed='\033[1;31m'         # Red
# BGreen='\033[1;32m'       # Green
# BYellow='\033[1;33m'      # Yellow
# BBlue='\033[1;34m'        # Blue
# BPurple='\033[1;35m'      # Purple
# BCyan='\033[1;36m'        # Cyan
# BWhite='\033[1;37m'       # White
#
# # Underline
# UBlack='\033[4;30m'       # Black
# URed='\033[4;31m'         # Red
# UGreen='\033[4;32m'       # Green
# UYellow='\033[4;33m'      # Yellow
# UBlue='\033[4;34m'        # Blue
# UPurple='\033[4;35m'      # Purple
# UCyan='\033[4;36m'        # Cyan
# UWhite='\033[4;37m'       # White
#
# # Background
# On_Black='\033[40m'       # Black
# On_Red='\033[41m'         # Red
# On_Green='\033[42m'       # Green
# On_Yellow='\033[43m'      # Yellow
# On_Blue='\033[44m'        # Blue
# On_Purple='\033[45m'      # Purple
# On_Cyan='\033[46m'        # Cyan
# On_White='\033[47m'       # White
#
# # High Intensity
# IBlack='\033[0;90m'       # Black
# IRed='\033[0;91m'         # Red
# IGreen='\033[0;92m'       # Green
# IYellow='\033[0;93m'      # Yellow
# IBlue='\033[0;94m'        # Blue
# IPurple='\033[0;95m'      # Purple
# ICyan='\033[0;96m'        # Cyan
# IWhite='\033[0;97m'       # White
#
# # Bold High Intensity
# BIBlack='\033[1;90m'      # Black
# BIRed='\033[1;91m'        # Red
# BIGreen='\033[1;92m'      # Green
# BIYellow='\033[1;93m'     # Yellow
# BIBlue='\033[1;94m'       # Blue
# BIPurple='\033[1;95m'     # Purple
# BICyan='\033[1;96m'       # Cyan
# BIWhite='\033[1;97m'      # White
#
# # High Intensity backgrounds
# On_IBlack='\033[0;100m'   # Black
# On_IRed='\033[0;101m'     # Red
# On_IGreen='\033[0;102m'   # Green
# On_IYellow='\033[0;103m'  # Yellow
# On_IBlue='\033[0;104m'    # Blue
# On_IPurple='\033[0;105m'  # Purple
# On_ICyan='\033[0;106m'    # Cyan
# On_IWhite='\033[0;107m'   # White




  	local ecode="\033["

	yellow="${ecode}1;33m"
	darkyellow="${ecode}0;33m"
	red="${ecode}1;31m"
	darkred="${ecode}0;31m"
	endcolor="${ecode}0m"
	green="${ecode}1;32m"
	darkgreen="${ecode}1;32m"
	blue="${ecode}1;34m"
	darkblue="${ecode}0;34m"
	cyan="${ecode}0;36"
	darkcyan="${ecode}0;36"
	gray="${ecode}0;37"
	purple="${ecode}1;35"
	darkpurple="${ecode}0;35"

	# Back compatability w. old scripts
	export YELLOW="$yellow"
	export RED="$red"
	export ENDCOLOR="$endcolor"
	export GREEN="$green"
	export BLUE="$blue"

	anim=(
	"${blue}â€¢${green}â€¢${red}â€¢${magenta}â€¢    "
	" ${green}â€¢${red}â€¢${magenta}â€¢${blue}â€¢   "
	"  ${red}â€¢${magenta}â€¢${blue}â€¢${green}â€¢  "
	"   ${magenta}â€¢${blue}â€¢${green}â€¢${red}â€¢ "
	"    ${blue}â€¢${green}â€¢${red}â€¢${magenta}â€¢"
	)

	echo -e "$yellow * $darkyellow * $red * $darkred * $green * $darkgreen * $blue * $darkblue * $cyan * $darkcyan * $gray * $darkgray * $purple * $darkpurple * $endcolor"
}





term::start_animation ()
{
# Description:
# A simple function to display and animation during a silent acton
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::start_animation "Display text"
# term::stop_animation
#
# End of documentation

	setterm -cursor off
	export ANIM_PID="0"
	PAD="---------------------------------------------------------"
	LINE=$(printf "%s %s" "${@}" "$PAD" | cut -c 1-${#PAD})
	(
	while true; do
		for i in {0..4}; do
			printf "$LINE  \r\033[2K ${anim[i]}"
			sleep 0.1
		done

		for i in {4..0}; do
			printf "\r\033[2K $LINE  ${anim[i]}"
			sleep 0.1
		done
	done
	) & 

	export ANIM_PID="${!}" 
}







term::stop_animation ()
{
# Description:
# A simple function to STOP display and animation during a silent acton
#
# Globals:
# Arguments: 
# Outputs: Standard out
# Returns:
# Usage: 
# term::stop_animation
#
# End of documentation
	[[ -e "/proc/${ANIM_PID}" ]]  && kill -SIGPIPE "${ANIM_PID}"
	printf "${erace_line}$LINE [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n"
	unset LINE
	setterm -cursor on
}







rtd_oem_pause ()
{
# Description:
# A simple function to pause and wait for end user input.
# The function expects a non zero (0) argument to execute the pause
# and wait for the end user to press ENTER to continue execution.
#
# Globals:
# Arguments: 0 - !0 "[error message]"
# Outputs: Standard out
# Returns:
# Usage:  suggestion stop on execution error:
# EXPRESSION  || rtd_oem_pause 1
# or
# EXPRESSION ; rtd_oem_pause $?
#
# In both of these cases script execution will halt and wait for confirmation
# before continuing.
#
# Calling the function with no parameters will cause the function to simply continue. 
# This is useful in scripts when using with a captured return variable: $?
#
# EXPRESSION ; rtd_oem_pause $?
#
# in this case the script will continue if the EXPRESSION was successful, but will
# pause if the EXPRESSION failed.
#
# End of documentation
	ERRMSG=$@

	if [ ! $1 -eq 0 ]; then
		read -p "$ERRMSG: Press  [ ENTER ] to continue:"
	fi
}




pause_a_given_time ()
{
# Description:
# Simple function to pause for a given number of seconds whle showing a count down
# in seconds. If only a pause and no output is needed then it would be simpler to
# use the 'pause' built in command.
#
# Globals: OPTIND
# Arguments: -t -m -e where -t 'seconds' is mandatory.
# Outputs: STDOUT
# Returns: STDERR
# Usage: [-t <seconds> ] [-e <word> *completion message* ] [-m <word> *start message* ]
#
# EXAMPLE:
#
# pause_a_given_time -t 10 -m Waiting... -e Done!
#
# End of documentation
        local OPTIND o a
        while getopts ':t:m:e:' OPTION; do
                case "$OPTION" in
                t )
                        local _time="${OPTARG}"
                ;;
                e )
                        local _end_message="${OPTARG}"
                ;;
                m )
                        local _message="${OPTARG}"
                ;;
                ? )
                        write_host --cyan  "Usage: ${FUNCNAME[0]} [-t <seconds> ] [-e <word> *completion message* ] [-m <word> *start message* ]"
                        return 1
                ;;
                esac
        done
        unset OPTIND

        if [[ -z $_time ]] ; then
		write_error "Specifying time is required! [-t <seconds> ] Optional arguments are: [-e <word> *completion message* ] [-m <word> *start message* ]"
		return 1
	else
		write_status "$_message"
		while [ $_time -ge 1 ]; do
			echo -ne "One Moment please $_time ... \r"
			sleep 1
			_time=$[$_time-1]
		done
		echo
		write_status "$_end_message"
	fi
}





write_host ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# This function will print a message to the standard out in a color specified.
# Specified colors can be colord defined in the function "set_colors"
# If no color option is specified this cunctio simply works like the echo command.
#
# Globals:
# Arguments: [color option]
# Outputs:
# Returns:
# Usage: write_host [option] [String]
#
# where [option] is a supported color:
# --yellow            Prints message in YELLOW
# --darkyellow        Prints message in DARK YELLOW
# --red               Prints message in RED
# --darkred           Prints message in DARK RED
# --endcolor          DEFAULT color as in terminal.
# --green             Prints message in GREEN
# --darkgreen         Prints message in DARK GREEN
# --blue              Prints message in BLUE
# --darkblue          Prints message in BLUE
# --cyan              Prints message in CYAN
# --darkcyan          Prints message in DARK CYAN
# --gray              Prints message in GRAY
# --purple            Prints message in PURPLE
# --darkpurple        Prints message in  DARK PURPLE
#
# NOTE: this function uses the "tput" mechanisms to set colors, and gice a convenient
# and simple uman way to access them. The target system must have "tput" aavailable.
#
#
# End of documentation
	_option=$1

	case ${_option} in
		--yellow ) color="$(tput bold; tput setaf 3)" ;;
		--darkyellow ) color="$(tput dim; tput setaf 3)" ;;
		--red ) color="$(tput bold; tput setaf 1)" ;;
		--darkred ) color="$(tput setaf 3)" ;;
		--endcolor ) color="$(tput sgr0)" ;;
		--green ) color="$"$(tput bold; tput setaf 2)"" ;;
		--darkgreen ) color="$(tput dim; tput setaf 2)" ;;
		--blue ) color="$(tput bold; tput setaf 4)" ;;
		--darkblue ) color="$(tput dim; tput setaf 4)" ;;
		--cyan ) color="$(tput bold; tput setaf 6)" ;;
		--darkcyan ) color="$(tput dim; tput setaf 6)" ;;
		--gray ) color="$(tput dim; tput setaf 7)" ;;
		--purple ) color="$(tput bold; tput setaf 5)" ;;
		--darkpurple ) color="$(tput dim; tput setaf 5)" ;;
		*) local _text="$1" ;;
	esac
	[[ -z "${_text}" ]] && local _text="${color} ðŸ’» $2 $(tput sgr0)"
	echo -e "${_text} "

	# Tell the loging function to log the message requested...
	system::log_item "ðŸ§© ðŸ’» ${FUNCNAME[1]}: ${_text}"

}



write_error ()
{
# Description:
# is a simplified and consistent way to write output to the screen.
# write_error will print a message to the standard out in RED.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_error "[String]"
#
# End of documentation
	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]]; then
		if [[ -n "${text}" ]]; then
			echo "ðŸ§© ðŸ’¥ ${FUNCNAME[1]}: ${text}"
		fi
	else
		if [[ -n "${text}" ]]; then
			echo -e "$(tput bold; tput setaf 1)ðŸ§© ðŸ’¥ ${FUNCNAME[1]}: ${text}${endcolor}"
		fi
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "ðŸ§© ðŸ’¥ ${FUNCNAME[1]}: ${text}"

}


write_warning ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_warning will print a message to the standard out in Yellow.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_warning "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]]; then
		[ -n "${text}" ] && echo "ðŸ§© âš  ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "${yellow}ðŸ§© âš  ${FUNCNAME[1]}: ${text}${endcolor}"
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "ðŸ§© âš  ${FUNCNAME[1]}: ${text}"
	
}


write_status ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_status will print a message to the standard out in GREEN.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_status "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]] ; then
		[ -n "${text}" ] && echo "ðŸ§© âœ“ ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "${green}ðŸ§© âœ“ ${FUNCNAME[1]}: ${text}${endcolor}"
	fi

	# Tell the loging function to log the message requested...
	[ -n "${text}" ] && system::log_item "ðŸ§© âœ“ ${FUNCNAME[1]}: ${text}"
	
}


write_information ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_information will print a message to the standard out in BLUE.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_information "[String]"
#
# End of documentation


	local text=$1

	if [[ "${TERMUITXT}" == "nocolor" ]] ; then
		[ -n "${text}" ] && echo -e "ðŸ§© ðŸ›ˆ ${FUNCNAME[1]}: ${text}"
	else
		[ -n "${text}" ] && echo -e "${blue}ðŸ§© ðŸ›ˆ ${FUNCNAME[1]}: ${text}${endcolor}"
	fi

	# Tell the loging function to log the message requested...
	system::log_item "ðŸ§© ðŸ›ˆ ${FUNCNAME[1]}: ${text}"
	
}





list_loaded_internal_functions ()
{
# Description: Function to list all internal library functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--zformat]
# Outputs: Standard out, list of functions either formatted for zenity or not. Output may be used to populate a zenity menu or dialog.
# Returns:
# Usage: list_loaded_software_functions [] [--zformat]
# End of documentation

	if [[ "$1" == "--zformat" ]]; then
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			Description=$( head -200 $0 |grep "${index}" | head -1 |cut -f2 -d';' )
			echo -e "$i \n ${index} \n ${Description} \n"
			((i=i+1))
		done
	else
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			echo "$index #$i"
			((i=i+1))
		done

	fi
}


software::list_bundles ()
{
# Description: Function to list all software bundles defined in _rtd_recipes that are either installable or removable.
# Globals:
# Arguments: none or [--zformat]
# Outputs: Standard out, list of functions either formatted for zenity or not. Output may be used to populate a zenity menu or dialog.
# Returns:
# Usage: software::list_bundles [] [--zformat-installable | --zformat-removable]
# End of documentation

	if [[ ! -f ${completed_bundles_list} ]] ; then
		mkdir -p ${completed_bundles_list%/*}
		touch ${completed_bundles_list}
	fi

	case "$1" in
		--zformat-installable )
			# List software bundles for use with zenity
			for _bundle in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_" |grep -v "Single_Install" )
			do
				# Build each line to be displayed in the bundle installer...
				Description=$(grep -A 1 "$_bundle ()" "${_OEM_DIR}/core/_rtd_recipies" |tail -1)
				Description="${Description/"# "/": "}"
				Description="${Description/"	"/""}"
				cat ${completed_bundles_list} |grep "${_bundle/recipe_Bundle:_/}" &>/dev/null || echo -en "true \n ${_bundle/recipe_Bundle:_/} \n ${Description} \n"
			done
		;;
		--zformat-removable )
			# List software bundles for use with zenity
			completed_bundles_list="$(cat ${completed_bundles_list} )"
			for _installed_bundle in ${completed_bundles_list} ; do
				# Build each line to be displayed in the bundle installer...
				Description=$(grep -A 1 "recipe_Bundle:_$_installed_bundle ()" "${_OEM_DIR}/core/_rtd_recipies" |tail -1)
				Description="${Description/"# "/": "}"
				Description="${Description/"	"/""}"
				echo -e "true \n ${_installed_bundle} \n ${Description} \n"
			done
		;;
		* )
			# Default list format
			i=1
			for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_" |grep -v "Single_Install" )
			do
				echo "$index #$i"
				((i=i+1))
			done
		;;
	esac
}


list_loaded_software_functions ()
{
# Description: Function to list all software (_rtd_recipes) functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--nonum]
# Outputs: Standard out, list of functions either numerated or not.
# Returns:
# Usage: list_loaded_software_functions [] [--nonum]
# End of documentation

	if [[ "$1" == "--nonum" ]]; then
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo false ${index/recipe_/}
		done
	else
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo "$i	${index/recipe_/}"
			((i=i+1))
		done
	fi
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Executive                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# The following section launches the internal functions if given arguments
# request this. If no arguments are provided, then all the functions in this
# library will simply be loaded in to memory.

# Load base color sheme for use in the library...
set_colors


# Set log location and name...
if [[ $EUID -ne 0 ]]; then
	: ${_LOG_DIR:="${HOME}/.config/rtd/logs"}
	mkdir -p ${_LOG_DIR}
else
	: ${_LOG_DIR:="/var/log/rtd"}
	mkdir -p ${_LOG_DIR}
fi

# Set the log file to be used by the library...
: ${_SCRIPTNAME:=$(basename "${BASH_SOURCE[0]}")}
: ${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}


# initialize loging and provide process details...
export _LOGFILE
touch ${_LOGFILE}
system::log_item "ðŸ’» ********** : $(basename ${BASH_SOURCE[0]}) loaded by $(basename "${0}") on $HOSTNAME  : ************************************"
system::log_item "ðŸ’» Basic System Information: 
$(hostnamectl)"


# check if library is loaded from a terminal or another script (behavior may differ)...
# This may be useful to log for support reasons.
if (return 0 2>/dev/null) ; then 
	sourced=0
	write_warning "Library is sourced from a script or terminal! "

	if [[ "$(basename $0)" == "bash" ]] ; then
		write_information "Script is sourced from bash in a terminal: $0 $@"
	else
		write_information "Script is being sourced from a script: $(basename $0) $@"
	fi
else 
	sourced=1
	write_warning "Library is run directly! $(basename $0) $@"
fi





# Find and load all dependant files for this library... 
for i in ${_OEM_dependencies} ; do dependency::file ${i} &>/dev/null ; done 

# log variables for support reasons...
system::log_item "Library Loaded Variables: 
.........................................
$(env | grep '^_')

_LOG_DIR=${_LOG_DIR}
_LOGFILE=${_LOGFILE}
_SCRIPTNAME=${_SCRIPTNAME}
.........................................
"

# Check if this library is asked to do anything or just load...
if [ -z $1 ]; then
	echo "RTD Power Library $RTD_VERSION OK"
	export RTDFUNCTIONS=1
else
	case $1 in
		--help | -? )
			echo -e "${0##*/} :: RunTime Data Library HELP ::

			Usage: ${0##*/} [OPTIONS]
			valid option are :
			--help		 : Show this help text
			--list		 : List library functions (requires options: software, or internal, or all)
				software : (list) software install bundles available
				internal : (list) internal functions loaded
				all	 : (list) all library functions including software
			--devhelp	 : diplay script developer's help
			EXAMPLE:
			${0##*/} --list --internal"
		;;
		--list )
			case $2 in
				software ) list_loaded_software_functions ;;
				internal ) list_loaded_internal_functions ;;
				all ) ( echo -e $YELLOW "Software Recipies: $ENDCOLOR" && list_loaded_software_functions && echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR" && list_loaded_internal_functions ) ;;
				* ) echo "USAGE: The --list option requires a (what option). Valid option are: software, internal, all." ;;
			esac
		;;
		--devhelp )
			while true; do
				exec 3>&1
				selection=$(dialog --clear --no-collapse --backtitle "${BRANDING:-" RunTime Data : Function library : Script Development Support"}" --title "RTD Library Loaded Functions:" --menu "\n Chose a function below to see more details about the function." "${HEIGHT:-0}" "${WIDTH:-90}" "${LIST_HEIGHT:-0}" $(list_loaded_internal_functions) 2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case $selection in
					$selection )
						result=$(while IFS= read -r 'line'; do
							[[ "$line" == "$selection ()" ]]		&& printline="yes"
							[[ "$line" == "	$selection ()" ]]		&& printline="yes"
							[[ "$line" == "$selection () " ]]		&& printline="yes"
							[[ "$line" == "	$selection () " ]]		&& printline="yes"
							[[ "$line" == "		$selection ()" ]]	&& printline="yes"
							[[ "$line" == "# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
							[[ "$printline" == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
						done < $0 )
						dialog --clear --no-collapse --backtitle "${0##*/} :: RunTime Data Library HELP ::" --title "RTD Functon: $selection" --msgbox "$result" "${HEIGHT:-25}" "${WIDTH:-110}"
						return
					;;
					* ) exit ;;
				esac
			done
		;;
		--devhelp-gtk )
			while true; do
				exec 3>&1
				DisplayList=$(list_loaded_internal_functions --zformat)
				IFS_SAV=$IFS
				IFS=$(echo -en "\n\b")
				selection=$(zenity --list --modal --text="Select a function below, to see the function's documentation \n and usage:" --height="${ZHEIGHT:-600}" --width="${ZWIDTH:-1000}" --print-column=2 --column="Number" --column="Function" --column="Description" ${DisplayList} 2>/dev/null )
				exit_status=$?
				IFS=$IFS_SAV
				exec 3>&-
				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case "$selection" in
					"$selection" )
						result=$(while IFS= read -r 'line'; do
							# if echo "$line" |grep "$selection ()" ; then printline="yes" ; fi
							[[ "$line" == "${selection/ /}()" ]]		&& printline="yes"
							[[ "$line" =~ ?"$selection ()" ]]		&& printline="yes"
							[[ "$line" == *"$selection ()"* ]]		&& printline="yes"
							[[ "$line" == "# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
							[[ "$line" == "# End of Documentation" ]]	&& printline="no"
							[[ "$printline" == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
						done < $0 )
						zenity --info --modal --ok-label=BACK --title "RTD Functon: $selection" --text="$result" --height="${ZHEIGHT:-600}" --width="${ZWIDTH:-1000}"
					;;
					* )
					# Trap unknown exit code...
					exit
					;;
				esac
			done
		;;
		* )
			echo "No RECOGNIZED arguments provided: loading ${0:BASENAME}" ; echo "Use ${0:BASENAME} --help to see supported arguments"
			echo "Parameter provided: $1"
			echo "$0 launched with unknown parameters" >${_LOGFILE:-"/var/log/$(basename $0)"}
		;;
	esac
fi


# Cleanup on exit: 
# for var in $(compgen -v | grep '^_'); do
#     unset $var
# done
