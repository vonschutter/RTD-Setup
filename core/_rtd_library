#!/bin/bash
export RTD_VERSION=2.0
<<Library_Documentation
::				R T D   F u n c t i o n   L i b r a r y
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
:: 	Version:	2.0
::
::
::	Purpose:	To collect and enable the use of code snippets in other scripts.
::			To document these thoroughly so that they may be useful for learning BASH.
::	Usage: 		call this file using the "source" statement in bash.
::
::	This script is shared in the hopes that
::	someone will find it useful.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

---  To see options to use this library type "bash _rtd_library --help"
---  To see usefull documentation on each function in this library in a Terminal or remote ssh: "bash _rtd_library --devhelp"
---  To see usefull documentation on each function in this library in GTK (local desktop): "bash _rtd_library --devhelp-gtk"


	Functions defined in this library:

	Function Name: 					Description:
	----------------------------------------------------------------------------------------------------------------
	add_gnome3_favorite_app				: Adds a new favorite app to the gnome favorites bar
	add_software_task 				: Wrapper function to execute a command and display pretty terminal OK or FAIL
	backup_running_vm 				: Backs up all running virtual machines on the local computer
	change_disk_pass 				: Allows user to change password of the system partition encrypted disk
	check_dependencies 				: Checks that software requirements are met so scripts do not fail
	check_if_password_p0wned 			: Allows user to check if an intended password is already in well known dictionaries
	check_menu_availability 			: Checks if it is possible to display graphical menus in a terminal
	cleanup_and_finish 				: Cleans and clears variables and temp files used by the media creations functions
	compress_all_items_here				: Compress all folders and files in pwd using 7z (optionally encrypt)
	compress_provided_items				: Compress and optionally encrypt discrete contents
	create_iso_image 				: Creates an OS iso image
	create_iso_image_debian 			: Creates a Debian iso image
	create_physical_media_from_iso			: Create physical media thumb drive from an ISO file
	debug_list_loaded_functions			: Lists all loaded RTD functions in the environment
	create_swapfile					: Create a new swapfile
	display_result 					: Displays command results in a pretty terminal box
	display_spinner					: Display a spinner in the terminal
	display_software_installation_choices_gtk	: Show software installation options defined in recipe file (external)
	display_software_installation_choices_term	: Show software installation options defined in recipe file (external)
	dl						: Downloads and installs a package from the internet
	download_and_manipulate_iso_debian 		: Download and modify a debian iso to automatically install OEM addons
	enable_firewall					: Will turn on UFW and add the Allow SSH rule
	ensure_admin					: Elevates privileges to admin root for the whole script asks for password
	ensure_flatpak_package_managment		: Ensure that the Flatpack software management is available
	ensure_snap_package_managment			: Ensure that the snap software management system is installed
	err_no_menu_system_found 			: Function to handle what to do if it is not possible to currently display menus in a terminal
	get_Windows_Product_Key				: Retrieves a Microsoft Windows product key if it is stored in BIOS (common for OEM)
	generate_autounattend_xml			: Creates an autounattend.xml for Windows setup
	generate_autoyast_file				: Generates an installation configuration file for SUSE builds.
	generate_fedora_ks_cfg_file			: Creates a kickstart file for fedora
	generate_minecraft_server_launcher		: Creates a minecraft server launcher, w. automatic dependeny resolutions
	generate_report_disk_space_used_by_directory 	: Generate a disk usage report
	generate_rtd_me_sh_cmd				: Creates a rtd bootstrap script for system/software install for Windows, Linux, MAC OS, BSD etc.
	InstallSoftwareFromRepo				: Installs a package from a repository supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.
	is_software_package_available			: Checks to see if a software package is available in a repository
	io_on_notify_wait				: Wait for a disk change and then execute a command
	is_software_package_installed			: Checks to see if a software package already is installed
	list_loaded_internal_functions			: List all internal library functions loaded... for debugging/support purposes.
	list_loaded_software_functions			: List all software (_rtd_recipes) functions loaded... for debugging/support purposes.
	make_kvm_virtual_machine_now_from_debian_org 	: Immediately create a virtual machine directly from debian.org
	make_kvm_virtual_machine_now_from_fedora_org	: Immediately create a virtual machine directly from Fedora.org
	make_kvm_virtual_machine_now_from_iso 		: Make a virtual machine from a generated ISO image
	make_kvm_virtual_machine_now_from_microsoft	: Make a virtual machine running Windows
	make_kvm_virtual_machine_now_from_opensuse_com	: Immediately create a virtual machine directly from oensuse.org
	make_kvm_virtual_machine_now_from_ubuntu_com 	: Immediately create a virtual machine from ubuntu.com
	make_preseed_cfg 				: Generate a debian + derivatives preseed file for fully automated installs
	notice_rtd_loaded				: Notifies a script that RTD functions are loaded
	make_system_recovery_partition			: Build a system recovery partition
	prepare_environment_for_iso_creation 		: Ensure that all prerequisites are met for downloadeing; extracting; and creating a modified ISO file
	rtd_oem_cfg_Account_Setup 			: MODULE: sets default user account and encrypted password for a preseed file
	rtd_oem_cfg_Account_Setup			: Generates a preseed section [Account setup] (d-i passwd string)
	rtd_oem_check_inet_access 			: Verifies that the internet is accessible
	rtd_oem_find_live_release 			: locate and download live media for debian and ubuntu
	rtd_oem_kde_set_wallpaper 			: Sets wallpaper in the plasma workspace
	rtd_oem_make_launchers				: Creates a default set of pre-defined launchers
	rtd_oem_pause 					: Pause function; will only pause if a non zero integet is passed
	rtd_oem_preseed_cfg_Addon_MinecraftServer 	: MODULE  sets minecraft server setup tasks for a preseed file
	rtd_oem_preseed_cfg_Addon_Tasks 		: MODULE  sets default post OS install tasks for a preseed file
	rtd_oem_preseed_cfg_Disk_Layout 		: MODULE  sets encrypted disk defaults and partitioning for a preseed file
	rtd_oem_preseed_cfg_EFI 			: MODULE  sets EFI boot options for a preseed file
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation: MODULE  sets default GRUP boot configuration for a preseed file
	rtd_oem_preseed_cfg_Localization 		: MODULE  sets default default localization for a preseed file
	rtd_oem_preseed_cfg_Network_Configuration 	: MODULE  sets default network configuration for a preseed file
	rtd_oem_preseed_cfg_Package_Selection 		: MODULE  sets default software selection for a preseed file
	rtd_oem_preseed_cfg_Prevent_Install_On_USB 	: MODULE  settings for a preseed file to prevent auto installation on a USB stick
	rtd_oem_preseed_cfg_Unattended_Install 		: MODULE  sets fully unattended install for a preseed file
	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options 	: MODULE  sets optional elements for a kickstart file normally not needed
	rtd_oem_register_wallpapers_for_gnome		: Register wallpapers for Gnome (so they show up in the appearance tool)
	rtd_oem_release_upgrade 			: Attempt to perform a release upgrade for supported systems
	rtd_oem_remove_non_western_latin_fonts 		: Remove all non-latin fonts from a distribution. for the western world these are not needed and slow the system
	rtd_oem_remove_software 			: Removes the software title requested on all supported distributions
	rtd-oem_register_wallpapers_for_gnome		: Generates the xmp file needed for gnome to "see" the installed wallpapers
	rtd_oem_reseal 					: Reseals the system for delivery to a new user user will be asked for password and locale etc.
	rtd_oem_reset_default_environment_config 	: Removes previously configured auto-login and running of setup scripts
	rtd_oem_turn_on_gui_network_management		: Set network managers to manage network interfaces if not set
	rtd_oem_setup_brand_splash_screen 		: Brands splash screens on a bootable distribution install media
	rtd_oem_ubuntu_auto_install_iso_builder 	: Creates automatic install media for Ubuntu
	rtd_ppa_checker 				: Checks PPA archives on supported distributions
	rtd_server_setup_choices_productivity		: Builtin Server terminal productivity software install options
	rtd_server_setup_choices_services		: Builtin Server software options
	rtd_setup_choices_for_preseed			: Write out a Debian pre-defined preeseed file to a location requested
	rtd_setup_choices_preseed 			: Allows for user specified choices to be added to a preseed file
	rtd_setup_choices_term_fallback			: For server setup, displays a menu where you may chose CLI productivity software
	rtd_update_system 				: Performs a software update/refresh on supported distributions
	rtd_wait_for_internet_availability 		: Checks that the internet is reachable and waits until it is...
	run_command_in_gnome_user_session 		: Running with elevated privileges; will allow to switch back to user who started process to execute script in that environment
	scan_for_malware				: Scan location for malware
	set_colors					: Set colors for prompting on screen in human usable variables: $RED, $GEEN etc.
	set_enable_oem_elevated_privelege		: Set automatic privilege escalation for scripts
	set_gnome_ui_common_tweaks_for_user		: Set common UI usability tweaks
	set_gnome_ui_mac_tweaks_for_user		: Set MAC UI usability tweaks
	set_gnome_ui_moca_tweaks_for_user		: Set eye strain friendly flat theme UI tweaks
	set_gnome_ui_win10_tweaks_for_user		: Set Windows 10 UI usability tweaks
	set_gnome_ui_corprate_crisp_tweaks_for_user	: Set corporate/business friendly UI tweaks
	set_install_command				: Determines what install command should be used to install packages from repositories
	set_oem_elevated_privilege_gui			: Set x-authority toallow root GUI
	SofwareManagmentAvailabilityCHK			: Checks to see that the software managment system is not busy
	toggle_oem_auto_login				: Toggle the auto login option for the user
	test_iso_boot_media				: Test bootable media using QEMU
	up2date						: Older universal software update function
	write_error					: Prints an error message to terminal in RED
	write_host 					: Prints a message to the terminal w. a choice of color
	write_information 				: Prints a message to the terminal in BLUE
	write_status					: Prints a message to the terminal in GREEN
	write_warning 					: Prints a message to the terminal in YELLOW


Use Google Coding standards:
In general any function that is not both obvious and short must be commented. Any function in a library must be commented regardless of
length or complexity. It should be possible for someone else to learn how to use your program or to use a function in your library
by reading the comments (and self-help, if provided) without reading the code.

All function comments should describe the intended API behaviour using:

1	Description of the function.
2	Globals: List of global variables used and modified.
3	Arguments: Arguments taken.
4	Outputs: Output to STDOUT or STDERR.
5	Returns: Returned values other than the default exit status of the last command run.

Advice: As a "best practice" working with this file, given the size and complexities, it is better to write a new function in an external script and
use the "source" statement to include this library in said script, so that all the other functions here are available to use in the new
function.

Library_Documentation









#              .--.           .---.        .-.
#          .---|--|   .-.     | A |  .---. |~|    .--.
#       .--|===|Ch|---|_|--.__| S |--|:::| |~|-==-|==|---.
#       |%%|NT2|oc|===| |~~|%%| C |--|   |_|~|CATS|  |___|-.
#       |  |   |ah|===| |==|  | I |  |:::|=| |    |GB|---|=|
#       |  |   |ol|   |_|__|  | I |__|   | | |    |  |___| |
#       |~~|===|--|===|~|~~|%%|~~~|--|:::|=|~|----|==|---|=|
#       ^--^---'--^---^-^--^--^---'--^---^-^-^-==-^--^---^-'
###########################################################################
##                                                                       ##
##                        Library Settings                               ##
##                                                                       ##
###########################################################################



# load branding informaton:
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"/_branding

# Load base folder structure for optional administrative scripts:
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"/_locations

# Software recipes and bundles to be installed on request:
source "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"/_rtd_recipies

# Determine log file directory
: ${_ERRLOGFILE:-"$_LOG_DIR/$( basename $0)-error.log"}
: ${_LOG_FILE:-"${_LOG_DIR}/$( basename $0).log"}















#     |>>>                                                      |>>>
#     |                     |>>>          |>>>                  |
#     *                     |             |                     *
#    / \                    *             *                    / \
#   /___\                 _/ \           / \_                 /___\
#   [   ]                |/   \_________/   \|                [   ]
#   [ I ]                /     \       /     \                [ I ]
#   [   ]_ _ _          /       \     /       \          _ _ _[   ]
#   [   ] U U |        {#########}   {#########}        | U U [   ]
#   [   ]====/          \=======/     \=======/          \====[   ]
#   [   ]    |           |   I |_ _ _ _| I   |           |    [   ]
#   [___]    |_ _ _ _ _ _|     | U U U |     |_ _ _ _ _ _|    [___]
#   \===/  I | U U U U U |     |=======|     | U U U U U | I  \===/
#    \=/     |===========| I   | + W + |   I |===========|     \=/
#     |  I   |           |     |_______|     |           |   I  |
#     |      |           |     |||||||||     |           |      |
#     |      |           |   I ||vvvvv|| I   |           |      |
# _-_-|______|-----------|_____||     ||_____|-----------|______|-_-_
#    /________\         /______||     ||______\         /________\
#   |__________|-------|________\_____/________|-------|__________|

###########################################################################
##                                                                       ##
##                       Library Functions                               ##
##                                                                       ##
###########################################################################

# All library functions are listed below in a few sections:
# - System Managment
# - Software Management
# - Virtual Machine Management
# - Internal Configuration Repository
# - Script Internal Functions








#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#              ________________________________________________
#             /                                                \
#            |    _________________________________________     |
#            |   |                                         |    |
#            |   |  C:\> _                                 |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |                                         |    |
#            |   |_________________________________________|    |
#            |                                                  |
#             \_________________________________________________/
#                    \___________________________________/
#                 ___________________________________________
#              _-'    .-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.  --- `-_
#           _-'.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.--.  .-.-.`-_
#        _-'.-.-.-. .---.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-`__`. .-.-.-.`-_
#     _-'.-.-.-.-. .-----.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-----. .-.-.-.-.`-_
#  _-'.-.-.-.-.-. .---.-. .-------------------------. .-.---. .---.-.-.-.`-_
# :-------------------------------------------------------------------------:
# `---._.-------------------------------------------------------------._.---'
# ----------------------------------------------------------------
#  ____            _
# / ___| _   _ ___| |_ ___ _ __ ___
# \___ \| | | / __| __/ _ \ '_ ` _ \
#  ___) | |_| \__ \ ||  __/ | | | | |
# |____/ \__, |___/\__\___|_| |_| |_|
#        |___/
#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
# ----------------------------------------------------------------





change_disk_pass ()
{
# Description: Function to change the passphrase fo an encrypted storage device.
# It will offer to change the first encrypted volume found by blockid.
# It is unclear how this will work if there are multiple encrypted volumes found.
# The function does not expect an argument. It will prompt for a password.
#
# Globals:
# Arguments: None accepted
# Outputs: Interactive
# Returns: default exit status of the last command run.
# Usage: change_disk_pass
#
#
# End of Documentation

	clear
	write_host --red "Changing the disk encryption password for your hard drive:"
	cryptsetup luksChangeKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)"
	read -p "Press  [ ENTER ] to continue:"
}









oem_autounlock_disk ()
{
# Setup automatic unlocking of the encrypted system disk (encryption is default on RTD systems).
# NOTE: This will render the encryption useless since the key to unlock the encrypted
# volume will be located on an unencrypted location on the same system as the encrypted volume.
# This is the same as locking your door and leaving the key by the door outside.
#
# The intention behind this is to be able to complete all build activites without manual intervention
# of any kind. The intention is to remove the key file after all administrative tasks are complete.
#
# 1. Back up your initramfs disk
#
# Globals:
# Arguments: None accepted
# Outputs:
# Returns: default exit status of the last command run.
# Usage: oem_autounlock_disk
#
# End of Documentation
	cp  /boot/initrd.img-$(uname -r)  /boot/initrd.img-$(uname -r).bak

	cat > /boot/grub/grub.cfg <<- OEM_CRYPTLOCK_OPTION
	### BEGIN /etc/grub.d/10_linux ###

	menuentry 'Debian GNU/Linux, with Linux $(uname -r) (crypto safe)' --class debian --class gnu-linux --class gnu --class os {
		load_video
		insmod gzio
		insmod part_msdos
		insmod ext2
		set root='hd0,msdos1'
		search --no-floppy --fs-uuid --set=root 2a5e9b7f-2128-4a50-83b6-d1c285410145
		echo    'Loading Linux $(uname -r) ...'
		linux   /vmlinuz-$(uname -r) root=/dev/mapper/dradispro-root ro  quiet
		echo    'Loading initial ramdisk ...'
		initrd  /initrd.img-$(uname -r).safe
	}
	...
	## END /etc/grub.d/10_linux ###
	OEM_CRYPTLOCK_OPTION

	# 2. Create the key file in the unencrypted /boot partition
	dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4

	# 3. Set permissions
	chmod 0400 /boot/keyfile

	# 4. Add the new file as unlock key to the encrypted volume
	echo letmein1234 | cryptsetup -v luksAddKey $(blkid | grep crypto_LUKS|  cut -d : -f 1) /boot/keyfile -

	# 6. Edit /etc/crypttab
	chmod 0777 /etc/crypttab
	cp /etc/crypttab /etc/crypttab.temporary
	sed -i /"$(cat /etc/crypttab | cut -d " " -f 1 )"/d /etc/crypttab.temporary
	echo $(cat /etc/crypttab | cut -d " " -f 1-2)  /$(udevadm info $(blkid | grep crypto_LUKS|  cut -d : -f 1) |grep by-uuid | cut -d : -f 2 | head -1):/keyfile luks,keyscript=/lib/cryptsetup/scripts/pa$  >> /etc/crypttab.temporary
	mv /etc/crypttab /etc/crypttab.back
	mv /etc/crypttab.temporary /etc/crypttab

	# Restore permissions to crypttab
	chmod 0440 /etc/crypttab

	# Generate new initramfs
	mkinitramfs -o /boot/initrd.img-$(uname -r)  $(uname -r)

}











oem_register_all_tools ()
{
# Description: Function to register all executables on the current device.
# It will find all the $TLA powertools locations and make and executable lin to
# the system /bin directory. Tis assures that all tools are available in the path.
#
#
# Globals: ${_MODS_DIR}
# Arguments: None accepted
# Outputs:
# Returns: default exit status of the last command run.
# Usage: oem_register_all_tools
# Dependencies: _locations
#
# End of Documentation
	_bashrc="/home/${_OEM_USER:-"tangarora"}/.bashrc"

	sed -i s/'# session  optional       pam_xauth.so'/'session  optional       pam_xauth.so'/g /etc/pam.d/sudo
	if ! grep "xhost local:root" "${_bashrc}" ; then echo 'xhost local:root >/dev/null' >> "${_bashrc}" ; fi

	if [[ -n "${_MODS_DIR}" ]] ; then
		for d in $( ls -p ${_MODS_DIR}/ ) ; do
			write_status "Creating links to $d"
			chmod +x ${_MODS_DIR}/$d/rtd*
			ln -f -s ${_MODS_DIR}/$d/${_TLA,,}* -t /bin/
		done
		write_status "Creating links to ${_OEM_DIR}/core/*.sh"
		chmod +x ${_OEM_DIR}/core/*.sh
		ln -f -s ${_OEM_DIR}/core/*.sh -t /bin/
		return
	else
		write_error "Location variables not set!"
		return 1
	fi
}












check_menu_availability ()
{
# Description: First discover what menu system is installed. Some systems use "dialog" and
# other systems use whiptail for the terminal to show menus and dialogs.
# If nothing is found, then make sure it is available before continuing.
#
# Globals:
# RTD_GUI respected as default value. If unset it will be set to "dialog" or "whiptail"
# depending on which is present. IF both are present, the dialog is prefferred.
#
# Arguments: None accepted
# Outputs: Interactive
# Returns: Default exit status of the last command run.
# Usage: check_menu_availability
#
# End of documentation
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --no-button "NO: Use whiptail" --yes-button "YES: Install dialog" --yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			err_no_menu_system_found
		else
			echo "User selected No, exit status was $?."
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}










rtd_oem_make_launchers ()
{
# Description: Function that creates a default set of launchers for the Linux GUI menu system.
#
# Globals:
# The tools (scripts) located in {_OEM_DIR}/*/ are expected as launchers are created for these.
# ${_MODS_DIR}
#
# Arguments: None accepted
# Outputs: Launcherc created in /usr/share/applications/
# Returns: Default exit status of the last command run.
# Usage: rtd_oem_make_launchers
#
# End of documentation

	if [[ ! $UID -eq 0 ]]; then
		write_error "This function requires elevated privileges. Please elevate privileges prior to calling this function."
		return 1
	else
		write_information "Creating ${_TLA} launchers..."
		# Add launchers for some OEM apps.
		cat > /usr/share/applications/rtd.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD
		Comment=RTD Simple System Support Tool
		Exec=${_MODS_DIR}/Simple-Support-Tool.mod/rtd-simple-support-tool
		Path=${_MODS_DIR}/Simple-Support-Tool.mod/
		Icon=${_MODS_DIR}/Simple-Support-Tool.mod/Media_files/sys2.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-user-bakup.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-Backup
		Comment=RTD User home Backup Tool
		Exec=${_MODS_DIR}/System_User_Backup.mod/rtd-oem-backup-linux-config
		Path=${_MODS_DIR}/System_User_Backup.mod/
		Icon=${_MODS_DIR}/System_User_Backup.mod/Media_files/sys0.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-nordvpn.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD-NordVPN
		Comment=Nord VPN Termnal GUI
		Exec=${_MODS_DIR}/Nordvpn-Manager.mod/rtd-nordvpn
		Path=${_MODS_DIR}/Nordvpn-Manager.mod
		Icon=${_MODS_DIR}/Nordvpn-Manager.mod/Media_files/sys3.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-minercraft-server.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=Minecraft-Server
		Comment=Automatically download and start a Minecraft Server here now!
		Exec=${_MODS_DIR}/Minecraft-Server-Manager.mod/rtd-minecraft-server
		Path=${_MODS_DIR}/Minecraft-Server-Manager.mod
		Icon=${_MODS_DIR}/Minecraft-Server-Manager.mod/Media_files/sys5.ico
		Terminal=true
		Type=Application
		Categories=OEM;
		EOF

		cat > /usr/share/applications/rtd-switch-desktop.desktop <<-EOF
		[Desktop Entry]
		Version=2.0
		Name=RTD UI Look Changer
		Comment=Change the overall look and feel of your desktop (be more like Windows or MAC)
		Exec=${_MODS_DIR}/RTD-Desktop-Look-Switcher.mod/rtd-desktop-look-switcher
		Path=${_MODS_DIR}/RTD-Desktop-Look-Switcher.mod/
		Icon=${_MODS_DIR}/RTD-Desktop-Look-Switcher.mod/Media_files/sys7.ico
		Terminal=false
		Type=Application
		Categories=OEM;
		EOF
	fi
 }











get_Windows_Product_Key ()
{
# Description: Function to retrieve a Windows product key from the BIOS. This assumes that the OEM
# has indeed stored the windows key in the BIOS... Doing so is a common practice. It is useful to
# retrieve the key if it is desired to run Windows in a Virtual Machine and Presumably would prefer to
# not run the evaluation version of Windows. This function could also be used to take advantage of the
# ${WinKey} variable and echo it in to the autoinattend.xml file for unattended builds.
#
# Globals: RTD_GUI
# Arguments: None
# Outputs: A variable named: "${WinKey}" and echoing its contents to standard out.
# Returns: default exit status of the last command run.
# Usage: get_Windows_Product_Key
# End of documentation
	WinKey=$(sudo strings /sys/firmware/acpi/tables/MSDM | tail -1)
	echo "${WinKey}"
}











err_no_menu_system_found ()
{
# Description: Function to handle the error condition if a manu system is not found on the system.
# On occasion it may be neede to display dialog boxes and selection menus even in a terminal.
# for these cases; dialog, whiptail (newt), or zenity may be needed.
# This function will attempt to install the desired menu system and if it cannot or the user
# opts out it will error and exit the script.
#
# Globals: RTD_GUI
# Arguments: None
# Outputs: Interactive
# Returns: default exit status of the last command run.
# Usage:
# err_no_menu_system_found
# End of documentation

	echo -e $RED" ______________________________________________________________________ \n There is eiter no way to display menus on this system or you have told me \n to install the default  menu system! \n This is required to display the administrative menus... \n \n     Â¯\_( Í¡ðŸ‘ï¸â€¯ÍœÊ– Í¡ðŸ‘ï¸)_/Â¯ \n ______________________________________________________________________ \n"
	echo -e $YELLOW"May I attepmpt to install this ability to your system? \a $ENDCOLOR"
	read -p "Add software: (y/n)?" choice
	case "$choice" in
	y|Y )
		: "${RTD_GUI:=$1}"
		for i in dnf yum zypper apt-get; do
			if hash $i 2>/dev/null; then
				$i install $RTD_GUI -y
				if $? eq 0 ;  then
					echo -e $YELLOW"$RTD_GUI installed... exporting..."
					RTD_GUI="dialog --clear"
					export RTD_GUI
					return 0
				fi
			fi
		done
	;;
	n|N ) err_no_menu_system_available ;;
	* ) read -p  "Invalid Selection" && err_no_menu_system_found || exit 1 ;;
	esac
}













enable_firewall ()
{
# Description:
# Function to enable system firewall and add a given rule. This simple function
# enables Uncomplicated Fire Wall (UFW) and adds a rule to allow SSH to
# pass. This function expects no arguments. However nothing will be done if
# no ufw firewall is present on the system. The cunction will not attempt to add
# the ufw since this may conflict with any firewall present. To use this funciton
# to enable ufw, first any other firewall software must be disabled and ufw added.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo -e $faded_orange "UFW not present on this system: please turn on the firewall and configure it manually!" $ENDCOLOR
	fi
}











rtd_oem_reset_default_environment_config ()
{
# Description: Function to reset temporary configurations to their original setings from the
# distributor. To configure and/or automatically install Linux systems RTD OEM
# load process must make some changes to the system in question that are not
# good security practice or that may be disruptive during normal operations.
# These setings are not limited to bu include "auto login", "auto sudo" and
# "auto running scripts"...
# Globals:
# Arguments: None
# Outputs: removes autostart files and configurations from an OEM state to a default state.
# Returns:
# Usage:
# End of documentation

	# Disable the automatically trying to install OEM software
	mkdir -p ${_OEM_DIR}/cache/
	[[ -f /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ]] && mv /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ${_OEM_DIR}/cache/
	[[ -f /etc/sudoers.d/99_sudo_include_file ]] && mv /etc/sudoers.d/99_sudo_include_file ${_OEM_DIR}/cache/
	cp /home/${SUDO_USER}/.bashrc ${_OEM_DIR}/cache/bashrc
	# Keep ability for root to open dialog boxes for a user.
	sed -i '/xhost\ local:root/d' /home/${SUDO_USER}/.bashrc
	toggle_oem_auto_login
}













rtd_wait_for_internet_availability ()
{
# Description: Function that, when called, will wait for an active internet connection
# to be available before before continuing. Most softwrare install activities
# need an active internet connection to be able to install and update software.
# Naturally, some in house loads use local mirrors, but if you can see the
# internet, you would have access to your own ropositories as well...
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: rtd_wait_for_internet_availability
# End of documentation



	write_status "Waiting for internet access..."
	write_information "NOTE: Free access to the internet is required to continue."
	while ! ping -c 1 -W 1 8.8.8.8 &>/dev/null ; do
		write_status "Waiting..."
		sleep 10
	done
}










io_on_notify_wait ()
{
# Description: Function that, when called, will wait for a disk change
# and then execute the command passed as an argument. This is useful when
# wanting to keep two location in sync with minimal delay, or to scan
# for malware as soon as a change has occurred.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: io_on_notify_wait rsync -avt . host:/remote/dir ...
# End of documentation

	check_dependencies inotify-tools
	EVENTS="CREATE,CLOSE_WRITE,DELETE,MODIFY,MOVED_FROM,MOVED_TO"

	if [ -z "$1" ]; then
		write_error "Usage: $0 rsync -avt . host:/remote/dir ..."
		exit -1;
	fi

	inotifywait -e "$EVENTS" -m -r --format '%:e %f' . | (
		WAITING="";
		while true; do
		LINE="";
		read -t 1 LINE;
		if test -z "$LINE"; then
			if test ! -z "$WAITING"; then
				echo "CHANGE";
				WAITING="";
			fi;
		else
			WAITING=1;
		fi;
		done) | (
		while true; do
		read TMP;
		echo $@
		$@
		done
	)
}









display_spinner ()
{
# Description: Simple function to display a spinner in the terminal.
# Globals:
# Arguments: start/stop
# Outputs:
# Returns:
# Usage:
#
#
#
# End of documentation

		function _spinner() {
		# $1 start/stop
		#
		# on start: $2 display message
		# on stop : $2 process exit status
		#           $3 spinner function pid (supplied from stop_spinner)

		local on_success="DONE"
		local on_fail="FAIL"
		local nc="\e[0m"

		case $1 in
			start)
			# calculate the column where spinner and status msg will be displayed
			let column=$(tput cols)-${#2}-46
			# display message and position the cursor in $column column
			# echo -ne ${2}
			printf "%${column}s"

			# start spinner
			i=1
			sp='\|/-'
			delay=${SPINNER_DELAY:-0.15}

			while :
			do
				printf "${RED}\b[${sp:i++%${#sp}:1}]\b\b${ENDCOLOR}"
				sleep $delay
			done
			;;
			stop)
			if [[ -z ${3} ]]; then
				echo "spinner is not running.."
				exit 1
			fi

			kill $3 > /dev/null 2>&1

			# inform the user uppon success or failure
			echo -en "\b["
			if [[ $2 -eq 0 ]]; then
				echo -en "${green}${on_success}${nc}"
			else
				echo -en "${red}${on_fail}${nc}"
			fi
			echo -e "]"
			;;
			*)
			write_error "invalid argument, try {start/stop}"
			exit 1
			;;
		esac
		}

		function start_spinner {
		# $1 : msg to display
		_spinner "start" "${1}" &
		# set global spinner pid
		export _sp_pid=$!
		disown
		}

		function stop_spinner {
		# $1 : command exit status
		_spinner "stop" $1 $_sp_pid
		unset _sp_pid
		}

	if [[ "$1" == "start" ]] ; then
		start_spinner $2
	elif [[ "$1" == "stop" ]] ; then
		stop_spinner $2
	else
		write_error "invalid argument, try {start/stop}"
	fi

}











toggle_oem_run_once () {
# Task to run the OEM post configuaration on first login.
# the OEM post configuration may allow for interaction if desired and would
# best run on several distributions and in a full graphic environment.
#
# Globals:
# Arguments: [script path] [optional:path to .desktop launcher]
# Outputs:
# Returns:
# Usage:
#
# setup_oem_run_once /path/to/script.sh
# End of documentation
	_FILE=${2:-"/etc/xdg/autostart/oem-run.desktop"}
	# If the launcher exists, delete it, else create it.
	if [[ -e ${_FILE} ]] ; then
		if [[ -w "${_FILE}" ]]
		then
			write_information "Removing execution on login of (${_FILE})"
			rm ${_FILE}
		else
			write_warning "Write permission is NOT granted on ${_FILE}"
			write_status "Requesting elevated privileges..."
			sudo rm ${_FILE}
		fi
	else
		cat > ${_FILE} <<-CREATE_START_LINK
		# This will automatically start the RuntTime Data OEM config options on
		# the first login. Once run this launcher will be moved to the /opt/rtd folder
		# so that subsequent logins will not be plagued by the OEM setup.
		#
		[Desktop Entry]
		Type=Application
		Exec=sudo $1
		Terminal=true
		Hidden=false
		X-GNOME-Autostart-enabled=true
		Name=${_BACK_TITLE} OEM Run
		Comment=OEM
		CREATE_START_LINK
	fi
}










toggle_oem_auto_login ()
{
# Description: Function to toggle auto login for admin purposes.
# Call the function once to set auto login and call it again to
# unset auto login. This is usefult to do an administrative login interactively
# and run configuration scripts (like for OEM setup, KVM automatic template generation)
#
# This function will look for all the popular display managers adn common ways to configure
# automatic login and set those. If auto login is already set, this funciton will unset the
# automatic login.
#
# The function will also check and apply SUSE speciffic configurations: it will not edit the
# sddm.conf, gdm.conf, gdm3.conf, or lightdm.conf, instead, it modifies the suse speciffic
# displaymanager file in /etc/sysconfig/.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  toggle_oem_auto_login
#
#
# End of documentation

	# first, do not treat SUSE like the others... It wil complain and not do what you want...
	if ! hostnamectl |grep suse ; then
		# Toggle auto login for Light DM if present (Old Ubuntu, Mint?, Budgie? etc.)
		if [[ -f /etc/lightdm/lightdm.conf ]]; then
			if [[ -f /etc/lightdm/lightdm.conf.rtd-bak ]]; then
				write_status "***** LightDM auto login is enabled: toggeling off... ******"
				rm /etc/lightdm/lightdm.conf && mv /etc/lightdm/lightdm.conf.rtd-bak /etc/lightdm/lightdm.conf
			else
				write_status "***** LightDM auto login is disabled: toggeling on... ******"
				cp /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.rtd-bak
				cat > /etc/lightdm/lightdm.conf <<-OEM_LXDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/lightdm/lightdm.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[SeatDefaults]
				autologin-user=${SUDO_USER:-"tangarora"}
				autologin-user-timeout=0
				OEM_LXDM_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for SDDM if present (Kubuntu, SUSE, KDE Based DE's)
		if [[ -f /etc/sddm.conf ]]; then
			if [[ -f /etc/sddm.conf.rtd-bak ]]; then
				write_status "******* SDDM auto login is enabled: toggeling off... *******"
				rm /etc/sddm.conf && mv /etc/sddm.conf.rtd-bak /etc/sddm.conf
			else
				write_status "******* SDDM auto login is disabled: toggeling on... *******"
				cp /etc/sddm.conf /etc/sddm.conf.rtd-bak
				cat > /etc/sddm.conf <<-OEM_SDDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/sddm.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[Autologin]
				User=${SUDO_USER:-"tangarora"}
				Session=plasma.desktop
				OEM_SDDM_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for GDM3 if present (Ubuntu, Debian default etc.)
		if [[ -f /etc/gdm3/daemon.conf ]]; then
			if [[ -f /etc/gdm3/daemon.conf.rtd-bak ]]; then
				write_status "******* GDM3 auto login is enabled: toggeling off... *******"
				rm /etc/gdm3/daemon.conf && mv /etc/gdm3/daemon.conf.rtd-bak /etc/gdm3/daemon.conf
			else
				write_status "******* GDM3 auto login is disabled: toggeling on... *******"
				cp /etc/gdm3/daemon.conf /etc/gdm3/daemon.conf.rtd-bak
				cat >  /etc/gdm3/daemon.conf <<-OEM_GDM3_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/gdm3/daemon.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				[daemon]
				AutomaticLoginEnable=True
				AutomaticLogin=${SUDO_USER:-"tangarora"}
				WaylandEnable=false
				OEM_GDM3_LOGIN_OPTION
			fi
		fi

		# Toggle auto login for GDM per gnome standard (Fedora et. al.)
		if [[ -f /etc/gdm/custom.conf ]]; then
			if [[ -f /etc/gdm/custom.conf.rtd-bak ]]; then
				write_status "******* GDM auto login is enabled: toggeling off... ********"
				rm /etc/gdm/custom.conf && mv /etc/gdm/custom.conf.rtd-bak /etc/gdm/custom.conf
			else
				write_status "******* GDM auto login is disabled: toggeling on... ********"
				cp /etc/gdm/custom.conf /etc/gdm/custom.conf.rtd-bak
				cat >  /etc/gdm/custom.conf <<-OEM_GDM_LOGIN_OPTION
				# This configuration file was created by RTD Setup.
				# You may safely replace this file with the original backed up:
				# /etc/gdm/custom.conf.rtd-bak
				# If this file is not there, then it was not there to begin with
				# and you can delete this file.
				# GDM configuration storage

				[daemon]
				WaylandEnable=false
				AutomaticLoginEnable=True
				AutomaticLogin=${SUDO_USER:-"tangarora"}

				[security]

				[xdmcp]

				[chooser]

				[debug]
				OEM_GDM_LOGIN_OPTION
			fi
		fi
	fi

	# Special case for SUSE...
	if [[ -e /etc/sysconfig/displaymanager ]] ; then
		if [[ -e /etc/sysconfig/displaymanager.rtd-bak ]]; then
			write_status "****** SUSE auto login is enabled: toggeling off... ********"
			rm /etc/sysconfig/displaymanager && mv /etc/sysconfig/displaymanager.rtd-bak /etc/sysconfig/displaymanager
		else
			write_status "****** SUSE auto login is disabled: toggeling on... ********"
			cp /etc/sysconfig/displaymanager /etc/sysconfig/displaymanager.rtd-bak || write_error "Could not backup: /etc/sysconfig/displaymanager! "
			sed -i 's/DISPLAYMANAGER_AUTOLOGIN=""/DISPLAYMANAGER_AUTOLOGIN="tangarora"/' /etc/sysconfig/displaymanager || write_error "Could not write to file: /etc/sysconfig/displaymanager!"
			#sed -i 's/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="no"/DISPLAYMANAGER_PASSWORD_LESS_LOGIN="yes"/' /etc/sysconfig/displaymanager || write_error "Could not write to file: /etc/sysconfig/displaymanager!"
		fi
	fi

	# Toggle auto login for Terminal target env. (no GUI).
	if [ ! -f /etc/systemd/system/getty@tty1.service.d/override.conf ]; then
		write_status "******* TTY auto login is disabled: toggeling on... ********"
		mkdir -p /etc/systemd/system/getty@tty1.service.d
		cat >  /etc/systemd/system/getty@tty1.service.d/override.conf <<-OEM_TTY_LOGIN_OPTION
		"[Service]"
		"ExecStart="
		"ExecStart=-/sbin/agetty --noissue --autologin ${SUDO_USER:-"tangarora"} %I $TERM"
		"Type=idle"
		OEM_TTY_LOGIN_OPTION
	else
		write_status "******* TTY auto login is enabled: toggeling off... ********"
		rm /etc/systemd/system/getty@tty1.service.d/override.conf
	fi
}









set_oem_elevated_privilege_gui ()
{
# Description: Some Debian and other Linux distribution do not allow gui apps to
# be run when invoked by "sudo" or in a root (system elevated authority)
# environment. To mitigate this some stemp may need to taken.
# Will work on Slackware as well as Debian to give root permission to open X programs.
#
# Globals: $_OEM_USER
# Arguments: None
# Outputs: configures local X environment to allow root to show GUI apps
# Returns:
# Usage: set_oem_elevated_privilege_gui
# End of documentation

	write_information "Editing bashrc: xhost local:root IN /home/${_OEM_USER}/.bashrc"
	touch /home/${_OEM_USER}/.bashrc
	echo "xhost local:root" >> /home/${_OEM_USER:-"tangarora"}/.bashrc

	# Allows runing an X program as root
	write_information "Editing bashrc: XAUTHORITY=/home/${_OEM_USER}/.Xauthority IN /root/.bashrc"
	touch /root/.bashrc
	echo "export XAUTHORITY=/home/${_OEM_USER:-"tangarora"}/.Xauthority" >>/root/.bashrc
}






set_enable_oem_elevated_privelege()
{
# Description: Set no password elevated priviledges.
# This will allow apps to be run when invoked by "sudo" without being prompted
# for a password. This emulates the "UAC" from Microsoft. Please remember to
# turn this off using the function "rtd_oem_reset_default_environment_config"
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	: ${_OEM_USER:="${SUDO_USER}"}
	write_information "Adding instruction to a sudoers include file: ${_OEM_USER} ALL=(ALL) NOPASSWD:ALL"
	# This should be removed when OEM setup is complete as it would represent a back door...
	echo "${_OEM_USER} ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/99_sudo_include_file

	# Check that your sudoers include file passed the visudo syntax checks:
	sudo visudo -cf /etc/sudoers.d/99_sudo_include_file
}






make_system_recovery_partition ()
{
# Description: Incomplete function to build an OEM rescue partition...
# Function to enable system OEM Recovery
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: NOTE: I have yet to figura out how to do this!

# End of documentation

	devlist="$(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep 1 | cut -f1 -d' ')"

	if [[ -z ${devlist} ]]; then
		DIALOGRC="/root/.dialogrc"
		if -e ${DIALOGRC} ; then
			mv ${DIALOGRC} ${DIALOGRC}.bak
		fi
		echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
		dialog --title "Physical Installation Media Creator Error!" --backtitle "OS Media Manger" --msgbox "No removable media could be found!"  14 90
		rm ${DIALOGRC}
		if -e ${DIALOGRC}.bak ; then
			mv ${DIALOGRC}.bak ${DIALOGRC}
		fi
		return 1
	else
		declare -A RemovableMediaList
		key=0
		for i in $(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep 1 | cut -f1 -d' ');
		do
			SuggestedRemovableDevice="${i}"
			element="$(fdisk -l /dev/$i |head -1)"
			RemovableMediaList[$key]=$(echo -e \'"$element"\')
			(( key++ ))
		done

		if [[ 1 -eq ${#RemovableMediaList[@]} ]]; then
			mkdir /boot/iso
			dd if=/dev/${SuggestedRemovableDevice} of=/boot/iso/recovery.iso
			cat >> /etc/grub.d/40_custom <<-'EOF'
			menuentry "Reset to Factory Defaults" {
				set isofile="/boot/iso/recovery.iso"
				loopback loop (hd0,8)$isofile
				linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile noprompt noeject
				initrd (loop)/casper/initrd.lz
			}
			EOF
		else

			ChosenMediaItem="
			Removable media found: \n
			------------------------------------------------------------------------------- \n
			\n
			$(until [ $i -gt ${#RemovableMediaList[@]} ]
			do
				echo -e "Removable Disk $i:   ${RemovableMediaList[$i]}" \n
				((i=i+1))
			done
			)"

			USBTargetDevice=$( dialog --stdout --title "Physical Installation Media Creator" \
			--backtitle "OS Media Manger" \
			--inputbox "\n ${DiscoveredItems}" 0 0 /dev/${SuggestedRemovableDevice} )

			mkdir /boot/iso
			dd if=/dev/${ChosenMediaItem} of=/boot/iso/recovery.iso
			cat >> /etc/grub.d/40_custom <<-'EOF'
			menuentry "Reset to Factory Defaults" {
				set isofile="/boot/iso/recovery.iso"
				loopback loop (hd0,8)$isofile
				linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=$isofile noprompt noeject
				initrd (loop)/casper/initrd.lz
			}
			EOF
		fi
	fi
}







rtd_oem_reseal () {
# Description:
# Function to reseal a newly installed system for delivery to end user.
# Globals: The distribution must have an OEM reseal function or software available.
# Arguments: None
# Outputs:
# Returns:
# Usage:

# End of documentation
	if cat /etc/os-release |grep ubuntu ; then
		InstallSoftwareFromRepo oem-config-gtk
		oem-config-prepare
		shutdown -h now
	elif cat /etc/os-release |grep kubuntu ; then
		InstallSoftwareFromRepo oem-config-kde
		oem-config-prepare
		shutdown -h now
	elif cat /etc/os-release |grep suse ; then
		echo "I dont know of any OEM configuration for SuSE"
	elif cat /etc/os-release |grep fedora ; then
		echo "I dont know of any OEM configuration for Fedora"
	fi
}








check_if_password_p0wned () {
# Description: Function to query a user for a password suggestion and check it against P0wned data base online.
# Globals: $RTD_GUI
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep "$(echo "${sha1:5:35}" | tr '[:lower:]' '[:upper:]')");
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}








rtd_oem_find_live_release()
{
# Description: This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
# 3 parameters are required for this function to know what to do: distro_version/
# It will also try to read the available iso images and grab the latest or requested iso.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env
# rtd_oem_find_live_release 	      10              debian         live           kde
# rtd_oem_find_live_release 	      10              debian         live           cinnamon
# rtd_oem_find_live_release 	      10              debian         net            ssh-server
# rtd_oem_find_live_release 	      19.04.2         ubuntu         live
# End of documentation
	distro_version="${1:-10}"
	distro_flavor="${2:-debian}"
	live_or_not="${3:-live}"
	desktop_env="${4:-standard}"

	case "$distro_flavor" in
	Ubuntu | ubuntu )
		case "$live_or_not" in
		Live | live | current-live | desktop)
			echo "http://releases.ubuntu.com/$distro_version/$(curl --silent http://releases.ubuntu.com/$distro_version/SHA256SUMS | \grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | netinst | net | mini )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			if [ ${1:0:2} -ge 18 ]; then
				echo "http://cdimage.ubuntu.com/releases/$distro_version/release/ubuntu-$distro_version-live-server-arm64.iso"
			else
				rel=http://releases.ubuntu.com/$1
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')"
			fi
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
	;;
	esac
}






cleanup_and_finish ()
{
# Description: Function to remove all temporary file locations left over from building
# the new netinstall ISO etc. and clean  up some variables...
# go back to initial directory
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	cd "$CURRENT_DIR" && echo "returned to $CURRENT_DIR" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$TMP_DOWNLOAD_DIR"
	rm -r "$TMP_DISC_DIR"
	rm -r "$TMP_INITRD_DIR"
	rm -r "$SCRIPT_DIR/custom"

	if [[  "$1" != "nomessage" ]]; then
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else
		echo "Cleanup..."
	fi

	unset BIN_7Z
	unset BIN_XORRISO
	unset BIN_CPIO
	unset ISOHDPFX_BIN
	unset VOLUME_TITLE
	unset TARGET_ISO_FILE_NAME
	unset SOURCE_ISO_URL
	unset SSH_PUBLIC_KEY_FILE
	unset PRESEED_TEMPLATE
	unset CONFIG
	unset PRESEED_FILE
	unset SRVorVDI
	clear
	return
}




generate_report_disk_space_used_by_directory ()
{
# Description: Function to generate a report for folders' disk space use.
# This function requres one argument; what root folder to analyse the directories in.
# This functio will return a report contained in the variable $return that may then be used.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# generate_report_disk_space_used_by_directory /home
#
# This will generate a report on the disk space per directory in the /home folder.
#
# End of documentation

	DIRS=$( ls $1 )
	store=/$tmp/out.ct
	$RTD_GUI --backtitle "$BRANDING" --title "Generating report for: $1" --gauge "Calculating disk space: this may take some time" $HEIGHT $WIDTH < <(
		echo "Storage Utilization Report:" >>$store
		echo "______________________________" >>$store
		n=$(ls $1 | wc -l )
		i=0
		for f in $DIRS
		do
			du -cksh $1/$f 2>/dev/null | grep -v total >>$store
			PCT=$(( 100*(++i)/n ))
			cat <<-EOF
			XXX
			$PCT
			Completed calculation for: "$f"...
			XXX
			EOF
			sleep 1
		done
	)
	total=$(echo ----- >>$store && du -cksh $1 2>/dev/null |grep total >>$store) | $RTD_GUI --backtitle "$BRANDING" --title "Completing report..." --progressbox "Working..." $HEIGHT $WIDTH
	result="$(cat $store )" ; rm $store
}






make_preseed_cfg ()
{
# Description: Function to write out a debina preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# functoin_name          location        config          function
# make_preseed_cfg       /path/to/file   ssh-server      Minecraft
# End of documentation

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=${3:-Tasks}
	PRESEED=preseed.cfg
	PRESEED_FILE="$SAVETO/$PRESEED"
	TASK_FILE="$SAVETO/task.sh"
	echo "$PRESEED_FILE"

	touch "$SAVETO/$PRESEED"

	rtd_oem_preseed_cfg_Unattended_Install "$SAVETO"
	rtd_oem_preseed_cfg_Network_Configuration "$SAVETO"
	rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO"
	rtd_oem_cfg_Account_Setup "$SAVETO"
	rtd_oem_preseed_cfg_Localization "$SAVETO"
	rtd_oem_preseed_cfg_EFI "$SAVETO"
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO"
	rtd_oem_preseed_cfg_Disk_Layout "$SAVETO"
	rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG"
	rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO"
	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO"
}










set_gnome_ui_common_tweaks_for_user ()
{
# Description:
# Configure Gnome for OEM look and feel. This is completely as desired.
# This function takes no arguments. Simply call it to make the changes.
# Howerver, this function must be called as the user it should apply to.
# if it is called in a script with "sudo" priviledges, it will make chages to
# the look and feel for the "root" user.
#
# To run this function as the user who started a script with sudo script content
# could be echoed out ot a temporary file and executed as follows
# sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus temporary_script.sh > /dev/null 2>&1
# or alternatively by calling the function "run_command_in_gnome_user_session /path/to/temorary_script.sh".
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# USAGE:
#
# set_gnome_ui_common_tweaks_for_user
#
# End of documentation

	write_status "Seting common OEM tweaks..."
	# Terminal and Tilix Dark Theme
		GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
		# gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'dark'
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency false
		gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000

	# Better Font Smoothing
		gsettings set org.gnome.settings-daemon.plugins.xsettings antialiasing 'rgba'

	# Usability Improvements
		gsettings set org.gnome.desktop.peripherals.mouse accel-profile 'adaptive'
		gsettings set org.gnome.desktop.sound allow-volume-above-100-percent true
		gsettings set org.gnome.desktop.calendar show-weekdate true
		gsettings set org.gnome.desktop.wm.preferences resize-with-right-button true
		gsettings set org.gnome.desktop.wm.preferences button-layout 'appmenu:minimize,maximize,close'
		gsettings set org.gnome.shell.overrides workspaces-only-on-primary false

	# This indexer is nice, but can be detrimental for laptop users battery life
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery false
		gsettings set org.freedesktop.Tracker.Miner.Files index-on-battery-first-time false
		gsettings set org.freedesktop.Tracker.Miner.Files throttle 15

	# Configure Dash to Dock
		gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize'
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM'
		gsettings set org.gnome.shell.extensions.dash-to-dock apply-custom-theme false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-background-color false
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots true
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots-color '#729fcf'
		gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink true
		gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true
		gsettings set org.gnome.shell.extensions.dash-to-dock force-straight-corner false
		gsettings set org.gnome.shell.extensions.dash-to-dock icon-size-fixed true
		gsettings set org.gnome.shell.extensions.dash-to-dock intellihide-mode 'ALL_WINDOWS'
		gsettings set org.gnome.shell.extensions.dash-to-dock isolate-workspaces true
		gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true
		gsettings set org.gnome.shell.extensions.dash-to-dock unity-backlit-items false
		gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode 'FIXED'
		gsettings set org.gnome.shell.extensions.dash-to-dock running-indicator-style 'SEGMENTED'
		gsettings set org.gnome.shell.extensions.dash-to-dock background-opacity 0.70000000000000000
		gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false

	# Configure dash-to-panel
		temporary_script=$(mktemp)
		chmod 777 ${temporary_script}
		cat > ${temporary_script} <<-'EOF_D2P'
		[org/gnome/shell/extensions/dash-to-panel]
		appicon-margin=4
		appicon-padding=4
		available-monitors=[0]
		dot-color-1='#5294e2'
		dot-color-2='#5294e2'
		dot-color-3='#5294e2'
		dot-color-4='#5294e2'
		dot-color-dominant=false
		dot-color-override=true
		dot-color-unfocused-1='#5294e2'
		dot-color-unfocused-2='#5294e2'
		dot-color-unfocused-3='#5294e2'
		dot-color-unfocused-4='#5294e2'
		dot-color-unfocused-different=false
		dot-style-focused='METRO'
		dot-style-unfocused='SEGMENTED'
		focus-highlight-color='#eeeeee'
		focus-highlight-dominant=true
		force-check-update=true
		group-apps=true
		hotkeys-overlay-combo='TEMPORARILY'
		isolate-monitors=false
		isolate-workspaces=false
		panel-element-positions='{"0":[{"element":"showAppsButton","visible":true,"position":"stackedTL"},{"element":"activitiesButton","visible":false,"position":"stackedTL"},{"element":"leftBox","visible":true,"position":"stackedTL"},{"element":"taskbar","visible":true,"position":"stackedTL"},{"element":"centerBox","visible":true,"position":"stackedBR"},{"element":"rightBox","visible":true,"position":"stackedBR"},{"element":"dateMenu","visible":true,"position":"stackedBR"},{"element":"systemMenu","visible":true,"position":"stackedBR"},{"element":"desktopButton","visible":false,"position":"stackedBR"}]}'
		secondarymenu-contains-showdetails=true
		show-appmenu=false
		show-favorites=true
		show-favorites-all-monitors=false
		stockgs-keep-dash=false
		stockgs-keep-top-panel=false
		trans-use-custom-bg=false
		trans-use-custom-opacity=true
		tray-size=0
		EOF_D2P
		dconf load / < ${temporary_script} && rm ${temporary_script}

	# Nautilus (File Manager) Usability
		gsettings set org.gnome.nautilus.icon-view default-zoom-level 'standard'
		gsettings set org.gnome.nautilus.preferences executable-text-activation 'ask'
		gsettings set org.gtk.Settings.FileChooser sort-directories-first true
		gsettings set org.gnome.nautilus.list-view use-tree-view true
		gsettings set org.gnome.nautilus.list-view default-zoom-level 'small'

	# Set the GNOME Shell Apps Dashboard sort app in categories based on the FreeDesktop standard.
		# Set the GNOME Shell Apps Dashboard sort app in categories based on the FreeDesktop standard.
		gsettings set org.gnome.desktop.app-folders folder-children "['accessories', 'chrome-apps', 'games', 'graphics', 'internet', 'office', 'programming', 'science', 'sound---video', 'system-tools', 'universal-access', 'wine', 'OEM', '3D-Printing', 'Cloud']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ name "Accessories"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ categories "['Utility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ name "Chrome Apps"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ categories "['chrome-apps']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ name "Games"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ categories "['Game']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ name "Graphics"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ categories "['Graphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ name "Internet"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ categories "['Network', 'WebBrowser', 'Email']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ name "Office"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ categories "['Office']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ name "Programming"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ categories "['Development']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ name "Science"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ categories "['Science']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ name "Sound & Video"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ categories "['AudioVideo', 'Audio', 'Video']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ name "System Tools"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ categories "['System', 'Settings']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ name "Universal Access"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ categories "['Accessibility']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ name "Wine"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ categories "['Wine', 'X-Wine', 'Wine-Programs-Accessories']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ name "OEM"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ categories "['OEM']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ name "3D-Printing"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ categories "['3D-Printing', 'CAD', '3D', '3DGraphics']"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ name "Cloud"
		gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ categories "['Cloud-Management', 'Cloud', 'aws', 'azure', 'gcp']"

	# Add Tilix configuration and shell definitions
		mkdir -p ~/.config/rtd
		cat > ~/.config/rtd/gconf-tilix-settings.ini <<-'EOF_TLX'
		[com/gexperts/Tilix]
		quake-specific-monitor=0
		quake-width-percent=90
		terminal-title-style='small'
		theme-variant='dark'
		warn-vte-config-issue=false

		[com/gexperts/Tilix/profiles]
		list=['2b7c4080-0ddd-46c5-8f23-563fd3ba789d', 'd6401d4b-4b26-42ec-918a-2e7dc977118d', '8000e9d6-6f21-4a4e-a122-ac45607b56f5', '5283b4cf-faa5-4aef-afcd-a29fd5e0335a', '75b21a4c-150c-4f7a-a093-9faaa19626e2', '1824e1f9-3b7e-48d2-b06a-709239d1d6d9']

		[com/gexperts/Tilix/profiles/1824e1f9-3b7e-48d2-b06a-709239d1d6d9]
		background-color='#272822'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#F8F8F2'
		highlight-colors-set=false
		palette=['#272822', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F8F8F2', '#75715E', '#F92672', '#A6E22E', '#F4BF75', '#66D9EF', '#AE81FF', '#A1EFE4', '#F9F8F5']
		use-theme-colors=false
		visible-name='Monokai'

		[com/gexperts/Tilix/profiles/2b7c4080-0ddd-46c5-8f23-563fd3ba789d]
		background-color='#000000000000'
		background-transparency-percent=10
		badge-color='#AC7EA8'
		badge-color-set=true
		bold-color-set=false
		cursor-colors-set=false
		default-size-columns=180
		default-size-rows=40
		dim-transparency-percent=0
		font='Ubuntu Mono 10'
		foreground-color='#EFEFEF'
		highlight-colors-set=false
		palette=['#000000', '#AA0000', '#00AA00', '#AA5400', '#0000AA', '#AA00AA', '#00AAAA', '#AAAAAA', '#545454', '#FF5454', '#54FF54', '#FFFF54', '#5454FF', '#FF54FF', '#54FFFF', '#FFFFFF']
		terminal-title='${id}: ${title}${process}'
		use-system-font=false
		use-theme-colors=false
		visible-name='Linux'

		[com/gexperts/Tilix/profiles/5283b4cf-faa5-4aef-afcd-a29fd5e0335a]
		background-color='#FDF6E3'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#657B83'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Sun Microsystems'

		[com/gexperts/Tilix/profiles/75b21a4c-150c-4f7a-a093-9faaa19626e2]
		background-color='#002B36'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#839496'
		highlight-colors-set=false
		palette=['#073642', '#DC322F', '#859900', '#B58900', '#268BD2', '#D33682', '#2AA198', '#EEE8D5', '#002B36', '#CB4B16', '#586E75', '#657B83', '#839496', '#6C71C4', '#93A1A1', '#FDF6E3']
		use-theme-colors=false
		visible-name='Solarized'

		[com/gexperts/Tilix/profiles/8000e9d6-6f21-4a4e-a122-ac45607b56f5]
		background-color='#1E1E1E'
		badge-color-set=false
		bold-color-set=false
		cursor-colors-set=false
		foreground-color='#A7A7A7'
		highlight-colors-set=false
		palette=['#1E1E1E', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#A7A7A7', '#5F5A60', '#CF6A4C', '#8F9D6A', '#F9EE98', '#7587A6', '#9B859D', '#AFC4DB', '#FFFFFF']
		use-theme-colors=false
		visible-name='Twilight'

		[com/gexperts/Tilix/profiles/d6401d4b-4b26-42ec-918a-2e7dc977118d]
		palette=['#000000', '#CC0000', '#4D9A05', '#C3A000', '#3464A3', '#754F7B', '#05979A', '#D3D6CF', '#545652', '#EF2828', '#89E234', '#FBE84F', '#729ECF', '#AC7EA8', '#34E2E2', '#EDEDEB']
		use-theme-colors=true
		visible-name='Tango'
		EOF_TLX
		dconf load / < ~/.config/rtd/gconf-tilix-settings.ini
}








set_gnome_ui_tweak_no_media_error ()
{
# Description:  Function to handle missing media when attempting to set UI look to
# 		resemble MAC/Windows/etc. for users accustomed to that.
#
# Usage:
# set_gnome_ui_tweak_no_media_error
# OEM_Hint="My custom mesage" ; set_gnome_ui_tweak_no_media_error
#
# Globals: ${OEM_Hint}
# Arguments: none
# Outputs:
# Returns: Standard err for last task
# End of documentation
	: ${OEM_Hint:="There was a problem with finding themes, launch the Bundle Installer Tool?"}

	zenity --question --text "${OEM_Hint}" --width=600
	case "$?" in
		0 ) pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY ${_CORE_DIR}/rtd-oem-linux-config.sh ;;
		1 ) return ;;
		* ) write_error "unknown response received!" ; return 1 ;;
	esac
}







set_gnome_ui_mac_tweaks_for_user ()
{
# Description: Function to set UI look to resemble MAC for users accustomed to that.
#
# Usage:
# set_gnome_ui_mac_tweaks_for_user Dark
# set_gnome_ui_mac_tweaks_for_user Light
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# End of documentation

	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting MAC like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Mojave-dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Mojave-dark'
			gsettings set org.gnome.desktop.interface icon-theme 'McMojave-circle-dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Mojave-dark"

			gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/MojaveNight.jpg

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'dark'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Mojave-light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Mojave-light'
			gsettings set org.gnome.desktop.interface icon-theme 'McMojave-circle'
			gsettings set org.gnome.shell.extensions.user-theme name "Mojave-light"

			gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/MojaveDay.jpg

			#gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ theme-variant 'light'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'
	gsettings set org.gnome.desktop.wm.preferences button-layout 'close,maximize,minimize:appmenu'
	# Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'desktop-icons@csoriano', \
	'ubuntu-appindicators@ubuntu.com', \
	'CoverflowAltTab@palatis.blogspot.com']"


	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 100
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-transparency true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ scrollback-lines 10000

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}






set_gnome_ui_win10_tweaks_for_user ()
{
# Description: Function to set UI look to resemble Windows 10 for users accustomed to that.
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_win10_tweaks_for_user Dark
# set_gnome_ui_win10_tweaks_for_user Light
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Windows like tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Windows-10-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Dark"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Windows-10-Light ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Windows-10-Light'
			gsettings set org.gnome.shell.extensions.user-theme name "Windows-10-Light"
			gsettings set org.gnome.desktop.interface icon-theme 'Windows-10-Icons'
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background 'false'

	# Set wallpaper
	gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/Redmond.png

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}






set_gnome_ui_corprate_crisp_tweaks_for_user ()
{
# Description: Function to set UI look to appeal to teh corporate or business user.
#
# Globals:
# Arguments: Dark/Light
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_corprate_crisp_tweaks_for_user Dark
# set_gnome_ui_corprate_crisp_tweaks_for_user Light
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Crisp like tweaks..."

	GNOME_TERMINAL_PROFILE="$(gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}')"

	UiTone=${1:-"Light"}

	# Gnome Shell Theming
	case ${UiTone} in
	Dark | dark )
		if [[ -d /usr/share/themes/Arc-Dark ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc-Dark'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc-Dark"
			gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/RTD_Wallpapers_HQ_Public_Domain_019.jpg
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	Light| light )
		if [[ -d /usr/share/themes/Arc ]] ; then
			gsettings set org.gnome.desktop.interface gtk-theme 'Arc'
			gsettings set org.gnome.shell.extensions.user-theme name "Arc"
			gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/RTD_Wallpapers_HQ_Public_Domain_020.jpg
		else
			set_gnome_ui_tweak_no_media_error
		fi
	;;
	esac

	if [[ -d /usr/share/icons/Arc-icon-theme ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Arc-icon-theme'
	else
			set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-panel@jderose9.github.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock extend-height 'true'
	gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}









set_gnome_ui_moca_tweaks_for_user ()
{
# Description: Function to set UI look to be friendly on the eyes, limiting eye strain.
#
# Globals:
# Arguments: none
# Outputs:
# Returns: Standard err for last task
# Usage:
# set_gnome_ui_moca_tweaks_for_user
#
# End of documentation
	GIT_Profile=${GIT_Profile:-vonschutter}
	# Save users keyboard preferences:
	# KeyboardLanguage=$(gsettings get org.gnome.desktop.input-sources sources )

	# Apply common settings:
	set_gnome_ui_common_tweaks_for_user
	write_status "Setting Eye strain saving tweaks..."

	GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`

	if [[ -d /usr/share/themes/vimix-dark-laptop ]] ; then
		gsettings set org.gnome.desktop.interface gtk-theme 'vimix-dark-laptop'
		gsettings set org.gnome.shell.extensions.user-theme name "vimix-dark-laptop"
		# Set wallpaper
		gsettings set org.gnome.desktop.background picture-uri file://${_WALLPAPER_DIR}/Ubuntu-ThrowingStones.jpg
	else
		set_gnome_ui_tweak_no_media_error
	fi

	if [[ -d /usr/share/icons/Flatery-Black-Dark ]] ; then
		gsettings set org.gnome.desktop.interface icon-theme 'Flatery-Black-Dark'
	else
		set_gnome_ui_tweak_no_media_error
	fi

	# Set font
	# gsettings set org.gnome.desktop.interface monospace-font-name 'Bitstream Vera Sans Mono'

	#Set Extensions for gnome
	gsettings set org.gnome.shell disable-user-extensions false
	gsettings set org.gnome.shell enabled-extensions "[\
	'user-theme@gnome-shell-extensions.gcampax.github.com', \
	'caffeine@patapon.info', \
	'TopIcons@phocean.net', \
	'dash-to-dock@micxgx.gmail.com', \
	'ubuntu-appindicators@ubuntu.com', \
	'apps-menu@gnome-shell-extensions.gcampax.github.com']"

	# Configure dash-to-panel
	gsettings set org.gnome.shell.extensions.dash-to-panel trans-use-custom-opacity 'true'

	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 10'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ audible-bell false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-theme-colors false
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-color '#000000'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ foreground-color '#AFAFAF'
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-transparent-background true
	gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ background-transparency-percent 20

	# Restore Keyboard Layout (reset by gnome)
	# gsettings set org.gnome.desktop.input-sources sources "${KeyboardLanguage}"
	busctl --quiet --user call org.gnome.Shell /org/gnome/Shell org.gnome.Shell Eval s 'Meta.restart("Reloadig Gnome with the new settings...")' & return
}










rtd_oem_register_wallpapers_for_gnome ()
{
# Description: Function to simplify registering wallpapers for Gnome.
#
# Globals:
# Arguments: /path/to/folder/with/wallpapers
# Outputs:
# Returns:
# Usage:
# rtd_oem_install_wallpapers_for_gnome /path/to/folder/with/wallpapers
#
# End of documentation

	WallPaperDir="$1"

	# Make a header:
	echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
	<!DOCTYPE wallpapers SYSTEM \"gnome-wp-list.dtd\">
	<wallpapers>" > oem-backgrounds.xml

	# Registering all pictures in $WallPaperDir:
	for i in ${_WALLPAPER_DIR}/*.jpg ${_WALLPAPER_DIR}/*.png; do
	echo "<wallpaper>
	<name>$i</name>
	<filename>$i</filename>
	<options>stretched</options>
	<pcolor>#8f4a1c</pcolor>
	<scolor>#8f4a1c</scolor>
	<shade_type>solid</shade_type>
	</wallpaper>" >> oem-backgrounds.xml
	done

	# creating the footer:
	echo "</wallpapers>" >> oem-backgrounds.xml

	# Register all files:
	mkdir -p /usr/local/share/gnome-background-properties
	sed 's/<name>\/usr\/share\/backgrounds\//<name>/g' oem-backgrounds.xml > /usr/local/share/gnome-background-properties/oem-backgrounds.xml
	rm oem-backgrounds.xml
}








rtd_oem_turn_on_gui_network_management ()
{
# Description: Function to set NetworkManager by default to manage networking.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# The function expects no arguments.
# Usage:
# rtd_oem_turn_on_gui_network_management
#
# End of documentation

	if ls /usr/bin/*session ; then
		# backup any existing network yaml definitions:
		mkdir -p /etc/netplan/bak && mv /etc/netplan/*.yaml /etc/netplan/bak/

		# Create a new netplan for all interfaces:
		# Be careful with white spaces in yaml files!!!
		cat > /etc/netplan/01-network-manager-all.yaml <<- 'EOF'
		# Let NetworkManager manage all devices on this system
		network:
		  version: 2
		  renderer: NetworkManager

		EOF

		# Enable network manager:
		systemctl disable systemd-networkd
		systemctl enable  NetworkManager
		systemctl start  NetworkManager
		systemctl stop systemd-networkd
		systemctl restart  NetworkManager
	else
		write_error "No graphical session appear to be availabl ein this system! Skipping netconfig..."
	fi
}






add_gnome3_favorite_app ()
{
# Description: Function to add a new favorite app to the gnome favorites bar.
# Globals: none
# Arguments: name of the shortcut to create (appname.desktop)
# Outputs:
# Returns: 0/1
# Usage: add_gnome3_favorite_app [appname.desktop]
#
# NOTE: This function must be run in the user context.
# End of documentation
# A potentioal simplification if the escapes cn be figured out:
# sudo -iu $SUDO_USER /bin/bash -c \" "gsettings set org.gnome.shell favorite-apps \\\"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\\$//), '${Newapp}']\\\"" \"
	NewApp="$1"
	if TMP_FIL=$(mktemp -p "$(mktemp -d )") ; then
		chown -R $SUDO_USER ${TMP_FIL%/*}
		sudo -iu  $SUDO_USER  echo "gsettings set org.gnome.shell favorite-apps \"\$(gsettings get org.gnome.shell favorite-apps | sed s/.\$//), '${NewApp}']\"" >${TMP_FIL}
		sudo -H -u $SUDO_USER DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus /bin/bash ${TMP_FIL}
		rm ${TMP_FIL}
	else
		return 1
	fi
}







run_command_in_gnome_user_session () {
# Description: Function to do a reverse sudo back to teh original Gnome user who called upon sudo.
# This functon expects any number of parameters that would make up the command or commands
# to be run in the users session. For example:
# 	run_command_in_gnome_user_session script_name.sh parameter one two etc
#
# Globals:
# Arguments: [path/script.sh] [bash command]
# Outputs:
# Returns:
# Usage: run_command_in_gnome_user_session script_name.sh
#
# End of documentation
	echo -------------------------- Begin as user: $SUDO_USER ---------------------
	echo "$*"
	sudo -H -u $SUDO_USER DISPLAY=$DISPLAY DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u "$SUDO_USER")/bus $*
	echo " "
	echo -------------------------- End as user: $SUDO_USER   ---------------------
}





ensure_admin ()
{
# Description: Function to elevate priviledges of script execution and to ensure administrative privileges
# such that system wide settings or configuration may be done.
#
# This function evaluates and uses multiple ways to elevate priviledges based on the environment. In an
# X session; and normal GUI w. systemd: elevate privs with normal GUI policy kit, otherwise try dialog
# menu system and cached sudo, and finally fall back on good old sudo. Since scripts may be launched with
# a GUI front (for user interaction) end and NO terminal; it is really preferable to display a proper
# priviledge escalation propt in a GUI format and only use sudo in cases where there is a terminal or
# no other option is present.
#
# Should the function not discover an X session, then dialog will be preferred over regular sudo.
#
# Globals: $UID
# Arguments: None
# Outputs: GUI
# Dependencies: soft dependency on "dialog", will fall back on CLI if dialog is absent.
# Returns: relaunches script under sudo.
# Usage: The function expects no arguments, but will prompt for system password if required.
# Usage: ensure_admin
#
# End of documentation

	if [ ! "$UID" -eq 0 ]; then
		if xset q &>/dev/null; then
			# If X is running in this session then...
			if echo $(systemctl get-default ) |grep graphical &>/dev/null ; then
				# If we are a normal GUI w. systemd: elevate privs with normal GUI policy kit...
				write_information "Allowing root to display menus..."
				xhost local:root
				write_information "Authenticating..."
				pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY SUDO_USER=$USER ${0}
				exit
			else
				# If we are some other kind of archane GUI then...
				write_information "Allowing root to display menus..."
				xhost local:root
				write_information "Checking for dialog..."
				if hash dialog 2>/dev/null ; then
					token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
					ret=$? ; clear
					case $ret in
						0)
							export HISTIGNORE='*sudo -S*'
							echo ${token} | sudo -S -v || ensure_admin
							sudo DISPLAY=$DISPLAY SUDO_USER=$USER /bin/bash ${0} $@ || rtd_oem_pause 1
						;;
						1) echo "Request cancelled" ;;
						255) echo "[esc] Request aborted" ;;
						* )  exit 1
					esac
					exit
				else
					# If we have some kind of X but not even "dialog" then...
					write_information "Dialog not found..."
					write_warning "This script needs administrative access..."
					xhost local:root
					sudo DISPLAY=$DISPLAY SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
					exit
				fi
			fi
		else
			# If there is no X in this session...
			write_information "No X server at \$DISPLAY [$DISPLAY]"
			# Use dialog if possible, otherwise just terminal...
			if hash dialog 2>/dev/null ; then
				token=$(dialog --title "${Title:-"sudo"}" --backtitle "${BackTitle:-"$( basename $0 )"}" --insecure --stdout --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90)
				ret=$? ; clear
				case $ret in
					0)
						export HISTIGNORE='*sudo -S*'
						echo ${token} | sudo -S -v || ensure_admin
						sudo DISPLAY=$DISPLAY SUDO_USER=$USER /bin/bash ${0} $@ || rtd_oem_pause 1
					;;
					1) echo "Request cancelled" ;;
					255) echo "[esc] Request aborted" ;;
					* )  exit 1
				esac
				exit
			else
				write_warning "This script needs administrative access..."
				sudo DISPLAY=$DISPLAY SUDO_USER=$USER bash "${0}" "$@" || rtd_oem_pause 1
				exit
			fi
		fi
	else
		if [[ ! -e /etc/pam.d/sudo ]] ; then
			touch /etc/pam.d/sudo
			echo 'session  optional       pam_xauth.so' > /etc/pam.d/sudo
		else
			sed -i s/'# session  optional       pam_xauth.so'/'session  optional       pam_xauth.so'/g /etc/pam.d/sudo
		fi
	fi
}






rtd_oem_check_inet_access ()
{
# Description: Function to verrify internet availabiltiy.
# The funciton will pause for 10 seconds by default, and will accept
# an integer to indicate a non-decault time to pause.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_check_inet_access [ integer ]
#
# Example:
# rtd_oem_check_inet_access 60
#
# If an argument is omitted rtd_oem_check_inet_access will wait indefinitley
# for input.
#
# End of documentation
	_ARG=$1
	if ! hash curl &>/dev/null; then
		read -t 10 -p "N O T I C E ! --
		Could not check for internet connectivity...
		Please install (curl) web crawler/downloader.
		Press [ENTER] to continue and [CTRL] + [C] to exit! Continuing in 10 seconds..."
	else
		if [[ -z "$_ARG" ]]; then
			curl ipinfo.io &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
		else
			curl ipinfo.io &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
		fi
	fi
}






rtd_oem_kde_set_wallpaper ()
{
# Description:
# Function to set KDE Plasma wallpaper from a script. this function expects one variable
# indication what file to set as background. You must provide the full path to the file.
# rtd_oem_kde_set_wallpaper /opt/oem/wallpaper.png Supported fule types are:
# webm, mp4, png, jpeg, gif, webp.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	echo "Setting wallpaper $1"
	full_image_path=$(realpath "$1")
	ext=$(file -b --mime-type "$full_image_path")

	if [ -z "$2" ]; then
	# Identify filetype and make changes
	case $(echo $ext | cut -d'/' -f2) in
		"mp4"|"webm") type='VideoWallpaper' ; write='VideoWallpaperBackgroundVideo';;
		"png"|"jpeg"|"jpg") type='org.kde.image' ; write='Image' ;;
		"gif"|"webp") type='GifWallpaper' ; write="GifWallpaperBackgroundGif" ;;
	esac
	else
	type="$2";
	write="$3";
	fi

	wallpaper_set_script="var allDesktops = desktops();
	print (allDesktops);
	for (i=0;i<allDesktops.length;i++)
	{
		d = allDesktops[i];
		d.wallpaperPlugin = '${type}';
		d.currentConfigGroup = Array('Wallpaper', '${type}', 'General');
		d.writeConfig('Image', 'file:///dev/null')
		d.writeConfig('$write', 'file://${full_image_path}')
	}"

	qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "${wallpaper_set_script}"
	kwriteconfig5 --file kscreenlockerrc --group Greeter --group Wallpaper --group org.kde.image --group General --key Image "file://$full_image_path"
}








rtd_oem_setup_brand_splash_screen()
{
# Description: Function to brand the installer splash screen for the customized installer
# downloaded from a ginve vendor. This function expects a few simple peices of information:
# parameter 1: full path to image file to be branded.
# parameter 2: quoted text to be incerted.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_setup_brand_splash_screen [string] [string]
#
# [string]: /path/to/imagefile.png, "text to brand image with"
#
# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
#
# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif  [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR
	fi
}





prepare_environment_for_iso_creation ()
{
# Description: Function to check that all dependencies are available for manipulating the
# net install ISO from Ubuntu. Subsequently, the temporary file locations
# are setup and templates are downloaded.
#
# Several key software components are required to create ISO files (virtual DVD/CD/BlueRay)
# as well as a few others needed to download files from the internet, etc.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# DEPENDENCIES: dos2unix, cpio, gzip, genisoimage, whois, pwgen, wget, fakeroot, xorriso.
#
# This function will find full paths for the binaries needed since if they are recently
# added, they may not be found in the current $PATH.
#
#	Software PATH insurance:
#	: "${BIN_7Z:=$(type -P 7z)}"
#	: "${BIN_XORRISO:=$(type -P xorriso)}"
#	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
#	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
#	: "${BIN_KVM:=$(type -P kvm)}"
#	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
#	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
#	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
#	: "${VOLUME_TITLE:="RTD Auto Installer"}"
#	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
#	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"
#
# The main tool to create ISO files system is "xorriso".
# [xorriso] copies file objects from POSIX compliant filesystems into Rock Ridge
# enhanced ISO 9660 filesystems and allows session-wise manipulation of such filesystems.
# It can load the management information of existing ISO images and it writes the session results
# to optical media or to filesystem objects.
#
# At this time this function expects no arguments.
#
# End of Documentation


	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	set -e
	for i in $_DEPENDENCIES
	do
		check_dependencies $i
	done

	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

	if [[ -e /usr/lib/ISOLINUX/isohdpfx.bin ]]; then
		: "${ISOHDPFX_BIN:="/usr/lib/ISOLINUX/isohdpfx.bin"}"
	else
		write_warning "An important file (isohdpfx.bin) was not found in the expected location. Attepting to workaround the issue..."
		check_dependencies isolinux
		check_dependencies mlocate && ( write_warning "Updating file location DB, this may take a long time if there are a lot of files on the system..." ; updatedb )
		locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 )
		: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	fi

	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		echo "You will need to setup automatic login using ssh manually each time you build a server with this media."
		read -p "Press [Enter] to continue..."
	fi

	CURRENT_DIR="$(pwd)"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR=$(mktemp -d )
	TMP_DISC_DIR=$(mktemp -d )
	TMP_INITRD_DIR=$(mktemp -d )

	for i in $PUT_QCOW_FILE_HERE_WHEN_DONE\
		$PUT_ISO_FILE_HERE_WHEN_DONE\
		$PERMANENT_DOWNLOAD_DIR
	do
		mkdir -p "$i" && chown "$SUDO_USER":"$SUDO_USER" "$i"
	done
}








rtd_oem_ubuntu_auto_install_iso_builder()
{
# Description: Function to generate an edited ISO file from a folder.
# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# :: function name				:: target		:: iso version to download
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	desktop â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	live	â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	server	â­ creates auoinstall iso using the Ubuntu server dvd
#
# End of Documentation


	CONFIG=$1
	ISO_VER=$2
	prepare_environment_for_iso_creation

	write_information "Retreive list of available Ubuntu versions..."
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# Ask for desired version to use:
	ubuntu_ver=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... \n $picachu "  25 110 "${all[-1]}" 3>&1 1>&2 2>&3) ;clear
	[ "$ubuntu_ver" ] || ubuntu_ver=${all[-1]}

	write_information Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $ubuntu_ver ubuntu $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)

	write_status "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$PERMANENT_DOWNLOAD_DIR" || read -p "Failure to download ISO file"
		iso="$PERMANENT_DOWNLOAD_DIR/$ISO_FILENAME"
	fi

	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	TMP_DISC_DIR=$mnt
	write_status "Mounting intallation media..."
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	write_status "Verifying media presence..."
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	write_information "Creating Installations media: $auto "
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	write_status "Modifying startup instructions...  "
		for f in splash.pcx splash.png ; do
			rtd_oem_setup_brand_splash_screen $auto/isolinux/$f
		done
		pushd ./$auto/isolinux/
			find splash.pcx | cpio -ov >>bootlogo
			find splash.png | cpio -ov >>bootlogo
		popd
	write_status "Unmounting $mnt... "
	umount $mnt || rtd_oem_pause 1


	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in live media... "
			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in server image... "
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
	esac


	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso"


	if [[ -f $TARGET_ISO ]]; then
		rm $TARGET_ISO
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$TARGET_ISO" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}







rtd_oem_setup_brand_splash_screen()
{
# Description: Function to brand the installer splash screen for the customized installer
# downloaded from a ginve vendor. This function expects a few simple peices of information:
# parameter 1: full path to image file to be branded.
# parameter 2: quoted text to be incerted.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# rtd_oem_setup_brand_splash_screen [string] [string]
#
# [string]: /path/to/imagefile.png, "text to brand image with"
#
# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
#
# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif  [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"
	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR
	fi
}










rtd_oem_ubuntu_auto_install_iso_builder()
{
# Description: Function to generate an edited ISO file from a folder.
# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:

# :: function name				:: target		:: iso version to download
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	desktop â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	live	â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	server	â­ creates auoinstall iso using the Ubuntu server dvd
#
# End of Documentation


	CONFIG=$1
	ISO_VER=$2
	prepare_environment_for_iso_creation

	write_information "Retreive list of available Ubuntu versions..."
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# Ask for desired version to use:
	ubuntu_ver=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... \n $picachu "  25 110 "${all[-1]}" 3>&1 1>&2 2>&3) ;clear
	[ "$ubuntu_ver" ] || ubuntu_ver=${all[-1]}

	write_information Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $ubuntu_ver ubuntu $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)

	write_status "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$PERMANENT_DOWNLOAD_DIR" || read -p "Failure to download ISO file"
		iso="$PERMANENT_DOWNLOAD_DIR/$ISO_FILENAME"
	fi

	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	TMP_DISC_DIR=$mnt
	write_status "Mounting intallation media..."
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	write_status "Verifying media presence..."
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	write_information "Creating Installations media: $auto "
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	write_status "Modifying startup instructions...  "
		for f in splash.pcx splash.png ; do
			rtd_oem_setup_brand_splash_screen $auto/isolinux/$f
		done
		pushd ./$auto/isolinux/
			find splash.pcx | cpio -ov >>bootlogo
			find splash.png | cpio -ov >>bootlogo
		popd
	write_status "Unmounting $mnt... "
	umount $mnt || rtd_oem_pause 1


	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in live media... "
			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in server image... "
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
	esac


	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso"


	if [[ -f $TARGET_ISO ]]; then
		rm $TARGET_ISO
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$TARGET_ISO" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}









download_and_manipulate_iso_debian ()
{
# Description:
# download_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
# This is a simple command sequence to read the preference of distribution to install
# and what release to get... then download the network install file from debian
# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# download_and_manipulate_iso_debian [ISO Name] [Environment] [Addon Task]
#
# where [ISO Name] may be: any string to starte the file name with
# where [Environment] may be: any debian supported desktop environment
# where [Addon Task] may be: additional pre determined configuration
#
# EXAMPLE:
# download_and_manipulate_iso_debian openssh-server MinecraftTasks
# download_and_manipulate_iso_debian gnome-desktop
# download_and_manipulate_iso_debian xfce-desktop
#
# End of Documentation

	: "${TARGET_ISO_FILE_NAME:="$1-$2-mini-netinstall-auto.iso"}"
	: "${SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/SHA256SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"
	PREFERENCE=$2

		echo -e $YELLOW Geting install image...
		echo -e $GREEN Download: $SOURCE_ISO_URL $ENDCOLOR

	wget -4  -q --show-progress "$SOURCE_ISO_URL" -O "$TMP_DOWNLOAD_DIR/netboot.iso" && "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/netboot.iso" "-o$TMP_DISC_DIR" || echo -e $RED "FAILED to download and extract $SOURCE_ISO_URL" $ENDCOLOR
		echo -e $BLUE; ls $TMP_DISC_DIR ; echo -e $ENDCOLOR
		echo -e $YELLOW Geting non-free firmware...
		echo -e $GREEN Download: $SOURCE_FIRMWARE $ENDCOLOR
	wget -4  -q --show-progress "$SOURCE_FIRMWARE" -O "$TMP_DOWNLOAD_DIR/firmware.zip" && ( mkdir "$TMP_DISC_DIR/firmware" & "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/firmware.zip" "-o$TMP_DISC_DIR/firmware" )

	echo -e $BLUE ; ls $TMP_DISC_DIR/firmware ; echo -e $ENDCOLOR

	# Load the installation answers template.
		echo -e $YELLOW Getting intall instructions template... $ENDCOLOR
	make_preseed_cfg "$TMP_INITRD_DIR" "$PREFERENCE"

# ------------------- Patch 1 grub .cfg ------------------------ #

patch "$TMP_DISC_DIR/boot/grub/grub.cfg" <<PATCH
11a12
> set timeout=10
PATCH

sed -i s/"menuentry --hotkey=g 'Graphical install' {"/"menuentry --hotkey=g 'Automatic Graphical install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menuentry --hotkey=g 'install' {"/"menuentry --hotkey=g 'Automatic install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menu label ^Graphical install"/"menu label ^Automatic Graphical install"/g "$TMP_DISC_DIR/isolinux/gtk.cfg"
sed -i s/"menu label ^Install"/"menu label ^Automatic Install"/g "$TMP_DISC_DIR/isolinux/txt.cfg"
# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #

dos2unix "$TMP_DISC_DIR/isolinux/isolinux.cfg"
patch "$TMP_DISC_DIR/isolinux/isolinux.cfg" <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II

# -------------------------------------------------------------- #

	# Edit the installation instructions file...
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$TMP_INITRD_DIR/preseed.cfg"
	mkdir "$TMP_INITRD_DIR/custom" && cp "$SSH_PUBLIC_KEY_FILE" "$TMP_INITRD_DIR/custom/userkey.pub" || echo -e $RED "Failed to create $TMP_INITRD_DIR/custom" $ENDCOLOR

# ---------------------Create ssh key service ------------------ #

cat << SSH_KEY_KEYGEN > "$TMP_INITRD_DIR/custom/ssh-host-keygen.service"
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN

# -------------------------------------------------------------- #

	# Inject created content into the new ISO...
	echo -e $GREEN "# Modify the CLI Installer" $ENDCOLOR
	pushd "$TMP_INITRD_DIR" || echo -e $RED "failed to enter init directory: $TMP_INITRD_DIR" $ENDCOLOR
		gzip -d -c "$TMP_DISC_DIR/install.amd/initrd.gz" > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find ./custom | fakeroot "$BIN_CPIO" -o -H newc -A -F ./initrd
		cat ./initrd | gzip -9c > "$TMP_DISC_DIR/install.amd/initrd.gz"
		rm "$TMP_INITRD_DIR/initrd"

		echo -e $GREEN "# Modify the GTK Installer" $ENDCOLOR
		gzip -d -c  "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"  > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"
	popd || (echo -e $RED "Failed to popd" $ENDCOLOR & rtd_oem_pause 1)
	rtd_oem_setup_brand_splash_screen
}










create_iso_image_debian ()
{
# Description: Function to generate the new ISO file from the extracted and
# altered original ISO.
# Delete old iso file if there...
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	# Check for other input and create them if not defined...
	: "${TARGET_ISO:-"~/${TLA}-${FUNCNAME[0]}.iso"}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"

	if [[ -e /usr/lib/ISOLINUX/isohdpfx.bin ]]; then
		: "${ISOHDPFX_BIN:="/usr/lib/ISOLINUX/isohdpfx.bin"}"
	else
		write_warning "An important file (isohdpfx.bin) was not found in the expected location. Attepting to workaround the issue..."
		check_dependencies isolinux
		check_dependencies mlocate && ( write_warning "Updating file location DB, this may take a long time if there are a lot of files on the system..." ; updatedb )
		locate isohdpfx.bin || ( write_error "The file isohdpfx.bin could not be found or fetched. Please correct manually!" ; rtd_oem_pause 1 )
		: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	fi

	write_status "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "Failed to enter $TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r \
		-V "${VOLUME_TITLE:-"Made by ${FUNCNAME[0]}"}" \
		-J -b "isolinux/isolinux.bin" \
		-c boot.cat \
		-no-emul-boot \
		-boot-load-size 4 \
		-boot-info-table \
		-input-charset utf-8 \
		-isohybrid-mbr "${ISOHDPFX_BIN}" \
		-eltorito-alt-boot \
		-e boot/grub/efi.img \
		-no-emul-boot \
		-isohybrid-gpt-basdat -o "$TARGET_ISO" ./ || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
	chmod 777 "$TARGET_ISO" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"

	test_iso_boot_media ${TARGET_ISO}
	if ${RTD_GUI} --yesno "Would you like to make a bootable thumbdrive from this ISO media?" ${HEIGHT} ${WIDTH} ; then
		create_physical_media_from_iso ${TARGET_ISO} || create_physical_media_from_iso
	else
		return
	fi
}















create_iso_image ()
{
# Description: Function to generate a bootable ISO file from source folder or an extracted and
# altered original ISO. The function takes 3 arguments: target file name, folder to use as source
# and volume title. The first argument is mandatory since it makes not sense unless it is known
# what source to use for makeing the ISO file.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# create_iso_image  ~/mybootablecdfolder ~/mybootable.iso "My cool bootable iso title"
#
# This function will over write the old iso file if there...
#
# End of Documentation

	# Check for required input...
	TMP_DISC_DIR=$1
	[[ -z "$TMP_DISC_DIR" ]] || rtd_oem_pause 1 "${FUNCNAME[0]} requires atleast one parameter."

	# Check for other input and create them if not defined...
	TARGET_ISO=$2
	: "${TARGET_ISO:-"~/${TLA}-${FUNCNAME[0]}.iso"}"
	VOLUME_TITLE=$3
	: "${VOLUME_TITLE:-"Made by ${FUNCNAME[0]}"}"

	check_dependencies isolinux
	check_dependencies mlocate && updatedb
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"

	write_status "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "failed to enter $TMP_DISC_DIR "
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" \
			-J -b isolinux.bin \
			-c boot.cat \
			-no-emul-boot \
			-boot-load-size 4 \
			-boot-info-table \
			-input-charset utf-8 \
			-isohybrid-mbr "$ISOHDPFX_BIN" \
			-eltorito-alt-boot \
			-e boot/grub/efi.img \
			-no-emul-boot \
			-isohybrid-gpt-basdat \
			-o "$TARGET_ISO" ./ || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
	chmod 777 "$TARGET_ISO" || rtd_oem_pause 1 "${FUNCNAME[0]}: An error may have occurred (review above outout) then: Press [ENTER] to continue:"
}





create_physical_media_from_iso ()
{
# Description:
# Function to automatically write ISO (virtual DVD/CD/BlueRay) to a thumb drive. No argumenst are
# required, but a source ISO file location can may be provided when calling the function.
# If information is required, but not provided, the end user will be interactively prompted.
# This function requires elevated priviledges to be able to write media to a thumb drive
# (boot sector) and other system restrictied activities. If the function is NOT called in a
# script with elevated priviledges, it will attempt to elevate priviledges and prompt for a password.
# Since writing a new bootable thumb drive is inherrently an interactive activity; a prompt will
# be displayed asking what media to write to. If no media is present, a warning error
# message will be displayed.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# "create_physical_media_from_iso" or "create_physical_media_from_iso path/to/file.iso"
#
# NOTE:
# [Note 1] An ISO file, often called an ISO image, is a single file that's a perfect representation of an
# entire CD, DVD, or BD. The entire contents of a disc can be precisely duplicated in a single ISO file.
# An optical disc image (or ISO image, from the ISO 9660 file system used with CD-ROM media) is a disk image
# that contains everything that would be written to an optical disc, disk sector by disc sector, including the
# optical disc file system. ISO images are expected to contain the binary image of an optical media file system
# (usually ISO 9660 and its extensions or UDF), including the data in its files in binary format, copied exactly
# as they were stored on the disc. The data inside the ISO image will be structured according to the file system
# that was used on the optical disc from which it was created.
#
# [Note 2] A USB flash drive is a data storage device that includes flash memory with an integrated USB interface.
# It is typically removable, rewritable and much smaller than an optical disc. Most weigh less than 30 g (1 oz).
# Since first appearing on the market in late 2000
# End of documentation


	: ${BackTitle="Physical Installation Media Creator"}
	: ${Title="OS Media Manger"}

	if [ ! "$UID" -eq 0 ]; then
		# find  a diferent way... tempfile not universal...
		data=$(tempfile 2>/dev/null)
		trap "rm -f $data" 0 1 2 5 15
		dialog --title "${Title}" --backtitle "${BackTitle}" --insecure --passwordbox "\n This functionality requires elevated priviledges. \n Please provide your (sudo) password" 10 90 2> $data
		ret=$? ; clear
		case $ret in
			0) cat $data | sudo -S bash "$0" "$*" ;;
			1) echo "Request cancelled" ;;
			255) [ -s $data ] && rm $data &>/dev/null || echo "[esc] Request aborted" ;;
			* ) rm $data &>/dev/null ; exit 1
		esac
		rm $data &>/dev/null
		exit
	fi

	if [[ -z "$1" ]]; then
		[[ -d /home/${SUDO_USER}/Virtual-DVDs ]] && SuggestedFolder="/home/${SUDO_USER}/Virtual-DVDs/" || SuggestedFolder="/home/${SUDO_USER}"
		TARGET_ISO=$(dialog --stdout --title "${Title}" --backtitle "${BackTitle}" --fselect "${SuggestedFolder}" 15 110 2)
		UserResponse=$? ; clear
		case ${UserResponse} in
			  1) echo "Request cancelled"; return 0 ;;
			  255) echo "[ESC] key pressed."; return 255 ;;
		esac
	else
		TARGET_ISO=$1
	fi

	if [[ -z "${TARGET_ISO}" ]]; then
		DIALOGRC=~/.dialogrc
		if [[ -e ${DIALOGRC} ]]; then
			mv ${DIALOGRC} ${DIALOGRC}.bak
		fi

		echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
		dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n You must provide an ISO file as argument! \n Usage: ${0##*/} ~/filename.iso"  14 90
		clear ; rm ${DIALOGRC}

		if [[ -e ${DIALOGRC}.bak ]]; then
			mv ${DIALOGRC}.bak ${DIALOGRC}
		fi
		return 1
	else
		#          List removable dev : not loop dev: not CD    : not nvme HD : filter: header w. name
		devlist="$(lsblk -ndo name,rm |grep -v loop |grep -v sr |grep -v nvme |grep 1 | cut -f1 -d' ')"

		if [[ -z ${devlist} ]]; then
			DIALOGRC=~/.dialogrc
			echo 'screen_color = (CYAN,RED,ON)' >${DIALOGRC}
			dialog --title "${Title}" --backtitle "${BackTitle}" --msgbox "\n No removable media could be found! Please insert a thumb drive and try again."  14 90
			clear ; rm ${DIALOGRC}
			return 1
		else
			declare -A RemovableMediaList
			index=1

			for media in ${devlist};
			do
				SuggestedRemovableDevice="${media}"
				RemovableMediaList[$index]=$(echo -e \'$(fdisk -l /dev/$media |head -1)\')
				(( index++ ))
			done

			DiscoveredItems="\n
			\n Removable media found: ${#RemovableMediaList[@]}
			\n --------------------------------------------------------

			$(until [ $i -gt ${#RemovableMediaList[@]} ]
			do
				[[ $i -gt 0 ]] && echo -e "Removable Disk $i:   ${RemovableMediaList[$i]} \n"
				((i=i+1))
			done
			)"

			USBTargetDevice=$( dialog --stdout --no-collapse --title "${Title}" --backtitle "${BackTitle}"  --inputbox "${DiscoveredItems}" 15 110 /dev/${SuggestedRemovableDevice} )
			Response=$?
			clear
			case ${Response} in
				0 )
					dialog --title "${Title}" --backtitle "${BackTitle}" --yesno "Please Confirm:\n Write the ISO file: \n ${TARGET_ISO} \n To the drive: \n ${USBTargetDevice}" 25 90
						case $? in
							0 ) ( dd if=${TARGET_ISO} of=${USBTargetDevice} status=progress 2>&1 |dialog --title "${Title}" --backtitle "${BackTitle}" --programbox "Please wait, writing disk now:" 25 90) ;;
							1 ) echo "Request cancelled"; create_physical_media_from_iso ;;
							255 ) echo "[ESC] key pressed."; return 255 ;;
							* ) echo "An unknown event occurred!" ; return 1 ;;
						esac
					clear ; return
				;;
				1 ) echo "Request cancelled"; return 0 ;;
				255 ) echo "[ESC] key pressed."; return 255 ;;
				* ) echo "An unknown event occurred!" ; return 1 ;;
			esac
			return
		fi
	fi
	return
}







compress_all_items_here ()
{
# Description: Function to compress the contents of the present working directory.
#
# Purpose:	To compress all files and folders individually found in the current folder.
#		The current folder refers to the present working directory "PWD". Compression method
#		is 7z. This privides a high level of compression.
#
# Globals:
# Arguments: --noprompt, --encrypt (mutually exclusive)
# Outputs:
# Returns:
# Usage:	compress_all_items_here [--compress] [--noprompt]
# Usage:	Simply call this function to accomplish this task.
#
# Arguments:	No parameters required for basic function (user will be prompted).
#
# End of documentation

	if hash 7z ; then
		write_information "7z is present, good..."
	else
		write_error "the 7z (7 zip) program was not found"
		for i in p7zip-full 7za
		do
			for i in dnf zypper apt-get ; do
				write_warning "Installing software requires elevated priviladges!"
				write_status "Peare enter password beloow (if not cached):"
				sudo $i install -y p7zip-full
			done
			exit 0
		done
	fi

	if [[ ! "$1" == "--noprompt" ]]; then
		if hash dialog 2>/dev/null ; then
			if ( dialog --backtitle "${BRANDING:-"${FUNCNAME[0]}"} ${1}" --title "Compress Content Here" --colors --cr-wrap --no-collapse --no-button "NO: Quit" --yes-button "YES: Compress" --yesno "Hello ${USER}... I am going to compress each file or folder that I find here: $(pwd) These are: \Z5 \n$(ls -h1 -F -I "*.7z")" 20 90 ); then
				clear
			else
				clear
				exit
			fi
		else
			clear
			write_host --cyan  "Hello ${USER}... I am going to compress each file or folder that I find in this folder. These are:"
			ls -I "*.7z" --color=always
			echo -e " \n"
			write_information "To cancel this, just close the terminal or press [CRTL] + [C]."
			read -p "Press the [ENTER] key to continue..."
		fi
	fi


	if echo ${*} |grep "encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" --stdout --insecure --passwordbox "\n Please provide a passphrase for the encryption. \n Please do not forget it!" 10 90 )
		ret=$? ; clear
		case $ret in
			0)
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $(ls -I "*.7z")
				do
					7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS
				result="
				\n Created the following archives encrypted with a pass-phrase:

				\n \Z1  $(ls *.7z)"
				display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		for line in $(ls -I "*.7z")
		do
			7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on $line.7z $line
		done
		IFS=$SAVEIFS
		result="
		Created the following archives un-encrypted:

		\n \Z1  $(ls *.7z)"
		display_result "Done Compressing"
	fi
}






compress_provided_items ()
{
# Description: Function to compress the contents of the present working directory.
#
# Purpose:	To compress all files and folders individually found in the current folder.
#		The current folder refers to the present working directory "PWD". Compression method
#		is 7z. This privides a high level of compression.
#
# Globals:
# Arguments: --noprompt, --encrypt (mutually exclusive)
# Outputs:
# Returns:
# Usage:	compress_provided_items [--encrypt] [--noprompt]
# Usage:	Simply call this function to accomplish this task.
#
# Arguments:	No parameters required for basic function (user will be prompted).
#
# End of documentation
list="$*"
	if echo ${@} |grep "--encrypt" ; then
		passtoken=$(dialog --title "${Title:="$( basename $0 )"}" --backtitle "${BRANDING:-"${FUNCNAME[0]}"}" --stdout --insecure --passwordbox "\n To encrypt the content you have to give me a phrase to encrypt it with. \n This can be anything in one long word, but never forget it!" 10 90 )
		ret=$? ; clear
		case $ret in
			0)

				echo "â˜• Please be patient, Large sets of files may take serious time..."
				list="${list:9:1000}"
				SAVEIFS=$IFS
				IFS=$(echo -en "\n\b")
				for line in $list ;
				do
					7z a -t7z -m0=lzma2 -mx=9 -mfb=64 -md=64m -ms=on -mhe=on -p$passtoken $line.7z $line
				done
				IFS=$SAVEIFS

				result="
				\nâ™¹ Created the following archive(s) encrypted: \n
				\n STATUS	FILENAME
				$(
				echo \\n
				for d in $list; do
				[[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n"
				done
				)
				\n Please review the above: â«"
				display_result "Done creating encrypted archives"
			;;
			1) echo "Request cancelled" ; exit 1;;
			255) echo "[esc] Request aborted" ; exit 255;;
			* )  exit 1 ;;
		esac
	else
		SAVEIFS=$IFS
		IFS=$(echo -en "\n\b")
		write_information "â˜• Please be patient, Large sets of files may take serious time..."

		for line in $@ ;
		do
			case $line in
				--noprompt ) echo sipp >/dev/null ;;
				* ) 7z a -t7z -m0=lzma2 -mx=5 -mfb=64 -md=64m -ms=on -mhe=on $line.7z $line ;;
			esac
		done

		IFS=$SAVEIFS
		result="
		Created the following archive(s): \n
		\n STATUS	FILENAME
		$(
		echo \\n
		for d in $@; do
		[[ -e $d.7z ]] && echo "Confirmed	:  $d.z7 \\n" || echo " Failed!	:  $d.z7 \\n"
		done
		)
		\n Please review the above: â«"
		if echo ${@} |grep "--noprompt" ; then
			echo $result
		else
			display_result "Done creating encrypted archives"
		fi
	fi
}








create_swapfile ()
{
# Description: Function to create a swapfile and enable it automatically.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Usage: [function_name] [options]
# Arguments:
# 	[size] : size in MB or GB
# 	[path] : path to file (Default path: /swapfile)
#
# NOTE:
# The Linux Kernel divides RAM into chunks of memories and the swapping process i
# s when the Linux Kernel uses a hard disk space (swap space) to store information from RAM
# and thus releases some RAM space. That is why when you install a Linux distribution, the
# installation wizard usually asks you to assign some space for the system and another for the swap.
#
# Using swap is a very useful way to extend the RAM because it provides the necessary additional
# memory when the RAM space has been exhausted and a process has to be continued. It is especially
# recommended when you have less than 1Gb of RAM. Although in the end, everything depends on you.
#
#
# End of documentaton


	SWAP_SIZE=$1
	SWAP_PATH=$2



	: "${SWAP_SIZE:=4G}"
	: "${SWAP_PATH:="/swapfile-${RANDOM}"}"

	write_information "Swap Size: ${SWAP_SIZE}"
	write_information "File Path: ${SWAP_PATH}"

	usage_mesage () {
		write_host --blue "
		Usage: $0 {size}
		Example: $0 4G
		(Default path: /swapfile)
		Usage with optional path: $0 {size} {path}"
	}

	if [[ -z "${SWAP_SIZE}" ]]; then
		# If we are not given any size to make the swaptfile... well...
		echo -e $RED "Please tell me what size swap file to make!" $ENDCOLOR
		usage_mesage
		exit 1
	elif [[ ! "${SWAP_SIZE:0:1}" -ge "1" ]]; then
		# Fail if the argument is not a numer
		echo -e $RED "The size for swap file must be a number!" $ENDCOLOR
		usage_mesage
		exit 1
	else
		if [[ -e ${SWAP_PATH} ]]; then
			write_error "ERROR: the file ${SWAP_PATH} already exists! Please choose a different name."
			exit 1
		fi
		write_host --cyan "Welcome to Swap setup script! This script will automatically setup a swap file and enable it."

		fallocate -l "${SWAP_SIZE}" "${SWAP_PATH}"	&& write_information "Allocated ${SWAP_SIZE} swap file: ${SWAP_PATH}" || (write_error "Error creting actual swapfile using fallocate! "; exit 1)
		chmod 600 "${SWAP_PATH}"			&& write_information "Sucessfully modified permissions on $SWAP_PATH" || (write_error "Error changing premissions" ; exit 1)
		mkswap "${SWAP_PATH}"				&& (write_status "Sucessfully formatted ${SWAP_PATH} as a swap partition" ; file -s ${SWAP_PATH}) || (write_error "Error formating ${SWAP_PATH} as a swapspace!" ; exit 1)
		swapon "${SWAP_PATH}" 				# Turn on the swap file...
		if [ $? = 0 ]; then
			echo "${SWAP_PATH}   none    swap    sw    0   0" | sudo tee /etc/fstab -a # Add to fstab
			write_status "Done! You now have a ${SWAP_SIZE} swap file at ${SWAP_PATH}"
		else
			if df -T ${SWAP_PATH} |grep btrfs >/dev/null ; then
				write_error "ERROR: swapfiles cannot be allocated on BTRFS. \n The root filesystem is BTRFS. Please use an ext4 or xfs partition.
				This is a BUG and hopefully it will be fixed soon... "
				exit 1
			else
				write_error "An unknown error occurred with starting the swap partition.."
				exit 1
			fi
		fi

	fi
}







scan_for_malware ()
{
# Description:
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	# Set the location of the quarantined files
	QUARANINE=~/VIRUS
	if [ ! -d "$QUARANINE" ]; then
		mkdir "$QUARANINE"
	fi

	# set the location of the log file
	CLAMSCANLOGFILE=~/clamscan.log
	SCANDIR=$@

	# First discover what menu system is installed. Some systems use "dialog" and
	# other systems use whiptail for the terminal to show menus and dialogs.

	if ! type clamscan ; then
		check_dependencies clamscan && exit
	fi




	write_host --purple "
	___________________________________________________

	[   Setting    ] [           Value             ]
	Logging to:         $CLAMSCANLOGFILE
	Quarantine in:      $QUARANINE

	___________________________________________________
	Starting scan....
	Scanning folder: $@"

	# Run the scan function
	clamscan $SCANDIR -r -a -i -l $CLAMSCANLOGFILE --bytecode=yes --stdout  --phishing-sigs --bell --algorithmic-detection=yes --move="$QUARANINE"
	return $?
}





















#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#                  .88888888:.
#                 88888888.88888.
#               .8888888888888888.
#               888888888888888888
#               88' _`88'_  `88888
#               88 88 88 88  88888
#               88_88_::_88_:88888
#               88:::,::,:::::8888
#               88`:::::::::'`8888
#              .88  `::::'    8:88.
#             8888            `8:888.
#           .8888'             `888888.
#          .8888:..  .::.  ...:'8888888:.
#         .8888.'     :'     `'::`88:88888
#        .8888        '         `.888:8888.
#       888:8         .           888:88888
#     .888:88        .:           888:88888:
#     8888888.       ::           88:888888
#     `.::.888.      ::          .88888888
#    .::::::.888.    ::         :::`8888'.:.
#   ::::::::::.888   '         .::::::::::::
#   ::::::::::::.8    '      .:8::::::::::::.
#  .::::::::::::::.        .:888:::::::::::::
#  :::::::::::::::88:.__..:88888:::::::::::'
#   `'.:::::::::::88888888888.88:::::::::'
#         `':::_:' -- '' -'-' `':_::::'`
# ----------------------------------------------------------------
#  ____         __ _
# / ___|  ___  / _| |___      ____ _ _ __ ___
# \___ \ / _ \| |_| __\ \ /\ / / _` | '__/ _ \
#  ___) | (_) |  _| |_ \ V  V / (_| | | |  __/
# |____/ \___/|_|  \__| \_/\_/ \__,_|_|  \___|
#
#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
# ----------------------------------------------------------------





software::ensure_software_store_available ()
{
# Description: Function to ensure that flatpack is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# GNOME Software is a utility for installing applications and updates on Linux.
# It is part of the GNOME Core Applications, and was introduced in GNOME 3.10.[3]
#
# It is the GNOME front-end to the PackageKit, in turn a front-end to several package management
# systems, which include systems based on both RPM and DEB.
#
# The program is used to add and manage software repositories as well as Ubuntu
# Personal Package Archives (PPA). Ubuntu replaced its previous Ubuntu Software Center
# program with GNOME Software starting with Ubuntu 16.04 LTS,[5] and re-branded it as "Ubuntu Software".
#
# It also supports fwupd for servicing of system firmware.[6]
#
# GNOME Software removed Snap support in July 2019, due to code quality issues, lack of integration
# (specifically, the user can't tell what snap is doing after they click "install" and that it
# generally ignores GNOME's settings), and the fact that it competes with the GNOME-supported Flatpak standard.[7]
#
# End of documentation


	case "$DESKTOP_SESSION" in
		plasma )
			write_information "${FUNCNAME[0]}: plasma on anything..".
			check_dependencies plasma-discover
			check_dependencies plasma-discover-backend-flatpak
			check_dependencies plasma-discover-backend-snap
		;;
		"/usr/share/xsessions/default" )
			# Special case for suse again...
			if cat /usr/share/xsessions/default.desktop |grep "Plasma"  ; then
				write_information "${FUNCNAME[0]}: kde on suse"
				check_dependencies plasma-discover
				check_dependencies plasma-discover-backend-flatpak
				check_dependencies plasma-discover-backend-snap
			else
				write_information "${FUNCNAME[0]}: gnome on suse"
				check_dependencies gnome-software
				check_dependencies gnome-software-plugin-flatpak
				check_dependencies gnome-software-plugin-snap
			fi
		;;
		* )
			write_information "${FUNCNAME[0]}: case = *"
			check_dependencies gnome-software
			check_dependencies gnome-software-plugin-flatpak
			check_dependencies gnome-software-plugin-snap
		;;
	esac

}







ensure_flatpak_package_managment ()
{
# Description: Function to ensure that flatpack is installed and flathup enabled.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs:
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Like Snap, Flatpak is another distribution independent package format aimed to simplify overall
# app distribution and usage in Linux systems. Previously known as xdg-app, the framework was based
# on the concept of running applications in a secure virtual sandbox without requiring root privileges
# or posing a security threat to the system.
# Flatpak was officially released in 2015 with a reliable backup from Red Hat, Endless Computers, and
# Collabora. It targeted primarily three Desktop Environments. That is FreeDesktop, KDE, and GNOME. The
# Linux distributions currently having this framework are arch Linux, Debian, Fedora, Mageia,
# Solus, and Ubuntu.The Flatpak framework itself is developed in C programming and released under the
# LGPL license. The lead developer is Alexander Larsson â€“ a Red Hat employee. Like Snapcraft for Snap,
# Flatpak also has the Flathub app store where users can find and install all Flatpak packages.
# Initially, Flathub only allowed open-source publishing applications on the website but
# has recently approved the publishing of proprietary apps.
# Additionally, unlike Snap, where we have a single repository controlled by Canonical to install and update
# software packages, Flatpak supports the use of multiple repos. The one significant disadvantage with this
# package is the lack of support for Servers.
#
#	*	---       PREFFERRED Software install (Security + Control)           ----		*
#
#  CAPABILITY TABLE:
# +-----------------------------------------------------+----------------+-------------+-----------------+
# | Features                                            | Snap           | Flatpak     | AppImage        |
# +-----------------------------------------------------+----------------+-------------+-----------------+
# | Permission Controls Toggles                         | Yes            | Yes         | No              |
# | Sandboxing Support                                  | Yes            | Yes         | Yes             |
# | Sandboxing Mandatory                                | Yes            | Yes         | No              |
# | App Portability                                     | Yes            | Yes         | No              |
# | Native Theme Support                                | Yes (with      | Yes (with c | Yes (with cav   |
# | Support for Bundled Libraries                       | Yes            | Yes         | Yes             |
# | Fully Contained Single Executable Support           | No             | No          | Yes             |
# | Online App Store                                    | Yes            | Yes         | Yes             |
# | Multi-version Parallel Apps Support                 | Yes            | Yes         | Yes             |
# | Automatic Updates                                   | Yes            | Yes         | Yes(with cave   |
# | Support for Chrome OS (through Crostini containers) | Yes            | Yes         | Yes             |
# | App Size                                            | higher than    | higher than | Lowest          |
# | Number of Applications Available in the App Store   | Highest        | Lowest      | Somewhere in  n |
# | Plugins for Desktop App Store Software              | Yes            | Yes         | No              |
# +-----------------------------------------------------+----------------+-------------+-----------------+
# End of documentation
	if hash flatpak ; then
		write_status "${FUNCNAME[0]}: FLATPAK command is available! Skipping check ... "
	else
		ensure_admin
		write_information "${FUNCNAME[0]}: Ensuring Flatpack software distribution system is available..."
			check_dependencies flatpak || write_error "${FUNCNAME[0]}: Failed to satisfy dependecy flatpak!"
			flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || write_error "${FUNCNAME[0]}: Failed to add flatpak repo!"
		return $?
	fi
}





ensure_snap_package_managment ()
{
# Description: Function to ensure that snap is installed.
# Globals: none
# Dependencies: [distro pakcage managment] [function: check_dependencies] [Internet access]
# Arguments: None
# Outputs: stdout
# Returns: Standard return codes 1/0
# Usage: Call the function with no arguments
# NOTE: https://www.fosslinux.com/42410/snap-vs-flatpak-vs-appimage-know-the-differences-which-is-better.htm
# Snap is a distribution independent package format developed by Canonical and first released
# in 2014. It was initially developed for Ubuntu but has been adopted by other Linux distributions
# like Arch, Linux Mint, CentOS, Gentoo, and Fedora, and also included support for the Snap framework.
# The main aim behind this package format development was to come up with a single unified format for
# software packages to run in a wide range of devices. That includes IoT (IoT), embedded devices
# running Ubuntu Core (a minimalistic version of Ubuntu), and computer systems that ran some Ubuntu version.
# Snap also offers an online app store â€“ Snapcraft, where users can find and install the software packages.
# It creates a large pool where users can find all available a snap package. Snapcraft is itself
# controlled and maintained by the Canonical team.
# package is the lack of support for Servers.
#
#	*	---       PREFFERRED Software install (Security + Control)           ----		*
#
#  CAPABILITY TABLE:
# +-----------------------------------------------------+----------------+-------------+-----------------+
# | Features                                            | Snap           | Flatpak     | AppImage        |
# +-----------------------------------------------------+----------------+-------------+-----------------+
# | Permission Controls Toggles                         | Yes            | Yes         | No              |
# | Sandboxing Support                                  | Yes            | Yes         | Yes             |
# | Sandboxing Mandatory                                | Yes            | Yes         | No              |
# | App Portability                                     | Yes            | Yes         | No              |
# | Native Theme Support                                | Yes (with      | Yes (with c | Yes (with cav   |
# | Support for Bundled Libraries                       | Yes            | Yes         | Yes             |
# | Fully Contained Single Executable Support           | No             | No          | Yes             |
# | Online App Store                                    | Yes            | Yes         | Yes             |
# | Multi-version Parallel Apps Support                 | Yes            | Yes         | Yes             |
# | Automatic Updates                                   | Yes            | Yes         | Yes(with cave   |
# | Support for Chrome OS (through Crostini containers) | Yes            | Yes         | Yes             |
# | App Size                                            | higher than    | higher than | Lowest          |
# | Number of Applications Available in the App Store   | Highest        | Lowest      | Somewhere in  n |
# | Plugins for Desktop App Store Software              | Yes            | Yes         | No              |
# +-----------------------------------------------------+----------------+-------------+-----------------+
# End of documentation


	if [[ $(echo "$OSTYPE" |grep "linux") ]]; then
		ensure_admin
		# these tests focus on the latest versions of the distros evaluated...
		if hostnamectl |grep "SUSE" 2>/dev/null ; then
			write_warning "${FUNCNAME[0]}: Special case for suse"
			write_status "${FUNCNAME[0]}: Adding repository..."
				zypper addrepo --refresh https://download.opensuse.org/repositories/system:/snappy/openSUSE_Leap_$(cat /etc/os-release |grep VERSION_ID |cut -d= -f2|cut -d\" -f2) snappy
			write_status "${FUNCNAME[0]}: Importing GPG keys..."
				zypper --gpg-auto-import-keys refresh
			write_status "${FUNCNAME[0]}: Updating software repository indexes..."
				zypper dup --from snappy
			write_information "${FUNCNAME[0]}: Ensuring SNAP software distribution system is available..."
				check_dependencies snapd || write_error "${FUNCNAME[0]}: Failed to satisfy dependecy SNAP!"
				systemctl enable snapd ; systemctl start snapd
				systemctl is-active --quiet snapd || ( write "${FUNCNAME[0]}: Service snapd not started sucessfully!" ; return 1 )

			if [[ -e /snap ]]; then
				write_information "${FUNCNAME[0]}: SNAP classic support present... "
			else
				ln -s /var/lib/snapd/snap /snap
			fi
			return $?
		elif hostnamectl |grep "Solus" 2>/dev/null ; then
			write_information "${FUNCNAME[0]}: Solus has snap support built in..." ;return 0
		elif hostnamectl |grep "Ubuntu" 2>/dev/null ; then
			write_information "${FUNCNAME[0]}: Ubuntu has snap support built in..." ;return 0
		elif hostnamectl |grep "Zorin" 2>/dev/null ; then
			write_information "${FUNCNAME[0]}: Zoring has snap support built in..." ;return 0
		elif hostnamectl |grep "Manjaro" 2>/dev/null ; then
			write_information "${FUNCNAME[0]}: Manjaro has snap support built in..." ;return 0
		else
			# For distributions that do not need to add a repository to install snap
			# But would need to install it from their standard reopsitory....
			write_information "${FUNCNAME[0]}: Ensuring SNAP software distribution system is available..."
			check_dependencies snapd || write_error "${FUNCNAME[0]}: Failed to satisfy dependecy SNAP!"
			systemctl enable snapd ; systemctl start snapd ; systemctl status snapd
			systemctl is-active --quiet snapd || return 1

			if [[ -e /snap ]]; then
				write_information "SNAP classic support present... "
			else
				ln -s /var/lib/snapd/snap /snap
			fi
			return $?
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "${FUNCNAME[0]}: Mac OSX is currently not supported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "${FUNCNAME[0]}: CYGWIN is currently unsupported with snap..."  ; return 1
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "${FUNCNAME[0]}: Lightweight shell is currently unsupported with snap... "  ; return 1
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "${FUNCNAME[0]}: Free BSD is currently unsupported with snap... " ; return 1
	else
		echo "I have no Idea what this system is" ; return 1
	fi
}





up_2_date ()
{
# Description: Function to simplify updating system completely. At present this function sets the
# highest preference to use "pkcon", the command line interface of "Package Kit" since
# this is the most consistent across different distrbutions. It may even work on BSD.
# Only if "pkcon" is not available, will the function use the identified distro native
# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may
# alias another distributions command (like SuSE does with apt) to be helpfull.
# This is one of the first update functions written and is kept for compatibility.
# Globals:
# Arguments: None
# Outputs:
# Returns: 0/1/3 where 1/0 = sucess/fail and 3 = package manager NOT found
# Usage: up_2_date
# End of documentation
	ensure_admin
	write_status "Running up2date function:"

	if hash pkcon 2>/dev/null; then
		pkcon update -y
	elif hash yum 2>/dev/null; then
		yum update -y
	elif hash apt 2>/dev/null; then
		apt-get update
		apt-get upgrade -y
		apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		return zypper up -y
	else
		return 3
	fi
}






system_config::tune_system_power_profile ()
{
# Description: Tuned is a Linux feature that monitors a system and optimizes its performance
# under certain workloads. Tuned uses profiles to do this. A profile is a set of rules that
# defines certain system parameters such as disk settings, kernel parameters, network
# optimization settings, and many other aspects of the system.
#
# This function sets the performance according to laptop/desktop/vm based on what is detected.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: simply call function in a script
# End of documentation

	check_dependencies tuned
	systemctl enable --now tuned
	tuned-adm profile balanced

	case "${1}" in
		--quiet | -q ) : ${_print="#"} ;;
		* ) unset _print ;;
	esac

	check_dependencies virt-what
	check_dependencies laptop-detect
	if virt-what ; then
		"${_print}" write_information "${FUNCNAME[0]}: This is likely not running in a virtual machine."
		if laptop-detect ; then
			"${_print}" write_information "${FUNCNAME[0]}: This is likely a laptop; applying pwersave profile..."
			tuned-adm profile powersave
		else
			"${_print}" write_information "${FUNCNAME[0]}: This is likely NOT a laptop; applying desktop profile..."
			tuned-adm profile desktop
		fi
	else
		"${_print}" write_information "${FUNCNAME[0]}: This is likely a VM; applying virtual-guest profile..."
		tuned-adm profile virtual-guest
	fi
}




rtd_oem::check_boot_splash_screen_enable () {
# Description: OEM function to enable splash screen on boot if desktop is indicated in
# a configuration file. This file could be an AutoYast.xml, or ks.cfg, or a preseed.cfg.
#
# Globals:
# Arguments: [FILE]
# Outputs:
# Returns: error level
# Usage: rtd_oem::check_boot_splash_screen_enable /root/original-ks.cfg
# End of documentation
	if -f $1 ; then
		if cat $1 |grep "-desktop" ; then
			InstallSoftwareFromRepo splash && echo 'GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"'>> /etc/default/grub
			update-grub
		fi
	fi
}




is_software_package_installed ()
{
# Description: Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Globals:
# Arguments: None
# Outputs:
# Returns: 1/0 where 0 = package is installed/1 = package is NOT installed
# Usage:
# Call this function by:
# is_software_package_installed "package name"
#                 or
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash dnf 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper -x se "$1" |grep 'status="installed"' > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}








is_software_package_available ()
{
# Description: Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper info "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	else
		return 3
	fi

}







InstallSoftwareFromRepo ()
{
# Description: Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpack
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
# snap or flatpack use.
# End of documentation
	ensure_admin
	: ${_LOGFILE:="/var/log/rtd/$( basename "$0".log )"}
	# Ask function how to install software...
	set_install_command >>/dev/null 2>&1

	# make some decent display terminal Graphics...
	PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$1"; then
		if is_software_package_available "$1"; then
			echo -ne "${PRE}"& $_INSTCMD "$1" &>>${_LOGFILE}  && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR \n"
			if [ $? != 0 ];
			then
				return 1
			fi
		else
			echo -ne "$PRE"\ && ( printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW NOT AVAILABLE... $ENDCOLOR \n" && return 1 )
		fi
	else
		echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Allready Installed... $ENDCOLOR \n"
	fi
}









set_install_command ()
{
# Description:
# add global install command for portability and convenience. This function
# allows for scripts to add software across many systems.
# Primarily for Linux: this function will look for the common package managers
# apt (all debina and ubuntu based distributions), dnf (RedHat, Fedora, Mandriva, and others)
# zypper (SuSE and Open SUSE). If neither of those package manages are available many systems
# use package kit; and this will be registered as an sinstall option.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: "set_install_command"
#
# Arguments: none.
#
# Return Codes:
# set_install_command will return a global variable ${_INSTCMD}
# ${_INSTCMD} will expand to teh appropriate install cmmand including options
# for non interactive install of a package. ${_INSTCMD} package.name will install said pacakge.
#
# A return code of "1" will be returned the function was not able to set the install command.
#
#
# End of documentation

	if [[ 'echo $OSTYPE" |grep "linux"' ]]; then

		if hash dnf 2>/dev/null; then
			# Try dnf (RedHat, Cent OS, Fedora)
			write_status "Setting install options for DNF"
			export _INSTCMD="sudo dnf -y  install"
		elif hash zypper 2>/dev/null; then
			# Try zypper (Open SUSE)
			write_status  "Setting install options for ZYPPER"
			export _INSTCMD="sudo zypper install -y "
		elif hash apt 2>/dev/null; then
			# Try apt (Debian, Ubuntu, and all derivatives)
			write_status  "Setting install options for DEB"
			export _INSTCMD="sudo apt-get -y install"
		elif hash pkcon 2>/dev/null; then
			# If thre is no apt, zypper, dnf
			write_status  "Setting install options for Package Kit"
			export _INSTCMD="sudo pkcon -y  install"
		else
			write_error "This system does not seem to have a software managment system"
			return 1
		fi

	elif [[ "$OSTYPE" == "darwin"* ]]; then
		write_error "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		write_error "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		write_error "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		write_error "Free BSD is currently unsupported... "
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		return 1
	fi
	return $?
}







check_dependencies ()
{
# Description:
# Function to check that a piece of software is installed and if not install it.
# Works for apt based systems currently. The function will take a parameter that is expected to
# match the software command line name or rather the name of the package. This should get
# updated to also check and install from snap and flatpack at some point.
#
# Globals:
# Arguments: None
# Dependencies: [flatpak; snap; or package manager]
# Function Dependencies: ensure_admin, write_status, write_information, write_warning, write_error, is_software_package_installed,
#                        InstallSoftwareFromRepo, ensure_snap_package_managment, ensure_flatpak_package_managment
# Outputs:
# Returns: 1/0
# Usage: check_dependencies [packagename]
#
# EXAMPLE: check_dependencies snapd
#
# End of documentation
	ensure_admin
	#---------------------------------------------------------------
	write_status "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	if is_software_package_installed $1 ; then
		write_information "I found that $1 is present on this system... thankyou for that! "
	else
		write_warning "You seem to have no $1... I will try to get it... "
		InstallSoftwareFromRepo $1
		if [ $? != 0 ];
		then
			ensure_snap_package_managment
			snap install $1
			if [ $? != 0 ];
			then
				ensure_flatpak_package_managment
				flatpack install $1 -y
				if [ $? != 0 ];
				then
					write_error "That install didn't work out so well."
					write_error "Please manually try to add the software since I couldn't do it."
					return 1
				fi
			fi
		fi
		echo "OK Done! Continuing..."
	fi
}












rtd_ppa_checker ()
{
# Description:
# Function to check status of Ubuntu and derivatives' PPA aarchives.
# This function will take one optional argument to toggle the "delete" option. If the delet option
# is requested rtd_ppa_checker will delete any PPA's that are not used (no software is installed from it)
#
# PPA stands for Personal Package Archive. The PPA allows application developers and
# Linux users to create their own repositories to distribute software. With PPA, you can
# easily get newer software version or software that are not available via the official Ubuntu
# repositories.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# rtd_ppa_checker [] [--delete]
#
# End of documentation
	ensure_admin
	for f in /etc/apt/sources.list.d/*.list; do
		grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
			echo "ENTRY: $ENTRY"
			HOST=$(cut -d/ -f3 <<< "$ENTRY")
			if [ "ppa.launchpad.net" = "$HOST" ]; then
				USER=$(cut -d/ -f4 <<< "$ENTRY")
				PPA=$(cut -d/ -f5 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "PPA: ppa:$USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			else
				USER=$(cut -d/ -f3 <<< "$ENTRY")
				PPA=$(cut -d/ -f4 <<< "$ENTRY")
				packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
				echo "REPOSITORY: $USER/$PPA"
				echo "FILENAME: $f"
				echo "$packageCount package(s) installed"

				if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
					sudo rm "$f" && echo "$f deleted"
				fi
			fi
		done
	done
}









rtd_oem_release_upgrade ()
{
# Description: Function to attempt to perform a release upgade on several Linux distributions.
# Supported distributions are: Ubuntu, Pop! OS, Debian, SUSE, and fedora.
# This function does not require any arguments but will respect "interactive". The "interactive"
# parameter will force the function to pause if a supported distribution is not found.
# It will check for a supported distribution and attempt the upgrade if possible.
# If a supported distribution is not detected the function will do nothing.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  (in a script):
#  rtd_oem_release_upgrade [ string ]
#
# [ string ] : interactive
#
# End of Documentation


	ensure_admin
	local set interactive=$1
	unset result
	TMP_DISC_DIR=$(mktemp -d )
		if hostnamectl |grep "Ubuntu" 2>/dev/null ; then
			write_warning "this may take some time, please be patient!"
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Pop!_OS" 2>/dev/null ; then
			write_warning "this may take some time, please be patient!"
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Debian" 2>/dev/null ; then
			write_error "Debian does not provide an upgrade tool between major releases... Please use the manual upgrade method."
			result="Debian does not have an in place upgrade tool. Please edit the /etc/apt/sources.list and use the disd-upgrade option"
			display_result "Release Upgrade Attempt Result: "
		elif hostnamectl |grep "SUSE" 2>/dev/null ; then
			write_warning "This REALLY may take some time, please be patient!"
			cat /etc/os-release
			write_information "these are the current repositories..."
			zypper modifyrepo --enable repo-update
			zypper repos --uri

			SUSE_VER=$($RTD_GUI --title "SUSE Distribution Upgrade Confirmation" --inputbox "Please pick an available Suse version by entering it below. For example type: 15.3  \n You are currently using: \n $(hosnamectl)  "  25 110 "15.3" 3>&1 1>&2 2>&3) ;clear
			[ "${SUSE_VER}" ] || write_error "No verson selected for distribution upgrade -- Only running a regular update then... "

			write_status "Checking if it is possible to upgrade to ${SUSE_VER}"
			if zypper --releasever="${SUSE_VER}" lr -u ; then
				zypper --releasever="${SUSE_VER}" ref
				write_status "Attempting upgrade of system now..."
				zypper --releasever="${SUSE_VER}" dup --force-resolution
				read -p "$ERRMSG: Press  [ ENTER ] to REBOOT:"
				reboot
			else
				write_error "It is not possible to upgrade to Open Suse ${SUSE_VER} since there does not appear to be a release server available for ${SUSE_VER}"
				read -p "$ERRMSG: Press  [ ENTER ] to continue:"
			fi
		elif hostnamectl |grep "fedora" 2>/dev/null ; then
			releasever=$($RTD_GUI --title "Fedora Distribution Upgrade Confirmation" --inputbox "Please enter the Fedora version you want to upgrade to. Please make sure that it has been published. You are currently using: $(hosnamectl)  only numbers are valid" 8 78  3>&1 1>&2 2>&3)
			sudo dnf upgrade --refresh
			sudo dnf install dnf-plugin-system-upgrade
			sudo dnf system-upgrade download --refresh --releasever="${releasever}"
			sudo dnf system-upgrade
			read -p "$ERRMSG: Press  [ ENTER ] to REBOOT:"
			reboot
		else
			[[ "$interactive" == "interactive" ]] && read -p "This option requires the program (do-release-upgrade) (Ubuntu) or OpenSUSE (zypper) on your system. Press [Enter] key to return to menu."
		fi
		return
}












rtd_oem_remove_non_western_latin_fonts ()
{
# Description:  a simple function to remove known
# non-western (latin) fonts from a distribution. Notably, Ubuntu provides too many fonts
# of all kinds by default, even if the user will never need the fonts. However, the fonts
# may cause unexpected font tool behavior and crashes, due to the large number of fonts
# and their features. It is there fore a good Idea to remove these fonts if they are not needed.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#	Simply call this function by stating its name:
# 	rtd_oem_remove_non_western_latin_fonts
#
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation
	ensure_admin
	font_list="fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lklug-sinhala fonts-lohit-guru fonts-guru fonts-nanum fonts-noto-cjk fonts-takao-pgothic fonts-tibetan-machine fonts-guru-extra \
		fonts-lao fonts-sil-padauk fonts-sil-abyssinica fonts-tlwg-* fonts-beng fonts-beng-extra fonts-deva fonts-deva-extra fonts-gubbi fonts-gujr fonts-gujr-extra fonts-kalapi fonts-knda \
		fonts-lohit-* fonts-orya* fonts-pagul fonts-sahadeva fonts-samyak-* fonts-sarai fonts-smc fonts-smc-* fonts-taml fonts-telu fonts-telu-extra"
	echo "Attempting to remove non-western fonts..."
	count=0
	for i in $font_list ; do
		rtd_oem_remove_software $i && (( count++))
	done
	echo "Removed [ $count ] non-western Fonts"
}









rtd_oem_remove_software ()
{
# Description:
# The OEM remove software function will attempt to remove whatever package name given
# as an argument using whatever package system found on the system. This is provided
# for portability and convenience. Currently, this functions will attempt to use
# pkcon (prefferred as it run on many distributions), apt, yum, dnf, and zypper.
# Additional package manager may be added as time allows.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# 	call this function using one argument only for reliability reasons;
#	as per the below example. If thre is a need to remove a large number of
#	packages it is reccommended to use a for loop and call this function,
#	still realizing the benefit of mylti-distribution support.
#
#	rtd_oem_remove_software packagename
#
# If a failure occurs this function will return a non "0" exit code. (1)
# End of documentation
	ensure_admin
	if [[ $(echo $OSTYPE |grep "linux") ]]; then
		echo "Trying to remove package $*"
		if hash dnf 2>/dev/null; then
			dnf -y remove $*
			return $?
		elif hash yum 2>/dev/null; then
			yum -y remove $*
			return $?
		elif hash zypper 2>/dev/null; then
			zypper -y remove $*
			return $?
		elif hash apt 2>/dev/null; then
			apt-get -y remove $* && apt -y autoremove
			return $?
		elif hash pkcon 2>/dev/null; then
			pkcon remove $* -y --autoremove
			return $?
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			return 1
		fi
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		return 1
	else
		echo "Though you can run bash, I have no Idea how to remove software here!"
		return 1
	fi
}










rtd_update_system ()
{
# Description:
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak.
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output.
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage: z
# End of documentation
	ensure_admin
	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.14 (built in)"

	LOGFILE="${LOGFILE:-$0.log}"

	write_status "${PUBLICATION}: Version ${VERSION}"
	write_status "------------------------------------------------------------------"

	write_host --cyan "I am updating software from all channels I can find on the system."
	write_host --cyan "I will update via the native package manager as well as newer formats"
	write_host --cyan "like snap and flatpak ..."
	echo -e " \n"


	log_item ()
	{
		DATE=$(date '+%d/%m/%Y %H:%M:%S');
		echo "$DATE --- : $*" >> "$LOGFILE"
	}


	rtd_software_task ()
	{
		log_item "running rtd_software_task with parameters $*"
		# make some decent display terminal graphics...
		PAD="----------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "Executing $LINE:"\ & "$@" >>"$LOGFILE" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
	}

	if hash dnf 2>/dev/null; then
		rtd_software_task dnf -y upgrade
	elif hash zypper 2>/dev/null; then
		rtd_software_task zypper up -y
	elif hash apt 2>/dev/null; then
		rtd_software_task apt-get update
		UPGRADABLE=$(LANG=C apt-get upgrade -s |grep -P '^\d+ upgraded'|cut -d" " -f1)
		if [ "$UPGRADABLE" -eq 0 ]; then
			write_information "$UPGRADABLE packages that need updates; Skipping update task... "
		else
			write_information "There are $UPGRADABLE packages that need updates..."
			rtd_software_task dpkg --configure -a
			rtd_software_task apt-get upgrade -y
			rtd_software_task apt-get full-upgrade -y
			rtd_software_task apt-get --purge autoremove -y
			rtd_software_task apt-get clean
		fi
	elif hash pkcon 2>/dev/null; then
		if [[ $1 == simple ]]; then disp_option="--plain" ; fi
		pkcon -y refresh $disp_option
		pkcon -y update --autoremove $disp_option
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		return 1
	fi

	write_status "updating snaps if snap is present on the system..."
	if hash snap 2>/dev/null; then
		rtd_software_task snap refresh
	else
		write_warning "--- snap software is not present on this system... skipping..."
	fi

	write_status "updating flatpacks if flatpack is present on system..."
	if hash flatpak 2>/dev/null; then
		rtd_software_task flatpak update --user --noninteractive -y
		rtd_software_task flatpak update --system --noninteractive -y
	else
		write_warning "--- flatpak software is not present on this system... skipping..."
	fi
}









add_software_task ()
{
# Description: Display executed task and echo ON/NOK based on sucess
# This function is created to reduce the terminal output and create a more poliched output of
# the tasks executed. This function has no idea shat it is doing, it will simply call the function
# it was asked to call or execute the command ist was asked to, and echo OK or FAIL based on the
# return code.
# Globals:
# Arguments: function or command to execute
# Outputs:
# Returns:
# Usage: add_software_task function_name
# End of documentation

	PAD="---------------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	#display_spinner start
	echo -ne "Task: ${LINE/recipe_/}:" & $@ &>${_LOGFILE:-"/var/log/rtd/$($FUNCNAME[0])$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup.log"} && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
	#display_spinner stop
}









dl ()
{
# Description: Function by Nate Beaken to ease and make consistent the downloading of the non repository
# packages and install them. It can install any package that Package Kit can manage (available on most Linux dists)
# It expects one parameter: the complete URL to download from.
# Globals:
# Arguments: URL to rpm or deb file and possibly some other formats of distributions that use package kit.
# Outputs:
# Depends:
#           - Functions; write_error, check_dependencies
#           - Software: wget, pkcon
# Returns: 0/1
# Usage:
# 	   dl https://download.teamviewer.com/download/linux/teamviewer_amd64.deb
# 	   dl https://download.teamviewer.com/download/linux/teamviewer.x86_64.rpm
# End of documentation

	download_url="$1"
	fetch_file () { wget -P {_OEM_DIR}/cache "${download_url}"  ; }

	echo  "${FUNCNAME[0]}: getting package ${download_url}..."
	if hash wget ; then
		fetch_file
	elif check_dependencies wget ; then
		fetch_file
	else
		write_error "Unable to download requested file:  ${download_url}..."
		write_error "Please check if wget is available since this is used to download files..."
		write_error "You may also want to check that the internet is reachable from this computer?"
		return 1
	fi

	echo "${FUNCNAME[0]}: Installing package $(basename ${download_url}) ..."
	if hash pkcon ; then
		pkcon install-local -y {_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	else
		check_dependencies packagekit-tools
		pkcon install-local -y {_OEM_DIR}/cache/"$(basename "${download_url}")"
		return $?
	fi
}









SofwareManagmentAvailabilityCHK ()
{
# Description: Function to check and see if the system software managment is available. In some cases
# the sofware managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation
	echo ""
	echo -e $YELLOW"--- Checking if software maintenance system is available:" $ENDCOLOR
	i=0
	tput sc
	while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
		case $(($i % 4)) in
			0 ) j="-" ;;
			1 ) j="\\" ;;
			2 ) j="|" ;;
			3 ) j="/" ;;
		esac
		tput rc
		echo -en "\r[$j] Waiting for other software managers to finish..."\


		sleep 5
		((i=i+1))
	done
}





display_software_installation_choices_gtk ()
{
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACKTITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

	DisplayMenu=( zenity  --list  --timeout 120 --width=800 --height=600 --text "$_BACKTITLE" --checklist  --column "ON/OFF" --column "Select Software to add:" --separator " " )
	SoftwareList=$(list_loaded_software_functions --nonum)
	MenuOptions=($(for i in $SoftwareList ; do echo -e "${zstatus:=false} ${i}" ; done ))

	declare -A choices
	choices=$("${DisplayMenu[@]}" "${MenuOptions[@]}" )

	for choice in ${choices}
		do
		# call each chosen software install (by function) & add recepie (removed for display purposes)
		add_software_task recipe_${choice}
	done
}





display_software_installation_choices_term ()
{
# Function to display the software install otions. All software option are listed in
# the _rtd_recipes recipe book. Leveraging all the useful function in _rtd_library.
# NOTE: adding a function in _rtd_recipes named "recipes_* ()" will automaticall populete
# the menu displayed to the user.
#
# Globals: ${_BACKTITLE} ${zstatus}
# Dependencies: _rtd_recipes
# Arguments: None
# Outputs: interactive screen
# Returns: 0/1 last command executed.
# Usage:  simply call the function by its name.
# Arguments: none
#
#
# End of documentation

echo Under construction...
	# DisplayMenu=( dialog --menu --text "$_BACKTITLE" $WIDTH $HEIGHT )
	# SoftwareList=$(list_loaded_software_functions --nonum)
	# count=1
	# MenuOptions=($(for i in $SoftwareList ; do echo -e "${count} ${i}" ;  count=$((count + 1)); done ))

	# declare -A choices
	# choices=$("${DisplayMenu[@]}" "${MenuOptions[@]}" )

	# for choice in ${choices}
	# 	do
	# 	# call each chosen software install (by function) & add recepie (removed for display purposes)
	# 	add_software_task recipe_${choice}
	# done
}







rtd_server_setup_choices_services ()
{
# Description: Function to display server installation options. This will install software that is usefull
# on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
#
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...
	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Server Role Options Menu" --separate-output --checklist "Please Select a role for this system below:" 22 85 16 )
	options=(1 "Install Minecraft Server" off
		 2 "Install LAMP Server" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)	write_status "Installing and configuring Minecraft server, launcher, auto startup, etc... "
					if java --version ; then
						echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
					else
						check_dependencies default-jre
					fi

					if cat /home/$SUDO_USER/minecraft-server |grep SLS ; then
						write_information "minecraft server launcher is already present..."
					else
						generate_minecraft_server_launcher "/home/$SUDO_USER/minecraft-server"
					fi

					if cat /etc/systemd/system/getty@tty1.service.d/override.conf |grep tangarora ; then
						write_information "Service auto login already setup..."
					else
						write_warning "Minecraft server startup is not enabled: seting up now..."
						toggle_oem_auto_login
					fi

					if cat /home/$SUDO_USER/.bashrc |grep minecraft-server ; then
						write_information "minecraft server is ready to start on login"
					else
						sudo -H -u tangarora bash -c 'echo ~/minecraft-server >> ~/.bashrc'
					fi

					dialog --backtitle "$BRANDING" --title "Install Status" --yesno "I am done installing Minecraft Server. What Do you want to run the Minecraft Server now? " "$HEIGHT" "$WIDTH"
					exit_status=$?

					case $exit_status in
						0 ) sudo -H -u tangarora bash -c 'bash ~/minecraft-server' ;;
						1 ) return ;;
					esac
				;;
				2)  for i in apache2 mysql-server php libapache2-mod-php php-mcrypt php-mysql phpmyadmin nodejs ; do InstallSoftwareFromRepo $i ; done ;;
			esac
		done
}








rtd_server_setup_choices_productivity ()
{
# Description: Function to display terminal software installation options. This will install
# software that is usefull on a server, or a remote system only accessible via SSH.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:  simply call the function by its name.
#
# Arguments: none
#
# NOTE:
# This may be a good usecase if you happen to be in an opressed geographic locaiton where
# your only option is to ssh to a remote server and access email and web that way.
# Perfomance in these cases may be very poor over the internet (as for example with
# the great firewall of China). In Such a case it would be usefull to have the good
# old CLI software! :)
# End of documentation

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "Terminal Productivity Software Options" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on
		2 "Alpine email client" on
		3 "Vim text editor" on
		4 "Finch multi protocol chat" on
		5 "Word Grinder word precessor" on
		6 "Spreadsheet Calculator" on
		7 "TPP Presentation Program" on
		8 "Midnight Commander file manager (Norton Commander)" on
		9 "Cmus Music Player" on
		10 "Byobu Terminal Window Manger" on
		11 "W3M web Browser" on
		12 "LYNX Web Browser" on
		13 "Mega.nz command line tools (Mega-CMD)" on
		14 "Rtorrent torrent download software" off
		15 "Install the OpenVpn client Software" on
		16 "Games: Freesweep mine sweep game" on
		17 "Games: Bastet Tetris Game" on
		18 "OEM Customizatons" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			case $choice in
				1) for i in htop powertop iftop monit nethogs bmon darkstat mtr glances nmap multitail ncdu ; do InstallSoftwareFromRepo $i ; done ;;
				2)  InstallSoftwareFromRepo alpine ;;
				3)  InstallSoftwareFromRepo vim ;;
				4)  InstallSoftwareFromRepo finch ;;
				5)  InstallSoftwareFromRepo wordgrinder ;;
				6)  InstallSoftwareFromRepo sc ;;
				7)  InstallSoftwareFromRepo tpp ;;
				8)  InstallSoftwareFromRepo mc ;;
				9)  InstallSoftwareFromRepo cmus ;;
				10) InstallSoftwareFromRepo byobu ;;
				11) InstallSoftwareFromRepo w3m ;;
				12) InstallSoftwareFromRepo lynx ;;
				13) Single_Install_MEGA.nz_Encrypted_Cloud_Storage megacmd ;;
				14) InstallSoftwareFromRepo rtorrent ;;
				15) InstallSoftwareFromRepo openvpn ;;
				16) InstallSoftwareFromRepo freesweep ;;
				17) InstallSoftwareFromRepo bastet ;;
				18) echo 'export PS1="\[\033[35m\]\t\[\033[m\]-\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ "' >> ~/.bashrc ;;
			esac
		done
}






rtd_setup_choices_server ()
{
# Description: Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :)
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...

	cmd=(dialog --backtitle "${TLA} OEM System Configuraton Menu" --title "System Software Chooser" --menu "It looks like this is a server to me. Please Select a role for htis system below:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  )
	options=(1 "Select terminal apps to install (i.e. vim, Lynx, Midnight Commander etc.)"
		 2 "Select Role (i.e. SSH server, Minecraft Server, etc.)"
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
			do
			    case $choice in
				1)  rtd_server_setup_choices_productivity ;;
				2)  rtd_server_setup_choices_services ;;
			esac
		done
}








rtd_setup_choices_for_preseed () {
# Description: Function to write out a Debian preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
# functoin_name          location        config          function
# make_preseed_cfg       /path/to/file   ssh-server      Minecraft
# End of documentation

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=$3
	: "${SRVFUNC:-Tasks}"
	: "${PRESEED:=preseed.cfg}"
	PRESEED_FILE="$SAVETO/$PRESEED"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$1/$PRESEED"

	cmd=("$RTD_GUI" --backtitle "$BRANDING" --title "VM Auto Answer Setup Questions" --separate-output --checklist "Please preconfiguration components below. You will be prompted to manually add information for sections that you de-select:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options" on
		 2 "rtd_oem_preseed_cfg_Unattended_Install" on
		 3 "rtd_oem_preseed_cfg_Network_Configuration" on
		 4 "rtd_oem_preseed_cfg_Prevent_Install_On_USB" on
		 5 "rtd_oem_cfg_Account_Setup" on
		 6 "rtd_oem_preseed_cfg_Localization" on
		 7 "rtd_oem_preseed_cfg_EFI" on
		 8 "rtd_oem_preseed_cfg_GRUB_Bootloader_Installation" on
		 9 "rtd_oem_preseed_cfg_Disk_Layout" on
		 10 "rtd_oem_preseed_cfg_Package_Selection" on
		 11 "rtd_oem_preseed_cfg_Addon_${SRVFUNC}" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO" ;;
			2) rtd_oem_preseed_cfg_Unattended_Install "$SAVETO" ;;
			3) rtd_oem_preseed_cfg_Network_Configuration "$SAVETO" ;;
			4) rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO" ;;
			5) rtd_oem_cfg_Account_Setup "$SAVETO" ;;
			6) rtd_oem_preseed_cfg_Localization "$SAVETO" ;;
			7) rtd_oem_preseed_cfg_EFI "$SAVETO" ;;
			8) rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO" ;;
			9) rtd_oem_preseed_cfg_Disk_Layout "$SAVETO" ;;
			10) rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG" ;;
			11) rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO" ;;
			esac
		done
}






































#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::           Function Section               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----
#            . _..::__:  ,-"-"._        |7       ,     _,.__
#    _.___ _ _<_>`!(._`.`-.    /         _._     `_ ,_/  '  '-._.---.-.__
# >.{     " " `-==,',._\{  \  / {)      / _ ">_,-' `                mt-2_
#   \_.:--.       `._ )`^-. "'       , [_/(                       __,/-'
#  '"'     \         "    _L        oD_,--'                )     /. (|
#           |           ,'          _)_.\\._<> 6              _,' /  '
#           `.         /           [_/_'` `"(                <'}  )
#            \\    .-. )           /   `-'"..' `:.#          _)  '
#     `        \  (  `(           /         `:\  > \  ,-^.  /' '
#               `._,   ""         |           \`'   \|   ?_)  {\
#                  `=.---.        `._._       ,'     "`  |' ,- '.
#                    |    `-._         |     /          `:`<_|h--._
#                    (        >        .     | ,          `=.__.`-'\
#                     `.     /         |     |{|              ,-.,\     .
#                      |   ,'           \   / `'            ,"     \
#                      |  /              |_'                |  __  /
#                      | |                                  '-'  `-'   \.
#                      |/                                         "    /
#                      \.                                             '

#                       ,/            ______._.--._ _..---.---------._
#      ,-----"-..?----_/ )      __,-'"             "                  (
# -.._(                  `-----'                                       `-
# -----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----


#  ----------------------------------------------------------------
# __     ___      _               _   __  __            _     _
# \ \   / (_)_ __| |_ _   _  __ _| | |  \/  | __ _  ___| |__ (_)_ __   ___
#  \ \ / /| | '__| __| | | |/ _` | | | |\/| |/ _` |/ __| '_ \| | '_ \ / _ \
#   \ V / | | |  | |_| |_| | (_| | | | |  | | (_| | (__| | | | | | | |  __/
#    \_/  |_|_|   \__|\__,_|\__,_|_| |_|  |_|\__,_|\___|_| |_|_|_| |_|\___|

#  __  __                                              _
# |  \/  | __ _ _ __   __ _  __ _ _ __ ___   ___ _ __ | |_
# | |\/| |/ _` | '_ \ / _` |/ _` | '_ ` _ \ / _ \ '_ \| __|
# | |  | | (_| | | | | (_| | (_| | | | | | |  __/ | | | |_
# |_|  |_|\__,_|_| |_|\__,_|\__, |_| |_| |_|\___|_| |_|\__|
#                           |___/
#  ----------------------------------------------------------------











test_iso_boot_media ()
{
# Description: Function to test a created ISO file by booting it in a temporary VM using QEMU.
# This function requires one argument or one variable (TARGET_ISO) to be set; since it needs
# to now what media to test.
#
# QEMU is a free and open-source emulator and virtualizer that
# can perform hardware virtualization. QEMU is a hosted virtual machine monitor: it emulates
# the machine's processor through dynamic binary translation and provides a set of different
# hardware and device models for the machine, enabling it to run a variety of
# guest operating systems.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
# test_iso_boot_media /path/to/media
# 	OR
# TARGET_ISO=/path/to/media
# test_iso_boot_media
#
# End of Documentation
	: "${TARGET_ISO:-"${1}"}"
	if [[ -z "${TARGET_ISO}" ]]; then
		rtd_oem_pause 1 "${FUNCNAME[0]}: requires one argument OR one variable set (TARGET_ISO)"
		return 1
	else
		if ($RTD_GUI --title "BOOT Media Testing" --yesno "\n Would you like to test your boot media ${TARGET_ISO} to see if it works?" 10 80); then
			write_information "TESTING ${TARGET_ISO}."
			check_dependencies qemu-kvm
			: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
			: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
			: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"

			${BIN_QEMU_IMG} create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2" 10G
			${BIN_QEMU_SYSTEM_X86_64} -smp 2 -enable-kvm -m 4G --cdrom "$PUT_ISO_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).iso" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2"
		else
			echo "User selected No, exit status was $?."
		fi
	fi
}







make_kvm_virtual_machine_now_from_fedora_org ()
{
# Description: Function to create a Fedora KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals: ${FedoraVersion} ${PRESEED_FILE}
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install
	do
		write_status "${count}	- Verifying dependencies ( ${i} )..."
		check_dependencies $i &>/dev/null
		count=$((count + 1))
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	FedoraVersion=${FedoraVersion:-"35"}

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"

        # create image and run installer
        "${BIN_VIRT_INSTALL}" --connect qemu:///system --name VDI_fedora_"${CONFIG}"_"${RANDOM}" \
                --vcpus "${2:-2}" \
                --memory "${3:-2048}" \
                --network "$VIRT_NET" \
                --disk size="${4:-40}" \
		--os-variant="fedora30" \
                --initrd-inject="${PRESEED_FILE}" \
		--location="http://www.nic.funet.fi/pub/Linux/INSTALL/fedora/linux/releases/${FedoraVersion}/Everything/x86_64/os/" \
		--extra-args "inst.ks=file:/$(basename $PRESEED_FILE)" \
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )


}







make_kvm_virtual_machine_now_from_opensuse_com ()
{
# Description: Function to create a SUSE KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install
	do
		write_status "${count}	- Verifying dependencies (${i})..."
		check_dependencies $i &>/dev/null
		count=$((count + 1))
	done
	write_information "Using sintallation control file: ${PRESEED_FILE}"

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
	: ${source_url:="${_SUSE_LEAP_SOURCE}"}

	_summary_message="The virtual machine (Debian_${vm_usecase}_${SRVFUNC}_${CONFIG}_${RANDOM}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${source_url} \n
	ðŸŒŽ - ${vm_kernel} \n
	ðŸŒŽ - ${vm_initrd} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${3:-2048} \n
	âœ… - CPU's: ${2:-2} \n
	âœ… - Disk Size: ${4:-40} \n You may attach to this server and see the progress at IP: $(hostname -I))"

	# create image and run installer
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name VDI_SUSE_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "$VIRT_NET" \
		--disk size="${4:-40}" \
		--os-variant=opensusetumbleweed \
		--initrd-inject="${PRESEED_FILE}" \
		--location='https://download.opensuse.org/distribution/openSUSE-current/repo/oss/' \
		--extra-args "AutoYaST=file:///$(basename $PRESEED_FILE)"   \
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
}








make_kvm_virtual_machine_now_from_debian_org ()
{
# Description: Function to create a Debian KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation

	write_status "${FUNCNAME[0]}:"
	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install
	do
		write_status "ðŸ§© ${count}	- Verifying dependencies ( ${i} )..."
		check_dependencies $i &>/dev/null
		count=$((count + 1))
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet, and set variables.
	: "${bin_virt_install:=$(type -p virt-install)}"
	: "${PRESEED_FILE:="$(make_preseed_cfg $( mktemp -d ) ssh-server )"}"
	if echo "${CONFIG:="ssh-server"}" |grep server &>/dev/null ; then : "${SRVorVDI="server"}" ; else : "${SRVorVDI="desktop"}" ; fi


	case "${SRVorVDI}" in
		server | Server )
				: "${vm_kernel="${_DEBIAN_FRONTEND_DEFAULT_KERNEL}"}"
				: "${vm_initrd="${_DEBIAN_FRONTEND_DEFAULT_INITRD}"}"
				: "${ui_diplay_style="theme=light"}"
				: "${vm_usecase="Server"}"
				;;
		desktop | Desktop )
				: "${vm_kernel="${_DEBIAN_FRONTEND_GTK_KERNEL}"}"
				: "${vm_initrd="${_DEBIAN_FRONTEND_GTK_INITRD}"}"
				: "${ui_diplay_style="theme=dark"}"
				: "${vm_usecase="VDI"}"
				;;
		*)	;;
	esac

	write_status "ðŸ”Ž 	- Discovering what the appropriate VM net interface is (default or br'0 - n')"
	: ${virt_net="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"}

	_summary_message="The virtual machine (Debian_${vm_usecase}_${SRVFUNC}_${CONFIG}_${RANDOM}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${source_url} \n
	ðŸŒŽ - ${vm_kernel} \n
	ðŸŒŽ - ${vm_initrd} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${3:-2048} \n
	âœ… - CPU's: ${2:-2} \n
	âœ… - Disk Size: ${4:-40} \n You may attach to this server and see the progress at IP: $(hostname -I))"


	# create image and run installer
	"${bin_virt_install}" --name Debian_${vm_usecase}_"${SRVFUNC}"_"${CONFIG}"_"${RANDOM}" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${virt_net}" \
		--location="${_DEBIAN_SOURCE_URL}" \
		--disk size="${4:-40}" \
		--os-variant="${1:-debian10}" \
		--video "virtio" --channel "spicevmc" \
		--initrd-inject="${PRESEED_FILE}" \
		--install kernel="${vm_kernel}",initrd="${vm_initrd}" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE) ${ui_diplay_style}" \
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	unset vm_kernel
	unset vm_initrd
	unset vm_usecase
	unset ui_diplay_style
	cleanup_and_finish nomessage
}







make_kvm_virtual_machine_now_from_ubuntu_com ()
{
# Description: Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual machine disk images.
# QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
#
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# Example:
#                                              vmtype    CPU  RAM   DISK
# make_kvm_virtual_machine_now_from_ubuntu_com debian10  4    2048  40
#
# If complete flexibility is needed simply use the virt-install binary and directly write the arguments.
# Alternatively; edit the function with new defaults that suit the needs.
# End of Documentation
	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install wget
	do
		write_status "ðŸ§© ${count}	- Verifying dependencies ( ${i} )..."
		check_dependencies ${i} &>/dev/null
		count=$((count + 1))
	done

	write_information "ðŸ”Ž Retreive list of available Ubuntu versions..."
	all_ubuntu_lts_versions=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	tgt_ubuntu_ver=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below.
	Long Term Support Versions to choose from are the following ðŸ‘: ${all_ubuntu_lts_versions[*]} You may also enter an inbetween release version
	by typing its release number below as well. If you are not sure just let me choose for you... \n ${ubuntulogo} "  25 110 "${all_ubuntu_lts_versions[-1]}" 3>&1 1>&2 2>&3)
	case $? in
		"$DIALOG_CANCEL") return ;;
		"$DIALOG_ESC") return ;;
	esac
	clear

	[ "$tgt_ubuntu_ver" ] || tgt_ubuntu_ver=${all_ubuntu_lts_versions[-1]}

	# Detect and set variables for key programs
	: ${bin_virt_install:=$(type -p virt-install)}
	: ${virt_net="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"}
	: ${ubuntu_iso_url=$(rtd_oem_find_live_release $tgt_ubuntu_ver ubuntu live)}
	: ${iso_filename:="$(basename $ubuntu_iso_url)"}
	: ${permanent_download_dir:="/var/lib/libvirt/boot/"}

	write_status "Checking if $iso_filename already downloaded..."
	iso=$(find "$permanent_download_dir" -name "$iso_filename")
	if [ ! -e "$iso" ]; then
		write_warning "$iso_filename is not in cache, downloading..."
		wget -nc $ubuntu_iso_url -P "$permanent_download_dir" || read -p "Failure to download ISO file"
		iso="$permanent_download_dir/$iso_filename"
	fi

	_summary_message="The virtual machine (Debian_${vm_usecase}_${SRVFUNC}_${CONFIG}_${RANDOM}) \n
	ðŸ“‹ - Using the instructions in PRESEED: ${PRESEED_FILE} \n
	ðŸ”§ - And Using this source for the packages and files to download: \n
	ðŸŒŽ - ${source_url} \n
	ðŸŒŽ - ${vm_kernel} \n
	ðŸŒŽ - ${vm_initrd} \n
	âœ… - Using the network: ${virt_net} \n
	âœ… - Memory: ${3:-2048} \n
	âœ… - CPU's: ${2:-2} \n
	âœ… - Disk Size: ${4:-40} \n You may attach to this server and see the progress at IP: $(hostname -I))"

	"${bin_virt_install}" --name VDI_${CONFIG}-${tgt_ubuntu_ver}-${RANDOM} \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${virt_net}" \
		--disk size="${4:-30}" \
		--os-variant="${1:-ubuntu21.10}" \
		--video "virtio" --channel "spicevmc" \
		--location="${iso},kernel=casper/vmlinuz,initrd=casper/initrd" \
		--extra-args="ks=file:$(basename $PRESEED_FILE) auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us \
		netcfg/get_hostname=${CONFIG}${tgt_ubuntu_ver} console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US \
		localechooser/supported-locales=en_US.UTF-8 ubiquity/use_nonfree=true boot=casper automatic-ubiquity quiet splash noprompt noshell" \
		--initrd-inject="$PRESEED_FILE" \
		--initrd-inject="$( dirname ${PRESEED_FILE})/ks.cfg" \
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )

	unset tgt_ubuntu_ver
	unset iso_filename
	unset ubuntu_iso_url
}







gen_cloudconfig (){
CloudConfig=$( mktemp )
PRESEED_FILE=${CloudConfig}

cat >> ${CloudConfig} <<-'EOF'
#cloud-config
autoinstall:
  debconf-selections: |
    debconf-set partman-auto/disk $BOOTDEV;\
    debconf-set grub-installer/bootdev $BOOTDEV;
    tasksel tasksel/first multiselect ubuntu-desktop
    in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd  ; \
    in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
    in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
    cp /*.cfg /target/opt/rtd/ ;\
    umount -l /media || echo "Empty" ; \
    eject || true; \
    echo "------  initial Setup Complete!  ------"
    ubiquity ubiquity/success_command string \
  identity:
    hostname: RTD-Client
    password: $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
    realname: RTD User
    username: tangarora
  keyboard:
    layout: se
  locale: en_US.UTF-8
  network:
    ethernets:
      manual: {}
    version: 2
  version: 1
EOF

}









make_kvm_virtual_machine_now_from_microsoft ()
{
# Description:
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on. In the future
# scripting will be added to allow for acting on remote machines directly...
# At this time this functio takes no arguments but will prompt for what it needs if it is not available.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
#
#
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation
	write_status "Lookup specific binaries: use full path since they may just have been added and not in PATH yet."
	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install mtools
	do
		write_status "${count}	- Verifying dependencies ( ${i} )..."
		check_dependencies $i &>/dev/null
		count=$((count + 1))
	done

	: ${BIN_VIRT_INSTALL:="$(type -p virt-install)"}
	: ${CONFIG:="Workstation"}
	: ${WindowsMedia:="/var/lib/libvirt/boot/Win10_English_x64.iso"}
	: ${WindowsInstructions:="/var/lib/libvirt/boot/win$(date +%Y-%m-%d-%H-%M-%S-%s).img"}
	: ${VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"}
	: ${AutoUnattend="/tmp/autounattend.xml"}
	: ${PostTasks="/tmp/rtd-me-sh.cmd"}

	write_information "Ensuring that install media is available to build a Windows VM..."
	if [[ ! -e "${WindowsMedia}" ]]; then
		if ( $RTD_GUI --backtitle "..$BRANDING" --title "Windows Install Media Needed" \
			--no-button "NO: Just Cancel" \
			--yes-button "OK: I am done upploading" \
			--yesno "Windows install media was not found where expected ${WindowsMedia%/*} \n Please place a copy of it in /home/$SUDO_USER/Downloads/ and press [ OK ] \n Please name it Win**something**.iso" 20 90 );
		then
			if $(ls /home/$SUDO_USER/Downloads/Win*.iso >/dev/null ) ; then
				mv -v /home/$SUDO_USER/Downloads/Win*.iso ${WindowsMedia}
			else
				write_error "Could not find the file: /home/$SUDO_USER/Downloads/Win*.iso "
				rtd_oem_pause 1
				return
			fi
		else
			return
		fi
	fi

	write_information "Ensuring that instructions are available to build a Windows VM..."
	if [[ ! -e "${WindowsInstructions}" ]]; then
		write_information "Generate Windows Instruction media..."
		mkfs.msdos -C ${WindowsInstructions} 1440 || rtd_oem_pause 1

		write_information "Generate installations instructions for Windows..."
		generate_autounattend_xml "${AutoUnattend}" || rtd_oem_pause 1

		write_information "Generate post install bootstrap script..."
		generate_rtd_me_sh_cmd ${PostTasks}
		mcopy -i ${WindowsInstructions} ${PostTasks} ::/ || rtd_oem_pause 1
		mcopy -i ${WindowsInstructions} ${AutoUnattend} ::/ || rtd_oem_pause 1
	fi

	write_status "Creating and starting Virtual machine... "
	"${BIN_VIRT_INSTALL}" --connect qemu:///system --name VDI_Windows10_"${CONFIG}"_"${RANDOM}" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${VIRT_NET}" \
		--video qxl \
		--disk size="${4:-40}" \
		--os-type windows \
		--os-variant=win10 \
		--cdrom "${WindowsMedia}" \
		--disk "${WindowsInstructions}",device=floppy \
		--livecd \
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
}







make_kvm_virtual_machine_now_from_iso ()
{
# Description: Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# Globals:
# Arguments: None
# Outputs:
# Returns:
# Usage:
# End of Documentation
	gen_cloudconfig
	RTD_GUI=dialog
	count=1
	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86 virt-install
	do
		write_status "${count}	- Verifying dependencies ( ${i} )..."
		check_dependencies $i &>/dev/null
		count=$((count + 1))
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"
	: "${TARGET_ISO:="/var/lib/libvirt/boot/ubuntu-21.04-desktop-amd64.iso"}"

	#Verify ISO presesnce
		if [[ ! -f "$TARGET_ISO" ]]; then
			$RTD_GUI --backtitle "${BRANDING:-"rtd"}" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
			clear
		fi
	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
	_summary_message="
	--vcpus ${2:-"2"}
	--memory ${3:-"2048"}
	--network ${VIRT_NET}
	--disk size=${4:-"30"}
	--os-variant=${1:-"ubuntu20.04"}
	--location=${TARGET_ISO}
	--cdrom=${TARGET_ISO}
	--initrd-inject=$PRESEED_FILE
	--extra-args ks=file:/$(basename $PRESEED_FILE)"



	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Ubuntu_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "${VIRT_NET}" \
		--disk size="${4:-30}" \
		--os-variant="${1:-debian10}" \
		--cdrom="${TARGET_ISO}" \
		--cloud-init meta-data=
		--noautoconsole && $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "${_summary_message}" 22 85 \
	|| ( read -p "ðŸ’¥ - An ERROR has occurred. Please press [ENTER] to continue..." && return 1 )
}





backup_running_vm ()
{
# Description:
# Function to back up all running virtual machines on the host it is being run on.
# This function should be called from within this script and does not require any
# arguments passed.
#
# Globals: ${VM_BACKUP_TARGET} (defaults to /mnt/vmdsk/VM_BACKUP)
# Arguments: None
# Outputs: Backups of running vm's.
# Returns:
# Usage:
#
# backup_running_vm
#
# End of documentation

	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=$(date +%Y-%m-%d.%H:%M:%S)
		LOG="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=$(virsh list --all | grep $DOMAIN | awk '{print $3}')
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if [[ ! -d $BACKUPFOLDER ]] ; then
				$RTD_GUI
			fi
			mkdir -p "$BACKUPFOLDER"
			TARGETS="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $3}')"
			IMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain "$DOMAIN" --name "backup-$DOMAIN" --no-metadata --atomic --disk-only "$DISKSPEC" >> "$LOG"
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > "$LOG"
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > "$LOG"
				rsync -apvz --inplace "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				else
				echo "Backup does not exist, creating a full sparse copy" > "$LOG"
				rsync -apvz --sparse "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				fi
			done

			BACKUPIMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			for TARGET in $TARGETS; do
				if virsh blockcommit "$DOMAIN" "$TARGET" --active --pivot >> "$LOG"; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > "$LOG"
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > "$LOG"
				rm -f "$BACKUP"
				fi
			done

			virsh dumpxml "$DOMAIN" > "$BACKUPFOLDER"/"$DOMAIN".xml
			echo "-----------WORKER END $DOMAIN-----------" >> "$LOG"
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> "$LOG"
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}












#                        ---
#                     -        --
#                 --( /     \ )XXXXXXXXXXXXX
#             --XXX(   O   O  )XXXXXXXXXXXXXXX-
#            /XXX(       U     )        XXXXXXX\
#          /XXXXX(              )--   XXXXXXXXXXX\
#         /XXXXX/ (      O     )   XXXXXX   \XXXXX\
#         XXXXX/   /            XXXXXX   \   \XXXXX----
#         XXXXXX  /          XXXXXX         \  ----  -
# ---     XXX  /          XXXXXX      \           ---
#   --  --  /      /\  XXXXXX            /     ---=
#     -        /    XXXXXX              '--- XXXXXX
#       --\/XXX\ XXXXXX                      /XXXXX
#         \XXXXXXXXX                        /XXXXX/
#          \XXXXXX                         /XXXXX/
#            \XXXXX--  /                -- XXXX/
#             --XXXXXXX---------------  XXXXX--
#                \XXXXXXXXXXXXXXXXXXXXXXXX-
#                  --XXXXXXXXXXXXXXXXXX-

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Internal Confgiration Repository      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.













generate_rtd_me_sh_cmd ()
{
# Description:
# Generates an unattended install instruction file for Windows systems.
# As documentation at microsoft for CMD shell scripting is limited see the below suggestion:
# Reference https://www.amazon.com/Windows-Shell-Scripting-Timothy-Hill/dp/1578700477
# for more information.
#
# Globals:
# Arguments: [directory path]
# Outputs: one rtd-me.cmd.sh flobal bootsrap script
# Returns: na
# Usage:
#
# generate_rtd_me_sh_cmd /location/to/place/fiile
#
#
# NOTE: This file is generated from this library to limit the dependecies on external downloads.
# End of documentation

	cat > $1 <<-'EOF'
	#!/bin/bash
	cls
	:<<"::CMDLITERAL"
	@ECHO OFF
	GOTO :CMDSCRIPT
	::CMDLITERAL

	echo	[internal]	-	RTD System System Managment Bootstrap Script      -	[internal]
	#::
	#::
	#:: 						Shell Script Section
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
	#:: Version:	1.06
	#::
	#::
	#:: Purpose: 	The purpose of the script is to decide what scripts to download based
	#::          	on the host OS found; works with both Windows, MAC and Linux systems.
	#::		The focus of this script is to be compatible enough that it could be run on any
	#::		system and compete it's job. In this case it is simply to identify the OS
	#::		and get the appropriate script files to run on the system in question;
	#::		In its original configuration this bootstrap script was used to install and
	#::		configure software appropriate for the system in question. It accomplishes this
	#::		by using the idiosyncrasies of the default scripting languages found in
	#::		the most popular operating systems around *NIX (MAC, Linux, BSD etc.) and
	#::		CMD (Windows NT, 2000, 2003, XP, Vista, 8, and 10).
	#::
	#::
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#

	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are
	# set here. There should be no reason to change any of this.

	# Ensure administrative privileges.
	[ "$UID" -eq 0 ] || echo -e $YELLOW "This script needs administrative access..." $ENDCOLOR
	[ "$UID" -eq 0 ] || exec sudo DISPLAY=$DISPLAY bash "$0" "$@"

	# Put a convenient link to the logs where logs are normally found...
	# capture the 3 first letters as org TLA (Three Letter Acronym)
	export _SCRIPTNAME=$(basename $0)
	export _TLA=${_SCRIPTNAME:0:3}
	export _LOG_DIR=/var/log/${_TLA}
	mkdir -p ${_LOG_DIR}

	# Set the GIT profile name to be used if not set elsewhere:
	export _GIT_PROFILE="${_GIT_PROFILE:-vonschutter}"

	# Location of base administrative scripts and command-lets to get.
	_src_url=https://github.com/${_GIT_PROFILE}/${_TLA^^}-Setup.git

	# Determine log file names for this session
	export _ERRLOGFILE=${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup-error.log
	export _LOGFILE${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup.log
	export _STATUSLOG=${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup-status.log


	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Execute tasks                   ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	#:: Given that Bash or other Shell environment has been detected and the POSIX chell portion of this script is executed,
	#:: the second stage script must be downloaded from an online location. Depending on the distribution of OS
	#:: there are different methods available to get and run remote files.
	#::
	#:: Table of evaluating family of OS and executing the appropriate action fiven the OS found.
	#:: In this case it is easier to manage a straight table than a for loop or array:


	if [[ "$OSTYPE" == "linux-gnu" ]]; then
		echo "Linux OS Found: Attempting to get instructions for Linux..."
		echo executing $0 >> ${_LOGFILE}
		if ! hash git &>> ${_LOGFILE} ; then
			for i in apt yum dnf zypper ; do $i -y install git | tee ${_LOGFILE} ; done
		fi
		git clone ${_src_url} /opt/${_TLA} | tee ${_LOGFILE}
			if [ $? -eq 0 ]
			then
				echo "Instructions successfully retrieved..."
				source ${_TLA}/core/_${_TLA}_library
				oem_register_all_tools
				ln -s ${_LOG_DIR} ${_OEM_DIR}/log
				bash ${_CORE_DIR}/rtd-oem-linux-config.sh "$@" | tee ${_LOGFILE}
			else
				echo "Failed to retrieve instructions correctly! "
				echo "Suggestion: check write permission in "/opt" or internet connectivity."
				exit 1
			fi
		exit $?
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		echo "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		echo "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		echo "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
	else
	echo "This system is Unknown to this script"
	fi
	exit $?


	# -----------------------------------------------------------------------------------------------------------------------
	# Anything after this exit statment below will be dangerous and meaningless
	# command syntax to POSIX based systems...
	# Make sure to exit no matter what...
	exit $?
	:CMDSCRIPT
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	@echo off
	echo			-	RTD System System Managment Bootstrap Script      -
	::
	::
	::					Windows CMD Shell Script Section
	::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	:INIT
		:::::::::::::::::::::::::::::::::::::::::::::::::::
		::	Script startup components; tasks that always
		::	need to be done when the initializes.
		::
		ECHO Welcome to %COMSPEC%
		ECHO This is a windows script!
		:: setlocal &  pushd %~dp0
		:: %debug%

	:SETINGS
		::::::::::::::::::::::::::::::::::::::::::::::::::::::
		::  ***             Settings               ***      ::
		::::::::::::::::::::::::::::::::::::::::::::::::::::::
		::
		set temp=c:\rtd\temp
		::if not exit %temp% md %temp%
		::set _LOGDIR=c:\rtd\log
		::if not exist %_LOGDIR% md %_OGDIR%
		set _STAGE2LOC=https://raw.githubusercontent.com/vonschutter/RTD-Setup/main/core/
		set _STAGE2FILE=rtd-oem-win10-config.ps1
		echo Stage 2 file is located at:
		echo %_STAGE2LOC%\%_STAGE2FILE%


	:GetInterestingThigsToDoOnThisSystem
		:: Given that Microsoft Windows has been detected and the CMD chell portion of this script is executed,
		:: the second stage script must be downloaded from an online location. Depending on the version of windows
		:: there are different methods available to get and run remote files. All versions of windows do not neccesarily
		:: support powershell scripting. Therefore the base of this activity is coded in simple command CMD.EXE shell scripting
		::
		:: Table of evaluating verson of windos and calling the appropriate action fiven the version of windows found.
		:: In this case it is easier to manage a straight table than a for loop or array:

		:: DOS Based versions of Windows:
		:: ver | find "4.0" > nul && goto CMD1 	rem Windows 95
		:: ver | find "4.10" > nul && goto CMD1 rem Windows 98
		:: ver | find "4.90" > nul && goto CMD1	rem Windows ME

		:: Windows 32 and 64 Bit versions:
		ver | find "NT 4.0" > nul && call :CMD1 Windows NT 4.0
		ver | find "5.0" > nul && call :CMD1 Windows 2000
		ver | find "5.1" > nul && call :CMD1 Windows XP
		ver | find "5.2" > nul && call :CMD1 Windows XP 64 Bit
		ver | find "6.0" > nul && call :DispErr Vista is not supported!!!
		ver | find "6.1" > nul && call :PS1 Windows 7
		ver | find "6.2" > nul && call :PS2 Windows 8
		ver | find "6.3" > nul && call :PS2 Windows 8
		ver | find "6.3" > nul && call :PS2 Windows 8
		ver | find "10.0" > nul && call :PS2 Windows 10

		:: Windows Server OS Versions:
		ver | find "NT 6.2" > nul && call :PS2 Windows Server 2012
		ver | find "NT 6.3" > nul && call :PS2 Windows Server 2012 R2
		ver | find "NT 10.0" > nul && call :PS2 Windows Server 2016 and up...

		goto end


	:PS1
		:: Procedure to get the second stage in Windows 7. Windows 7, by default has a different version of
		:: PowerShell installed. Therefore a slightly different syntax must be used.
		:: get stage 2 and run it...
		echo Found %*
		echo Fetching %_STAGE2FILE%...
		echo Please wait...
		powershell -Command "(New-Object Net.WebClient).DownloadFile('%_STAGE2LOC%\%_STAGE2FILE%', '%_STAGE2FILE%')"
		powershell -ExecutionPolicy UnRestricted -File .\%_STAGE2FILE%
		goto end


	:PS2
		:: Procedure to get the second stage configuration script in all version of windows after 7.
		:: These version of windows have a more modern version of PowerShell.
		:: get stage 2 and run it...
		echo Found %*
		echo Fetching %_STAGE2FILE%...
		echo Please wait...
		powershell -Command "[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;Invoke-WebRequest %_STAGE2LOC%\%_STAGE2FILE% -OutFile %_STAGE2FILE%"
		powershell -ExecutionPolicy UnRestricted -File .\%_STAGE2FILE%
		goto end




	:CMD1
		:: Pre windows 7 instruction go here (except vista)...
		:: Windows NT, XP, and 2000 etc. do not have powershell and must find a different way to
		:: fetch a script over the internet and execute it.

		echo Detected %* ...
		echo executing PRE Windows 7 instructions...

		goto end




	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	::::::::::::::                                          ::::::::::::::::::::::
	::::::::::::::            ERROR handling Below          ::::::::::::::::::::::
	::::::::::::::                                          ::::::::::::::::::::::
	::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



	:DispErr
		set _ERRMSG=%*
		@title %0 -- !!%_ERRMSG%!!
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo ::                            Message                                          ::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo.
		echo.
		echo        %_ERRMSG%
		echo        Presently I know what to do for Linux, and Windows 7 and beyond...
		echo.
		echo ::                                                                             ::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
		echo :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	goto eof



	:end
	:eof

	EOF
}






generate_autounattend_xml ()
{
# Description:
# Generates an unattended install instruction file for Windows systems.
# Reference https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/automate-windows-setup
# for more information.
#
# Globals:
# Arguments: [directory path]
# Outputs: one autounattend.cfg file
# Returns: na
# Usage:
#
# generate_autounattend_xml /location/to/place/fiile
#
# End of documentation

	cat > $1 <<-'EOF'
	<?xml version="1.0" encoding="utf-8"?>
	<unattend xmlns="urn:schemas-microsoft-com:unattend">
	<settings pass="windowsPE">
	<component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SetupUILanguage>
	<UILanguage>en-US</UILanguage>
	</SetupUILanguage>
	<InputLocale>0409:00000409</InputLocale>
	<SystemLocale>en-US</SystemLocale>
	<UILanguage>en-US</UILanguage>
	<UILanguageFallback>en-US</UILanguageFallback>
	<UserLocale>en-US</UserLocale>
	</component>
	<component name="Microsoft-Windows-International-Core-WinPE" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SetupUILanguage>
	<UILanguage>en-US</UILanguage>
	</SetupUILanguage>
	<InputLocale>0409:00000409</InputLocale>
	<SystemLocale>en-US</SystemLocale>
	<UILanguage>en-US</UILanguage>
	<UILanguageFallback>en-US</UILanguageFallback>
	<UserLocale>en-US</UserLocale>
	</component>
	<component name="Microsoft-Windows-Setup" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<DiskConfiguration>
	<Disk wcm:action="add">
	<CreatePartitions>
	<CreatePartition wcm:action="add">
	<Order>1</Order>
	<Type>Primary</Type>
	<Size>100</Size>
	</CreatePartition>
	<CreatePartition wcm:action="add">
	<Extend>true</Extend>
	<Order>2</Order>
	<Type>Primary</Type>
	</CreatePartition>
	</CreatePartitions>
	<ModifyPartitions>
	<ModifyPartition wcm:action="add">
	<Active>true</Active>
	<Format>NTFS</Format>
	<Label>System Reserved</Label>
	<Order>1</Order>
	<PartitionID>1</PartitionID>
	<TypeID>0x27</TypeID>
	</ModifyPartition>
	<ModifyPartition wcm:action="add">
	<Active>true</Active>
	<Format>NTFS</Format>
	<Label>OS</Label>
	<Letter>C</Letter>
	<Order>2</Order>
	<PartitionID>2</PartitionID>
	</ModifyPartition>
	</ModifyPartitions>
	<DiskID>0</DiskID>
	<WillWipeDisk>true</WillWipeDisk>
	</Disk>
	</DiskConfiguration>
	<ImageInstall>
	<OSImage>
	<InstallTo>
	<DiskID>0</DiskID>
	<PartitionID>2</PartitionID>
	</InstallTo>
	<InstallToAvailablePartition>false</InstallToAvailablePartition>
	</OSImage>
	</ImageInstall>
	<UserData>
	<AcceptEula>true</AcceptEula>
	<FullName>tangarora</FullName>
	<Organization></Organization>
	<ProductKey>
	<Key>W269N-WFGWX-YVC9B-4J6C9-T83GX</Key>
	</ProductKey>
	</UserData>
	</component>
	<component name="Microsoft-Windows-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<DiskConfiguration>
	<Disk wcm:action="add">
	<CreatePartitions>
	<CreatePartition wcm:action="add">
	<Order>1</Order>
	<Type>Primary</Type>
	<Size>100</Size>
	</CreatePartition>
	<CreatePartition wcm:action="add">
	<Extend>true</Extend>
	<Order>2</Order>
	<Type>Primary</Type>
	</CreatePartition>
	</CreatePartitions>
	<ModifyPartitions>
	<ModifyPartition wcm:action="add">
	<Active>true</Active>
	<Format>NTFS</Format>
	<Label>System Reserved</Label>
	<Order>1</Order>
	<PartitionID>1</PartitionID>
	<TypeID>0x27</TypeID>
	</ModifyPartition>
	<ModifyPartition wcm:action="add">
	<Active>true</Active>
	<Format>NTFS</Format>
	<Label>OS</Label>
	<Letter>C</Letter>
	<Order>2</Order>
	<PartitionID>2</PartitionID>
	</ModifyPartition>
	</ModifyPartitions>
	<DiskID>0</DiskID>
	<WillWipeDisk>true</WillWipeDisk>
	</Disk>
	</DiskConfiguration>
	<ImageInstall>
	<OSImage>
	<InstallTo>
	<DiskID>0</DiskID>
	<PartitionID>2</PartitionID>
	</InstallTo>
	<InstallToAvailablePartition>false</InstallToAvailablePartition>
	</OSImage>
	</ImageInstall>
	<UserData>
	<AcceptEula>true</AcceptEula>
	<FullName>tangarora</FullName>
	<Organization></Organization>
	<ProductKey>
	<Key>W269N-WFGWX-YVC9B-4J6C9-T83GX</Key>
	</ProductKey>
	</UserData>
	</component>
	</settings>
	<settings pass="offlineServicing">
	<component name="Microsoft-Windows-LUA-Settings" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<EnableLUA>false</EnableLUA>
	</component>
	</settings>
	<settings pass="offlineServicing">
	<component name="Microsoft-Windows-LUA-Settings" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<EnableLUA>false</EnableLUA>
	</component>
	</settings>
	<settings pass="generalize">
	<component name="Microsoft-Windows-Security-SPP" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SkipRearm>1</SkipRearm>
	</component>
	</settings>
	<settings pass="generalize">
	<component name="Microsoft-Windows-Security-SPP" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SkipRearm>1</SkipRearm>
	</component>
	</settings>
	<settings pass="specialize">
	<component name="Microsoft-Windows-International-Core" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<InputLocale>0409:00000409</InputLocale>
	<SystemLocale>en-US</SystemLocale>
	<UILanguage>en-US</UILanguage>
	<UILanguageFallback>en-US</UILanguageFallback>
	<UserLocale>en-US</UserLocale>
	</component>
	<component name="Microsoft-Windows-International-Core" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<InputLocale>0409:00000409</InputLocale>
	<SystemLocale>en-US</SystemLocale>
	<UILanguage>en-US</UILanguage>
	<UILanguageFallback>en-US</UILanguageFallback>
	<UserLocale>en-US</UserLocale>
	</component>
	<component name="Microsoft-Windows-Security-SPP-UX" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SkipAutoActivation>true</SkipAutoActivation>
	</component>
	<component name="Microsoft-Windows-Security-SPP-UX" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<SkipAutoActivation>true</SkipAutoActivation>
	</component>
	<component name="Microsoft-Windows-SQMApi" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<CEIPEnabled>0</CEIPEnabled>
	</component>
	<component name="Microsoft-Windows-SQMApi" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<CEIPEnabled>0</CEIPEnabled>
	</component>
	<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<ComputerName>-PC</ComputerName>
	<ProductKey>W269N-WFGWX-YVC9B-4J6C9-T83GX</ProductKey>
	</component>
	<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<ComputerName>-PC</ComputerName>
	<ProductKey>W269N-WFGWX-YVC9B-4J6C9-T83GX</ProductKey>
	</component>
	</settings>
	<settings pass="oobeSystem">
	<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="x86" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<AutoLogon>
	<Password>
	<Value>letmein1234</Value>
	<PlainText>true</PlainText>
	</Password>
	<Enabled>true</Enabled>
	<Username>tangarora</Username>
	</AutoLogon>
	<OOBE>
	<HideEULAPage>true</HideEULAPage>
	<HideOEMRegistrationScreen>true</HideOEMRegistrationScreen>
	<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
	<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
	<NetworkLocation>Work</NetworkLocation>
	<SkipUserOOBE>true</SkipUserOOBE>
	<SkipMachineOOBE>true</SkipMachineOOBE>
	<ProtectYourPC>1</ProtectYourPC>
	</OOBE>
	<UserAccounts>
	<LocalAccounts>
	<LocalAccount wcm:action="add">
	<Password>
	<Value>letmein1234</Value>
	<PlainText>true</PlainText>
	</Password>
	<Description>admin</Description>
	<DisplayName>tangarora</DisplayName>
	<Group>Administrators</Group>
	<Name>tangarora</Name>
	</LocalAccount>
	</LocalAccounts>
	</UserAccounts>
	<RegisteredOrganization></RegisteredOrganization>
	<RegisteredOwner>tangarora</RegisteredOwner>
	<DisableAutoDaylightTimeSet>false</DisableAutoDaylightTimeSet>
	<FirstLogonCommands>
	<SynchronousCommand wcm:action="add">
	<Description>Control Panel View</Description>
	<Order>1</Order>
	<CommandLine>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v StartupPage /t REG_DWORD /d 1 /f</CommandLine>
	<RequiresUserInput>true</RequiresUserInput>
	</SynchronousCommand>
	<SynchronousCommand wcm:action="add">
	<Order>2</Order>
	<Description>Control Panel Icon Size</Description>
	<RequiresUserInput>false</RequiresUserInput>
	<CommandLine>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v AllItemsIconView /t REG_DWORD /d 1 /f</CommandLine>
	</SynchronousCommand>
	<SynchronousCommand wcm:action="add">
	<Order>3</Order>
	<RequiresUserInput>false</RequiresUserInput>
	<CommandLine>cmd /C wmic useraccount where name="tangarora" set PasswordExpires=false</CommandLine>
	<Description>Password Never Expires</Description>
	</SynchronousCommand>
	</FirstLogonCommands>
	<TimeZone>W. Europe Standard Time</TimeZone>
	</component>
	<component name="Microsoft-Windows-Shell-Setup" processorArchitecture="amd64" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" xmlns:wcm="http://schemas.microsoft.com/WMIConfig/2002/State" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<AutoLogon>
	<Password>
	<Value>letmein1234</Value>
	<PlainText>true</PlainText>
	</Password>
	<Enabled>true</Enabled>
	<Username>tangarora</Username>
	</AutoLogon>
	<OOBE>
	<HideEULAPage>true</HideEULAPage>
	<HideOEMRegistrationScreen>true</HideOEMRegistrationScreen>
	<HideOnlineAccountScreens>true</HideOnlineAccountScreens>
	<HideWirelessSetupInOOBE>true</HideWirelessSetupInOOBE>
	<NetworkLocation>Work</NetworkLocation>
	<SkipUserOOBE>true</SkipUserOOBE>
	<SkipMachineOOBE>true</SkipMachineOOBE>
	<ProtectYourPC>1</ProtectYourPC>
	</OOBE>
	<UserAccounts>
	<LocalAccounts>
	<LocalAccount wcm:action="add">
	<Password>
	<Value>letmein1234</Value>
	<PlainText>true</PlainText>
	</Password>
	<Description>admin</Description>
	<DisplayName>tangarora</DisplayName>
	<Group>Administrators</Group>
	<Name>tangarora</Name>
	</LocalAccount>
	</LocalAccounts>
	</UserAccounts>
	<RegisteredOrganization></RegisteredOrganization>
	<RegisteredOwner>tangarora</RegisteredOwner>
	<DisableAutoDaylightTimeSet>false</DisableAutoDaylightTimeSet>
	<FirstLogonCommands>
		<SynchronousCommand wcm:action="add">
		<Description>Control Panel View</Description>
		<Order>1</Order>
		<CommandLine>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v StartupPage /t REG_DWORD /d 1 /f</CommandLine>
		<RequiresUserInput>true</RequiresUserInput>
		</SynchronousCommand>

		<SynchronousCommand wcm:action="add">
		<Order>2</Order>
		<Description>Control Panel Icon Size</Description>
		<RequiresUserInput>false</RequiresUserInput>
		<CommandLine>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ControlPanel" /v AllItemsIconView /t REG_DWORD /d 1 /f</CommandLine>
		</SynchronousCommand>

		<SynchronousCommand wcm:action="add">
		<Order>3</Order>
		<RequiresUserInput>false</RequiresUserInput>
		<CommandLine>cmd /C wmic useraccount where name="tangarora" set PasswordExpires=false</CommandLine>
		<Description>Password Never Expires</Description>
		</SynchronousCommand>

		<SynchronousCommand wcm:action="add">
		<Order>4</Order>
		<RequiresUserInput>true</RequiresUserInput>
		<CommandLine>"a:\rtd-me.sh.cmd"</CommandLine>
		<Description>Run Software install</Description>
		</SynchronousCommand>
	</FirstLogonCommands>
	<TimeZone>W. Europe Standard Time</TimeZone>
	</component>
	</settings>
	</unattend>
	EOF
}






rtd_oem_cloud-config_ubuntu_cfg_KS_CFG_Options ()
{
# Description: generates a preseed section [Ubuntu only] (ks.cfg)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: instruction for Ubuntu's convoluted support for both preseed and kickstart files.
# Usage: rtd_oem_cloud-config_ubuntu_cfg_KS_CFG_Options "directory"
# End of documentation
	cat > $1/autoinstall.yaml <<-'EOF'
#cloud-config
autoinstall:
  version: 1
  identity:
    hostname: ubuntu-server
    password: "$6$exDY1mhS4KUYCE/2$zmn9ToZwTKLhCw.b4/b.ZRTIZM30JZ4QrOQ2aOXJ8yk96xpcCof0kxKwuX1kqLG/ygbJ1f8wxED22bTL4F46P0"
    username: tangarora
		# # --------------------------------------------------- #

EOF
}






rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ()
{
# Description: generates a preseed section [Ubuntu only] (ks.cfg)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: instruction for Ubuntu's convoluted support for both preseed and kickstart files.
# Usage: rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "directory"
# End of documentation
	cat $1/preseed.cfg >$1/ks.cfg
}









rtd_oem_preseed_cfg_Unattended_Install ()
{
# Description: generates a preseed section [Unattended Installation] (d-i debconf string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: suppress any questions.
# Usage: rtd_oem_preseed_cfg_Unattended_Install "directory"
# End of documentation
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Unattended Installation
		# --------------------------------------------------- #
		# Simple instruction to tell the debian installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		# End of documentation
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# Install the KDE/Gnome oem-config frontend
		# --------------------------------------------------- #
		# Instructions to tell the installer what front end to display.
		# The default is to use a console based display with a light
		# Weight GUI. This is equally informative and stable. It is the
		# prefferred option for unseen deployments, for example in a
		# cloud service like AWS or AZURE. However, if the installation
		# will be seen by end users it may be preferable to show a modern
		# GUI that users will recognize and not be intimidated by.
		#
		# d-i     oem-config-udeb/frontend        string kde
		d-i     oem-config-udeb/frontend        string gnome
		# --------------------------------------------------- #
	EOF
}











rtd_oem_preseed_cfg_Network_Configuration ()
{
# Description: generates a preseed section [Network configuration] (d-i netcfg string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: wired + wireless configuration
# Usage: rtd_oem_preseed_cfg_Network_Configuration "directory"
# End of documentation
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp.
		# The RTD default prefferred config is to rely on DHCP,
		# and for wireless networks (systems with only wireless cards)
		# default to an SSID named "loader" and the guest wpa string
		# "letmein1234". This allows supported systems to be
		# installed directly over WiFi with no user input.
		# End of documentation
		d-i netcfg/choose_interface select manual
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string letmein1234

		# --------------------------------------------------- #

	EOF
}








rtd_oem_cfg_Account_Setup ()
{
# Description: generates a preseed section [Account setup] (d-i passwd string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: user accounts
# Usage: rtd_oem_cfg_Account_Setup "directory"
# End of documentation
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		# End of documentation
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string tangarora
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #

	EOF
}








rtd_oem_preseed_cfg_Prevent_Install_On_USB ()
{
# Description: generates a preseed section [Avoid USB install] (d-i early_command string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: EFI + Legacy ability to boot
# Usage: rtd_oem_preseed_cfg_Prevent_Install_On_USB "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string [ "$(ls -A /tmp)" ] && umount -l /media || echo "Empty" ;
		# End of documentation
		d-i partman/early_command string \
			USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
			BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
			debconf-set partman-auto/disk $BOOTDEV;\
			debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #

	EOF
}







rtd_oem_preseed_cfg_EFI ()
{
# Description: generates a preseed section [EFI] (d-i partman-efi string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: EFI + Legacy ability to boot
# Usage: rtd_oem_preseed_cfg_EFI "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition is a partition on a data storage device.
		# UEFI provides backward compatibility with legacy systems by reserving the first block (sector) of
		# the partition for compatibility code, effectively creating a legacy boot sector. On legacy BIOS-based
		# systems, the first sector of a partition is loaded into memory and execution is transferred to this code.
		# Here we tell setup to install EFI boot setup if possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# End of documentation
		# --------------------------------------------------- #

	EOF
}







rtd_oem_preseed_cfg_Localization ()
{
# Description: generates a preseed section [Localization] (d-i localechooser string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns: time-zone, keyboard-layout, locale
# Usage: rtd_oem_preseed_cfg_Localization "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to
		# the MUI in Microsoft environments.
		# End of documentation
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, se_SE.UTF-8
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #



		# --------------------------------------------------- #
		# Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select se
		d-i keyboard-configuration/layoutcode string se
		d-i debian-installer/keymap select se
		d-i keymap select se
		d-i console-setup/layoutcode string se
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# Clock and time zone setup
		# --------------------------------------------------- #
		d-i clock-setup/utc boolean true
		d-i time/zone string Etc/UTC
		d-i clock-setup/ntp boolean true
		d-i clock-setup/ntp-server string ntp.ubuntu.com

		# --------------------------------------------------- #

		EOF
}






rtd_oem_preseed_cfg_GRUB_Bootloader_Installation ()
{
# Description: generates a preseed section [Grub] (d-i grub-installer string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns:
# Usage: rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it also finds some other
		# OS, which is more likely to allow the newly installed Linux OS to boot without issue.
		# End of documentation
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #

	EOF
}







rtd_oem_preseed_cfg_Disk_Layout ()
{
# Description: generates a preseed section [Partitioning] (d-i partman string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns:
# Usage: rtd_oem_preseed_cfg_Disk_Layout "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		#   Disk layout (default encrypted disk)
		# --------------------------------------------------- #
		#
		# Set option to encrypt the hard disk:
		# By default the harddisk will be encrypted to pretect data
		# and will need to be unlocked with a password when the
		# system is booted. In addition a default is prefferred
		# where the swap space is set to 200% of RAM so that
		# hibernate can be supported.
		# End of documentation

		d-i partman-auto/method string crypto
		d-i partman-crypto/passphrase password letmein1234
		d-i partman-crypto/passphrase-again password letmein1234
		d-i partman-auto-crypto/erase_disks boolean false
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-auto-lvm/new_vg_name string crypt
		#d-i partman-auto/choose_recipe select root-encrypted
		d-i partman-auto/expert_recipe string                   \
		multi-cnx ::                                            \
			538 538 1075 free                               \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			3500 3500 3500 ext3                             \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
			.                                               \
			200% 25000 200% linux-swap                      \
			 	$lvmok{ } lv_name{ swap }               \
			 	in_vg { crypt }                         \
			 	$primary{ }                             \
			 	method{ swap } format{ }                \
			.                                               \
			500 1000 1000000000 ext4                        \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.

		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true

		# --------------------------------------------------- #

	EOF
}









rtd_oem_preseed_cfg_Package_Selection ()
{
# Description: generates a preseed section [Package selection] (d-i pkgsel string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns:
# Usage: rtd_oem_preseed_cfg_Package_Selection "directory"
# End of documentation

	cat >> $1/$PRESEED <<-EOF

		# --------------------------------------------------- #
		# Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like kde-desktop or
		# as individual packages. Only one "pkgsel/include" string will be used though!
		# remembder to fit all the packages you want on one line.
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop, lubuntu-desktop, ubuntu-mate-desktop
		# desktop,  gnome-desktop, kde-desktop, cinnamon-desktop, mate-desktop,
		# lxde-desktop, web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the line with a
		# relevant chice of debian role using "sed" or similar.
		# End of documentation
		tasksel tasksel/first multiselect $2
		d-i pkgsel/include string openssh-server dialog virt-what curl wget spice-vdagent git

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select safe-upgrade
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the systemâ€™s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you donâ€™t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #

	EOF
}








rtd_oem_preseed_cfg_Addon_MinecraftServer()
{
# Description: generates a preseed section [Addon Tasks] (late command string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns:
# Usage: rtd_oem_preseed_cfg_Addon_MinecraftServer "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Addon Tasks for Minecraft Server
		# --------------------------------------------------- #
		# End of documentation
		d-i preseed/late_command string \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
		 	cp /*.cfg /target/opt/rtd/ ; \
			in-target mkdir -p "/etc/systemd/system/getty@tty1.service.d" ; \
			in-target echo "[Service]" > "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "ExecStart=-/sbin/agetty --noissue --autologin tangarora "%I" "$TERM"" >> "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "Type=idle" >> "/etc/systemd/system/getty@tty1.service.d/override.conf" ; \
			in-target echo "bash /home/tangarora/minecraft.server" >> /home/tangarora/.bashrc ; \
			in-target wget https://github.com/vonschutter/RTD-Minecraft-Server-Manager/raw/master/minecraft-server -O /home/tangarora/minecraft.server ; \
			in-target chmod 777 /home/tangarora/minecraft.server ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			reboot; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #
	EOF
}







rtd_oem_preseed_cfg_Addon_Tasks ()
{
# Description: generates a preseed section [Addon Tasks] (late command string)
# Globals: $PRESEED (filename)
# Arguments: Where to place file (directory)
# Outputs: one preseed file section
# Returns:
# Usage: rtd_oem_preseed_cfg_Addon_Tasks "directory"
# End of documentation

	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Default preseed Addon Tasks
		# --------------------------------------------------- #
		# for Debian to work (ignored by Ubuntu)...
		d-i preseed/late_command string \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
		 	cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# for Ubuntu to work (ignored by Debian)...
		ubiquity ubiquity/success_command string \
			in-target apt-get -y install git ; \
			in-target git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd ; \
			in-target /usr/bin/chmod 755 /opt/rtd/core/rtd* ; \
			in-target /bin/bash /opt/rtd/core/rtd-oem-enable-config.sh ; \
		 	cp /*.cfg /target/opt/rtd/ ; \
			umount -l /media || echo "Empty" ; \
			eject || true; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to gracefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #

	EOF
}










generate_minecraft_server_launcher ()
{
# Description: Generates preseed file to build a minecraft server.
# Globals:
# Arguments: [file location]
# Outputs: one preseed file
# Returns: error level of last command
# Usage: generate_minecraft_server_launcher /tmp/preseed.cfg
# End of documentation

cat >> $1 <<-'MINECRAFT_EOF'
	#!/bin/bash
	#::             RTD System System Managment Script
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author:     RTD Library
	#:: Version:	1.03
	#::
	#::
	#:: Purpose: The purpose of the script is to perform managment tasks on Linux systems
	#::
	#:: This is a script that will start Minecraft Server on an Ubuntu or Debian (Ubuntu) based server. It will start
	#:: multiple panes using "byobu", and start the server etc there...
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are
	# set here. There should be no reason to change any of this to setup and
	# get a working Minecraft server on Ubuntu. However, if you have updated scripts
	# and need to download yours from someplace else you only need to change these
	# setings.

	# Your Minecraft version (this is a preference only), script will always
	# get the latest Minecraft if it does not find a local server.
	MINECRAFT_VERSION=Latest

	# Your local Minecraft directory.
	MINECRAFT_HOME=~/bin/minecraft.server/Minecraft.$MINECRAFT_VERSION
	MINECRAFT_JAR=server.jar





	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Functions                ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#

	function check_dependencies (){
		# Simple function to check if sofware is available and take action
		# if it is not. Software name must match command to envoke it.
		#---------------------------------------------------------------
		echo "Checking for script dependencies and install if not there..."
		#---------------------------------------------------------------
		if hash "$1" 2>/dev/null; then
			echo "I found that $1 is present on this system... thankyou for that! "
		else
			echo "You seem to have no $1... I will try to get it... "
			install_software "$1"
			if [ $? != 0 ];
			then
				echo "That install didn't work out so well."
				echo "Please manually try to add the software since I couldn't do it."
				exit
			fi
			echo "OK Done! Continuing..."
		fi
	}

	function install_software (){
		# Simple function to help installing software on several linux distributions
		# Should work on Fedora, SUSE, RedHat, Ubuntu, Debian etc. unless the naming
		# convention of the software package is different between distributions.
		if hash pkcon 2>/dev/null; then
			sudo pkcon -y  install "$@"
		elif hash yum 2>/dev/null; then
			sudo yum -y  install "$@"
		elif hash zypper 2>/dev/null; then
			sudo zypper install -y "$@"
		elif hash apt-get 2>/dev/null; then
			export DEBIAN_FRONTEND=noninteractive
			sudo apt-get -y -qq --allow-change-held-packages --ignore-missing install "$@"
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			_cleanup
			exit 1
		fi
	}

	function setup_minecraft_root (){
		# Setup and initiate the location of the mincraft server.
		# For us i likes to live in /home/$USER/bin/minecraft.server/Minecraft.$VERSION
		# This tests if the script files are available and downloades them if not.
		mkdir -p $MINECRAFT_HOME

		for i in start.sh announce.py server.properties eula.txt
		do
			if [ ! -f "$MINECRAFT_HOME/$i" ]; then
			$i $MINECRAFT_HOME
			fi
		done

		if [ ! -f "$MINECRAFT_HOME/$MINECRAFT_JAR" ]; then
			minecraft_update
		fi
	}


	function run_minecraft_server_manager (){

		# Start byobu multi screen app...
		byobu new-session -d -s $USER

		# status screen
		byobu rename-window -t $USER:0 'Minecraft Server Manager'
		byobu send-keys "bash $MINECRAFT_HOME/start.sh" C-m

		# Create new pane vertically and display htop
		byobu split-window -v
		byobu send-keys "htop " C-m

		# Split the "htop" window in 2, and start spedometer there.
		byobu split-window -h
		byobu send-keys "speedometer -r $NETINT  -t $NETINT" C-m

		# Create new window...
		byobu new-window -t $USER:1 -n 'Anouncing on Network (Press F4 to switch between windows)'
		byobu send-keys "python3 $MINECRAFT_HOME/announce.py" C-m

		# Set default window as the dev split plane
		byobu select-window -t $USER:0
		byobu-tmux select-pane -t 0

		# Attach to the session you just created
		byobu attach-session -t $USER
	}


	function check_java (){
		~/bin/java/bin/java --version >/dev/null
		if [ $? -eq 0 ]; then
			echo "java of some version is present. I respect your choice... and will try to run! --- OK!"
		else
			echo Java is now present where expected... will now download:
			wget https://download.oracle.com/java/19/latest/jdk-19_linux-x64_bin.tar.gz
			mkdir ~/bin/java && tar xzvf jdk-19_linux-x64_bin.tar.gz --directory ~/bin/java/ --strip 1
			#check_dependencies default-jre
		fi
	}


	function find_active_newtork_interface (){
		# Detect the name of the active network interface.
		NETINT=$(ip addr | awk '/state UP/ {print $2}' |grep -v "br*" |grep -v "wlp*" | head --bytes -2 )
		echo "Active network interface is: $NETINT"
		export NETINT
	}


	function minecraft_update() {
		# Get minecraft version publication file and get the latest server URL
		# This is an unneccessarily complicated way by Mojang!
		cd $MINECRAFT_HOME || { echo "Failure change to Minecraft folder. Is it there?"; exit 1; }
		wget -q -O $MINECRAFT_HOME/versions --no-check-certificate https://launchermeta.mojang.com/mc/game/version_manifest.json
		JSONVERSION=$(cat versions | python3 -c "exec(\"import json,sys\nobj=json.load(sys.stdin)\nversion=obj['latest']['release']\nfor v in obj['versions']:\n   if v['id']==version:\n    print(v['url'])\")")
		wget -q -O $MINECRAFT_HOME/versions --no-check-certificate $JSONVERSION
		MC_SERVER_URL=$(cat versions | python3 -c 'import json,sys;obj=json.load(sys.stdin);print(obj["downloads"]["server"]["url"])')
		rm $MINECRAFT_HOME/versions

		# Download the latest minecraft vesrion and check if it is the same as the one installed
		wget -q -O $MINECRAFT_HOME/minecraft_server.jar.update --no-check-certificate $MC_SERVER_URL
		if [ -f $MINECRAFT_HOME/minecraft_server.jar.update ] ; then
			if diff $MINECRAFT_HOME/$MINECRAFT_JAR $MINECRAFT_HOME/minecraft_server.jar.update >/dev/null ; then
				dialog --title 'Minecraft Update' --msgbox "You are already running the latest version of $MINECRAFT_JAR." 0 0
		else
			mv $MINECRAFT_JAR $MINECRAFT_JAR.previous
			mv $MINECRAFT_HOME/minecraft_server.jar.update $MINECRAFT_HOME/$MINECRAFT_JAR
			dialog --title 'Minecraft Update' --msgbox "Minecraft successfully updated." 0 0
		fi
		else
			dialog --title 'Minecraft Update' --msgbox "Minecraft update could not be downloaded." 0 0
			echo
		fi
	}


	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::    Script internal config repository     ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# This section contains content to written out to several configuration
	# files and external scripts.


	announce.py () {
		cat >> $1/announce.py <<-'EOF'
	#!/bin/python3
	#              RTD System System Managment Script
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :: Author:     generated by minecraft.server
	# :: Version 1.02
	# ::
	# ::
	# :: Purpose: The purpose of the script is to:
	# ::          1 - Broadcast service availability to the local network.
	# ::              This script is used to broadcast the minecraft server on the
	# ::              same machine (see "servers"). You may have as many minecraft
	# ::              servers running and broadcast as you like.
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	import socket
	import time
	import sys
	import os
	import urllib.request

	servers = [
	["Local Network - Minecraft Server", 25565],
	]

	BROADCAST_IP = "255.255.255.255"
	BROADCAST_PORT = 4445

	sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

	print("Broadcasting Minecraft servers to LAN on: " + os.environ['NETINT'])
	print("Local IP adress: ")
	print((([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith("127.")] or [[(s.connect(("8.8.8.8", 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1]]) + ["no IP found"])[0])

	print("External IP address visible on the internet: ")
	external_ip = urllib.request.urlopen('https://ident.me').read().decode('utf8')
	print(external_ip)

	while True:
	for server in servers:
		msg = "[MOTD]%s[/MOTD][AD]%d[/AD]" % (server[0], server[1])
		encode = str.encode(msg)
		sock.sendto(encode, (BROADCAST_IP, BROADCAST_PORT))
	time.sleep(3)
		EOF
	}


	start.sh () {
		cat >> $1/start.sh <<-'EOF'
	#!/bin/bash
	#::             RTD System System Managment Script
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#:: Author:     generated by minecraft.server
	#:: Version 1.00
	#::
	#::
	#:: Purpose: The purpose of the script is to:
	#::          1 - Launch Minecraft
	#::          2 - Check that Minecraft runs for at least one minute
	#::          3 - If Minecraft crashes or quits after one minute, restart Minecraft
	#::
	#::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	pushd $(dirname "$0")

	MC_SERVER_NAME=`cat server.properties |grep "motd=.*" `
	export $MC_SERVER_NAME

	while true; do

	start_epoch=$(date +%s)
	echo Starting Minecraft server $MC_SERVER_NAME ....
	~/bin/java/bin/java -Xmx2048M -Xms2048M -jar $(dirname "$0")/server.jar noggui broadcast

	# Abort if the application exited too quickly
	duration=$(( $(date +%s) - $start_epoch ))
	if [[ "$duration" < 60 ]]; then
		echo "Program exited too quickly! Aborting Minecraft Launcher...."
		exit
	fi

	done

	exit
		EOF
	}


	server.properties () {
		cat >> $1/server.properties <<-'EOF'
	# Minecraft server properties
	# generated by minecraft.server
	broadcast-rcon-to-ops=true
	view-distance=6
	max-build-height=256
	server-ip=
	rcon.port=25575
	level-seed=
	allow-nether=true
	gamemode=survival
	enable-command-block=true
	server-port=25565
	enable-rcon=false
	enable-query=true
	op-permission-level=3
	prevent-proxy-connections=false
	generator-settings=
	resource-pack=
	player-idle-timeout=0
	level-name=world
	rcon.password=
	motd=\u00A7d CuteWorld
	query.port=25565
	force-gamemode=true
	debug=false
	hardcore=false
	white-list=false
	broadcast-console-to-ops=true
	pvp=true
	spawn-npcs=true
	spawn-animals=true
	generate-structures=true
	snooper-enabled=false
	difficulty=normal
	network-compression-threshold=256
	level-type=default
	max-tick-time=-1
	spawn-monsters=true
	enforce-whitelist=false
	max-players=10
	use-native-transport=true
	spawn-protection=16
	resource-pack-sha1=
	online-mode=true
	allow-flight=false
	max-world-size=29999984
		EOF
	}

	eula.txt () {
		cat >> $1/eula.txt <<-'EOF'
	#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://account.mojang.com/documents/minecraft_eula).
	#Sun Feb 26 16:57:58 CET 2017
	eula=true
		EOF
	}


	# File write template. Takes one argument "where to put the file"
	filetowrite.txt () {
		cat >> $1/filetowrite.txt <<-'EOF'

		EOF
	}

	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Executive                ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


	# Check that the software components of this script are available.
	# iff they are not, attempt to install them.
	for i in byobu speedometer htop python3 dialog
	do
		check_dependencies $i
	done

	if echo "$@" | grep "update" ;then
		dialog --title "Update to latest Minecraft?"  --yesno "You have requested that I try to get the latest verion of Minecraft from Mojang. This means that the people playing in the server also will need the latest version. Is this OK?" 0 0
			case $? in
			0)
			minecraft_update ;;
			1)
			echo "Proceeding without update...";;
			255)
			echo "ESC pressed.";;
			esac
	fi

	# Basic check to see that the Minecraft folder is present and
	# if not crate it and download the scripts and the server jar file
	# to enable the server.
	setup_minecraft_root
	check_java

	# Start the server and monitor the server performance
	find_active_newtork_interface
	run_minecraft_server_manager

MINECRAFT_EOF
}






generate_fedora_ks_cfg_file ()
{
# Description: Function to generate an installation configuration file for Fedora/Red Hat.
# Globals:
# Arguments: [file path] [workstation, ssh-server, ansible-server]
# Outputs: One configuration file.
# Returns: 0/1
# Usage: generate_fedora_ks_cfg_file $(mktemp) workstation
# End of documentation
	FILE=${FILE="$1"}
	CONFIG=${CONFIG="$2"}
	FedoraVersion=${FedoraVersion:-"35"}
	write_host --cyan "Creating KS.CFG Instructions (txt): ${FILE}"

	# repo --name=fedora-updates --mirrorlist="https://mirrors.fedoraproject.org/mirrorlist?repo=updates-released-f${FedoraVersion}&arch=x86_64" --cost=0
	# repo --name=rpmfusion-free --mirrorlist="https://mirrors.rpmfusion.org/mirrorlist?repo=free-fedora-${FedoraVersion}&arch=x86_64" --includepkgs=rpmfusion-free-release
	# repo --name=rpmfusion-free-updates --mirrorlist="https://mirrors.rpmfusion.org/mirrorlist?repo=free-fedora-updates-released-${FedoraVersion}&arch=x86_64" --cost=0
	# repo --name=rpmfusion-nonfree --mirrorlist="https://mirrors.rpmfusion.org/mirrorlist?repo=nonfree-fedora-${FedoraVersion}&arch=x86_64" --includepkgs=rpmfusion-nonfree-release
	# repo --name=rpmfusion-nonfree-updates --mirrorlist="https://mirrors.rpmfusion.org/mirrorlist?repo=nonfree-fedora-updates-released-${FedoraVersion}&arch=x86_64" --cost=0
	# repo --name=google-chrome --install --baseurl="https://dl.google.com/linux/chrome/rpm/stable/x86_64" --cost=0

	if [[ "${CONFIG}" == "ssh-server" ]]; then
		write_information "Selected configuration is ssh-server..."
		cat >> ${FILE} <<-KS_EOF
		# Generated by: generate_fedora_ks_cfg_file
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		text

		# Configure installation method
		url --mirrorlist="https://mirrors.fedoraproject.org/mirrorlist?repo=fedora-${FedoraVersion}&arch=x86_64"

		# Run the Setup Agent on first boot
		firstboot --enable

		# Keyboard layouts
		keyboard --vckeymap=us --xlayouts='us'

		# System language
		lang en_US.UTF-8

		# System timezone
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org

		# Network information
		network --onboot=yes --bootproto=dhcp

		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted

		# Partition clearing information
		zerombr
		clearpart --all

		# Disk partitioning information
		autopart --nohome

		#Reboot the system after installation.
		reboot

		%packages --retries 5 --timeout 20
		openssh-server
		spice-vdagent
		%end
		KS_EOF
		return
	elif [[ "${CONFIG}" == "ansible-server" ]]; then
		write_information "Selected configuration is ansible-server..."
		cat >> ${FILE} <<-KS_EOF
		# Generated by: generate_fedora_ks_cfg_file
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		text

		# Configure installation method
		url --mirrorlist="https://mirrors.fedoraproject.org/mirrorlist?repo=fedora-${FedoraVersion}&arch=x86_64"

		# Run the Setup Agent on first boot
		firstboot --enable

		# Keyboard layouts
		keyboard --vckeymap=us --xlayouts='us'

		# System language
		lang en_US.UTF-8

		# System timezone
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org

		# Network information
		network --onboot=yes --bootproto=dhcp --hostname=ansible.localdomain

		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted

		# Partition clearing information
		zerombr
		clearpart --all

		# Disk partitioning information
		autopart --nohome

		#Reboot the system after installation.
		reboot

		%packages --retries 5 --timeout 20
		openssh-server
		spice-vdagent
		ansible
		%end
		KS_EOF
		return
	elif [[ "${CONFIG}" == "workstation" ]]; then
		write_information "Selected configuration is workstation..."
		cat >> ${FILE} <<-KS_EOF
		# Generated by: generate_fedora_ks_cfg_file
		# Choosing mode (graphical|text|cmdline [--non-interactive])
		graphical

		# Configure installation method
		url --mirrorlist="https://mirrors.fedoraproject.org/mirrorlist?repo=fedora-${FedoraVersion}&arch=x86_64"

		# Setup Agent on first boot
		firstboot --disable
		keyboard --xlayouts='se'
		lang en_US.UTF-8
		timezone Europe/London --isUtc --ntpservers=0.pool.ntp.org
		network --onboot=yes --bootproto=dhcp
		rootpw \$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted
		user --groups=wheel --name=tangarora --password=\$6\$Rn5/UTzjIs68MX\$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1 --iscrypted

		# Partition clearing information
		zerombr
		clearpart --all
		autopart --nohome --encrypted --passphrase letmein1234
		reboot

		%packages --retries 5 --timeout 20
		@^workstation-product-environment
		openssh-server
		spice-vdagent
		git
		%end

		# Post-installation Script
		%post --interpreter=/bin/bash
		git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd
		chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
		bash /opt/rtd/core/rtd-oem-enable-config.sh
		%end
		KS_EOF
		return
	else
		write_information "No configuration request: skipping..."
		return 1
	fi
}








generate_autoyast_file ()
{
# Description: Function to generate an installation configuration file for SUSE builds.
# Globals:
# Arguments: [file path] [workstation, ssh-server, ansible-server]
# Outputs: One configuration file.
# Returns: 0/1
# Usage: generate_autoyast_file $(mktemp) workstation
# End of documentation
	FILE="$1"
	CONFIG="$2"
	suse_product="Leap"
	write_host --cyan "Creating AUTOYAST Instructions (XML): ${FILE}"


	# Localized variables based on User preferences, but with suse speciffic defaults:
	Preference_DiskEncryption_SUSE="$( [[ "$_EncryptDisk" == "YES" ]] && echo "<encryption_password>${PreferredDiskPassword:-"letmein1234"}</encryption_password>" )"
	Preference_Password_SUSE=$( [[ -n "${PrefferredUserPassword}" ]] && echo "<user_password>${PrefferredUserPassword}</user_password>" || echo '<user_password>$6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1</user_password>' )
	Preference_Desktop_DE_SUSE=${_UserDesktopEnvironemtSelection:-"<pattern>kde</pattern>"}
	Preference_InitialUser_SUSE="<username>${_OEM_USER:-"tangarora"}</username>"
	Preference_Product_SUSE="<product>${suse_product:="openSUSE"}</product>"

	cat >> ${FILE} <<-AUTOYAST_EOF
<?xml version="1.0"?>
<!DOCTYPE profile>
<profile
	xmlns="http://www.suse.com/1.0/yast2ns"
	xmlns:config="http://www.suse.com/1.0/configns" >
	<general>
		<mode>
			<confirm config:type="boolean">false</confirm>
			<final_reboot config:type="boolean">true</final_reboot>
			<final_halt config:type="boolean">false</final_halt>
			<halt config:type="boolean">false</halt>
			<second_stage config:type="boolean">false</second_stage>
			<forceboot config:type="boolean">true</forceboot>
		</mode>
	</general>

	<storage>
		<proposal>
		<confirm config:type="boolean">false</confirm>
		<lvm config:type="boolean">true</lvm>
		<windows_delete_mode config:type="symbol">all</windows_delete_mode>
		<linux_delete_mode config:type="symbol">all</linux_delete_mode>
		<other_delete_mode config:type="symbol">all</other_delete_mode>
		${Preference_DiskEncryption_SUSE}
		</proposal>
	</storage>

	<networking>
	<keep_install_network config:type="boolean">true</keep_install_network>
	</networking>

	<deploy_image>
	<image_installation config:type="boolean">true</image_installation>
	</deploy_image>

	<software>
		<install_recommended config:type="boolean">true</install_recommended>
		<patterns config:type="list">
			<pattern>base</pattern>
			${Preference_Desktop_DE_SUSE}
		</patterns>

		<packages config:type="list">
			<package>wget</package>
			<package>vim</package>
			<package>spice-vdagent</package>
			<package>git</package>
		</packages>

		<products config:type="list">
			${Preference_Product_SUSE}
		</products>

	</software>

	<firstboot>
		<firstboot_enabled config:type="boolean">false</firstboot_enabled>
	</firstboot>

	<users config:type="list">
		<user>
			<encrypted config:type="boolean">true</encrypted>
			<fullname>root</fullname>
			<gid>0</gid>
			<home>/root</home>
			<shell>/bin/bash</shell>
			<uid>0</uid>
			${Preference_Password_SUSE}
			<username>root</username>
		</user>
		<user>
			<encrypted config:type="boolean">true</encrypted>
			<fullname>RTD User</fullname>
			<shell>/bin/bash</shell>
			${Preference_Password_SUSE}
			${Preference_InitialUser_SUSE}
		</user>
	</users>

	<login_settings>
		<autologin_user>tangarora</autologin_user>
		<password_less_login config:type="boolean">true</password_less_login>
	</login_settings>

	<services-manager>
		<default_target>graphical</default_target>
		<services>
			<enable config:type="list">
				<service>sshd</service>
				<service>spice-vdagent</service>
			</enable>
		</services>
	</services-manager>

	<scripts>
	    <init-scripts config:type="list">
	      <script>
		<source><![CDATA[
#!/bin/bash
git clone https://github.com/vonschutter/RTD-Setup.git /opt/rtd
chmod 755 /opt/rtd/core/rtd-oem-enable-config.sh
/opt/rtd/core/rtd-oem-enable-config.sh
cp *.xml /opt/rtd/
]]>
		</source>
	      </script>
	    </init-scripts>
	</scripts>

	<security>
		<displaymanager_remote_access>no</displaymanager_remote_access>
		<fail_delay>3</fail_delay>
		<faillog_enab>yes</faillog_enab>
		<gid_max>60000</gid_max>
		<gid_min>101</gid_min>
		<lastlog_enab>yes</lastlog_enab>
		<obscure_checks_enab>no</obscure_checks_enab>
		<permission_security>secure</permission_security>
		<run_updatedb_as>nobody</run_updatedb_as>
		<uid_max>60000</uid_max>
		<uid_min>500</uid_min>
		<selinux_mode>permissive</selinux_mode>
		<lsm_select>selinux</lsm_select>
	</security>


</profile>

AUTOYAST_EOF
}










#                 __
#               .'  '.
#              :      :
#              | _  _ |
#           .-.|(o)(o)|.-.        _._          _._
#          ( ( | .--. | ) )     .',_ '.      .' _,'.
#           '-/ (    ) \-'     / /' `\ \ __ / /' `\ \
#            /   '--'   \     / /     \.'  './     \ \
#            \ `"===="` /     `-`     : _  _ :      `-`
#             `\      /'              |(o)(o)|
#               `\  /'                |      |
#               /`-.-`\_             /        \
#         _..:;\._/V\_./:;.._       /   .--.   \
#       .'/;:;:;\ /^\ /:;:;:\'.     |  (    )  |
#      / /;:;:;:;\| |/:;:;:;:\ \    _\  '--'  /__
#     / /;:;:;:;:;\_/:;:;:;:;:\ \ .'  '-.__.-'   `-.

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Internal Functions       ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::









set_colors ()
{
# Description: Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message.
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# Usage:
#	Simply call this function by stating its name:
# 	set_colors
#
# Globals:
# Arguments: None
# Outputs: Sets usable variables: $picachu $music $chess $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# as well as: $[yellow, darkyellow, red, darkred, endcolor, green, darkgreen, blue, darkblue, cyan, darkcyan, gray, purple, darkpurple]
# Returns:
# Usage: echo -e $yellow "text to display" or echo -e $picachu
#
# "ðŸ”´  ðŸ”µ "
# The function will not return any sucess or failure codes. It will do its best and exit.
#
# End of documentation

# Foreground & background colour commands
#
# tput setab [1-7] # Set the background colour using ANSI escape
# tput setaf [1-7] # Set the foreground colour using ANSI escape
#
#
# Black        0;30     Dark Gray     1;30
# Red          0;31     Light Red     1;31
# Green        0;32     Light Green   1;32
# Brown/Orange 0;33     Yellow        1;33
# Blue         0;34     Light Blue    1;34
# Purple       0;35     Light Purple  1;35
# Cyan         0;36     Light Cyan    1;36
# Light Gray   0;37     White         1;37
#
#      Num  Colour    #define         R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1
#
# Text mode commands
#
# tput bold    # Select bold mode
# tput dim     # Select dim (half-bright) mode
# tput smul    # Enable underline mode
# tput rmul    # Disable underline mode
# tput rev     # Turn on reverse video mode
# tput smso    # Enter standout (bold) mode
# tput rmso    # Exit standout mode
#
# Cursor movement commands
#
# tput cup Y X # Move cursor to screen postion X,Y (top left is 0,0)
# tput cuf N   # Move N characters forward (right)
# tput cub N   # Move N characters back (left)
# tput cuu N   # Move N lines up
# tput ll      # Move to last line, first column (if no cup)
# tput sc      # Save the cursor position
# tput rc      # Restore the cursor position
# tput lines   # Output the number of lines of the terminal
# tput cols    # Output the number of columns of the terminal
#
# Clear and insert commands
#
# tput ech N   # Erase N characters
# tput clear   # Clear screen and move the cursor to 0,0
# tput el 1    # Clear to beginning of line
# tput el      # Clear to end of line
# tput ed      # Clear to end of screen
# tput ich N   # Insert N characters (moves rest of line forward!)
# tput il N    # Insert N lines
#
# Other commands
#
# tput sgr0    # Reset text format to the terminal's default
# tput bel     # Play a bell
#
# # Reset
# Color_Off='\033[0m'       # Text Reset
#
# # Regular Colors
# Black='\033[0;30m'        # Black
# Red='\033[0;31m'          # Red
# Green='\033[0;32m'        # Green
# Yellow='\033[0;33m'       # Yellow
# Blue='\033[0;34m'         # Blue
# Purple='\033[0;35m'       # Purple
# Cyan='\033[0;36m'         # Cyan
# White='\033[0;37m'        # White
#
# # Bold
# BBlack='\033[1;30m'       # Black
# BRed='\033[1;31m'         # Red
# BGreen='\033[1;32m'       # Green
# BYellow='\033[1;33m'      # Yellow
# BBlue='\033[1;34m'        # Blue
# BPurple='\033[1;35m'      # Purple
# BCyan='\033[1;36m'        # Cyan
# BWhite='\033[1;37m'       # White
#
# # Underline
# UBlack='\033[4;30m'       # Black
# URed='\033[4;31m'         # Red
# UGreen='\033[4;32m'       # Green
# UYellow='\033[4;33m'      # Yellow
# UBlue='\033[4;34m'        # Blue
# UPurple='\033[4;35m'      # Purple
# UCyan='\033[4;36m'        # Cyan
# UWhite='\033[4;37m'       # White
#
# # Background
# On_Black='\033[40m'       # Black
# On_Red='\033[41m'         # Red
# On_Green='\033[42m'       # Green
# On_Yellow='\033[43m'      # Yellow
# On_Blue='\033[44m'        # Blue
# On_Purple='\033[45m'      # Purple
# On_Cyan='\033[46m'        # Cyan
# On_White='\033[47m'       # White
#
# # High Intensity
# IBlack='\033[0;90m'       # Black
# IRed='\033[0;91m'         # Red
# IGreen='\033[0;92m'       # Green
# IYellow='\033[0;93m'      # Yellow
# IBlue='\033[0;94m'        # Blue
# IPurple='\033[0;95m'      # Purple
# ICyan='\033[0;96m'        # Cyan
# IWhite='\033[0;97m'       # White
#
# # Bold High Intensity
# BIBlack='\033[1;90m'      # Black
# BIRed='\033[1;91m'        # Red
# BIGreen='\033[1;92m'      # Green
# BIYellow='\033[1;93m'     # Yellow
# BIBlue='\033[1;94m'       # Blue
# BIPurple='\033[1;95m'     # Purple
# BICyan='\033[1;96m'       # Cyan
# BIWhite='\033[1;97m'      # White
#
# # High Intensity backgrounds
# On_IBlack='\033[0;100m'   # Black
# On_IRed='\033[0;101m'     # Red
# On_IGreen='\033[0;102m'   # Green
# On_IYellow='\033[0;103m'  # Yellow
# On_IBlue='\033[0;104m'    # Blue
# On_IPurple='\033[0;105m'  # Purple
# On_ICyan='\033[0;106m'    # Cyan
# On_IWhite='\033[0;107m'   # White




  	local ecode="\033["

	yellow="${ecode}1;33m"
	darkyellow="${ecode}0;33m"
	red="${ecode}1;31m"
	darkred="${ecode}0;31m"
	endcolor="${ecode}0m"
	green="${ecode}1;32m"
	darkgreen="${ecode}1;32m"
	blue="${ecode}1;34m"
	darkblue="${ecode}0;34m"
	cyan="${ecode}0;36"
	darkcyan="${ecode}0;36"
	gray="${ecode}0;37"
	purple="${ecode}1;35"
	darkpurple="${ecode}0;35"

	# Back compatability w. old scripts
	YELLOW="$yellow"
	RED="$red"
	ENDCOLOR="$endcolor"
	GREEN="$green"
	BLUE="$blue"

	music="
	â•”â•â•â•— â™« \n
	â•‘â–ˆâ–ˆâ•‘ â™ªâ™ª \n
	â•‘â–ˆâ–ˆâ•‘â™«â™ª \n
	â•‘ â—Žâ™«â™ªâ™« \n
	â•šâ•â•â• Turn Up The Music!!! \n
	"

	picachu="
	â¢€â£ â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â €â£ â£¤â£¶â£¶ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â¢°â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â£€â£€â£¾â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â¡â ‰â ›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â ˆâ ›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â ›â ‰â â €â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£§â¡€â €â €â €â €â ™â ¿â ¿â ¿â »â ¿â ¿â Ÿâ ¿â ›â ‰â €â €â €â €â €â£¸â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£„â €â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£´â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â â €â €â €â €â €â €â €â €â €â €â €â €â €â €â  â£´â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡Ÿâ €â €â¢°â£¹â¡†â €â €â €â €â €â €â£­â£·â €â €â €â ¸â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ €â €â ˆâ ‰â €â €â ¤â „â €â €â €â ‰â â €â €â €â €â¢¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¾â£¿â£·â €â €â €â €â¡ â ¤â¢„â €â €â €â  â£¿â£¿â£·â €â¢¸â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡€â ‰â €â €â €â €â €â¢„â €â¢€â €â €â €â €â ‰â ‰â â €â €â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â €â €â €â €â €â €â €â ˆâ €â €â €â €â €â €â €â €â €â €â¢¹â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢¸â£¿â£¿ \n
	"

	ubuntulogo="
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â ›â ‹â ‰â â €â €â €â €â ˆâ ‰â ™â ›â ¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â ¿â ‹â â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ ™â ¿â£¿â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â¡Ÿâ â €â €â €â €â €â €â €â €â €â €â €â €â €â¢ â£¾â£¿â£¦â €â €â €â ˆâ¢»â£¿â£¿â£¿ \n
	â£¿â£¿â â €â €â €â €â €â €â €â €â¢ â£¶â£¶â£¾â£·â£¶â£†â ¸â£¿â£¿â¡Ÿâ €â €â €â €â €â ¹â£¿â£¿ \n
	â£¿â ƒâ €â €â €â €â €â €â£ â£¾â£·â¡ˆâ »â ¿â Ÿâ »â ¿â¢¿â£·â£¤â£¤â£„â €â €â €â €â €â €â ˜â£¿ \n
	â¡â €â €â €â €â €â €â£´â£¿â£¿â Ÿâ â €â €â €â €â €â €â ˆâ »â£¿â£¿â£¦â €â €â €â €â €â €â¢¹ \n
	â â €â €â¢€â£¤â£¤â¡˜â¢¿â£¿â¡â €â €â €â €â €â €â €â €â €â €â¢¹â£¿â£¿â¡‡â €â €â €â €â €â ˆ \n
	â €â €â €â£¿â£¿â£¿â¡‡â¢¸â£¿â¡â €â €â €â €â €â €â €â €â €â €â¢ˆâ£‰â£‰â¡â €â €â €â €â €â € \n
	â¡€â €â €â ˆâ ›â ›â¢¡â£¾â£¿â£‡â €â €â €â €â €â €â €â €â €â €â£¸â£¿â£¿â¡‡â €â €â €â €â €â¢€ \n
	â£‡â €â €â €â €â €â €â »â£¿â£¿â£¦â¡€â €â €â €â €â €â €â¢€â£´â£¿â£¿â Ÿâ €â €â €â €â €â €â£¸ \n
	â£¿â¡„â €â €â €â €â €â €â ™â¢¿â¡¿â¢â£´â£¶â£¦â£´â£¶â£¾â¡¿â ›â ›â ‹â €â €â €â €â €â €â¢ â£¿ \n
	â£¿â£¿â£†â €â €â €â €â €â €â €â €â ˜â ¿â ¿â¢¿â¡¿â ¿â â¢°â£¿â£¿â£§â €â €â €â €â €â£°â£¿â£¿ \n
	â£¿â£¿â£¿â£§â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â ˜â¢¿â£¿â Ÿâ €â €â €â¢€â£¼â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¶â£„â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£ â£¶â£¿â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¶â£¤â£„â£€â¡€â €â €â €â €â¢€â£€â£ â£¤â£¶â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿ \n
	"

	chess="â™Ÿï¸ â™” â™• â™– â™— â™˜ â™™ â™š â™› â™œ â™ â™ž â™Ÿ"
	colorcircle="ðŸ”´ ðŸŸ  ðŸŸ¡ ðŸŸ¢ ðŸ”µ ðŸŸ£ ðŸŸ¤"
	colorsquares=" ðŸŸ¥ ðŸŸ§ ðŸŸ¨ ðŸŸ© ðŸŸ¦ ðŸŸª ðŸŸ«"
	#â° 	â± 	â² 	â³ 	â´ 	âµ 	â¶ 	â· 	â¸ 	â¹ 	âº
	#â© 	âª 	â« 	â¬ 	â­ 	â® 	â¯
	# â˜” 	â˜• 	â˜– 	â˜— 	â˜˜ 	â˜™ 	â˜š 	â˜› 	â˜œ 	â˜ 	â˜ž 	â˜Ÿ
	# â™° 	â™± 	â™² 	â™³ 	â™´ 	â™µ 	â™¶ 	â™· 	â™¸ 	â™¹ 	â™º 	â™» 	â™¼ 	â™½ 	â™¾ 	â™¿
	# âš 	âš‘ 	âš’ 	âš“ 	âš” 	âš• 	âš– 	âš— 	âš˜ 	âš™ 	âšš 	âš› 	âšœ 	âš 	âšž 	âšŸ
}





display_result ()
{
# Description: Function to read a variable "result" and display its contents. The purpose of this function
# is simply to make it easy and convenient to display a mesage to an end user in a terminal
# in a nice way. To use this function simply call it after populating the variable result.
# Globals: ${result}, ${BRANDING}
# Arguments: ["Title to display"]
# Outputs: Message in dialog box
# Returns: 0 or ESC
# Usage:
#
# result=$( command with output)
# display_result "title of the mesage"
#
# End of Documentation

	${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "$1" --msgbox "$result" ${HEIGHT:-"20"} ${WIDTH:-"80"}
	clear
}





rtd_oem_pause ()
{
# Description:
# A simple function to pause and wait for end user input.
# The function expects a non zero (0) argument to execute the pause
# and wait for the end user to press ENTER to continue execution.
#
# Globals:
# Arguments: 0 - !0 "[optional error message]"
# Outputs: Standard out
# Returns:
# Usage:  suggestion stop on execution error:
# EXPRESSION  || rtd_oem_pause 1
# or
# EXPRESSION ; rtd_oem_pause $?
#
# In both of these cases script execution will halt and wait for confirmation
# before continuing.
# End of documentation
	ERRMSG=$@

	if [ ! $1 -eq 0 ]; then
		read -p "$ERRMSG: Press  [ ENTER ] to continue:"
	fi
}





write_host ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# This function will print a message to the standard out in a color specified.
# Specified colors can be colord defined in the function "set_colors"
# If no color option is specified this cunctio simply works like the echo command.
#
# Globals:
# Arguments: [color option]
# Outputs:
# Returns:
# Usage: write_host [option] [String]
#
# where [option] is a supported color:
# --yellow            Prints message in YELLOW
# --darkyellow        Prints message in DARK YELLOW
# --red               Prints message in RED
# --darkred           Prints message in DARK RED
# --endcolor          DEFAULT color as in terminal.
# --green             Prints message in GREEN
# --darkgreen         Prints message in DARK GREEN
# --blue              Prints message in BLUE
# --darkblue          Prints message in BLUE
# --cyan              Prints message in CYAN
# --darkcyan          Prints message in DARK CYAN
# --gray              Prints message in GRAY
# --purple            Prints message in PURPLE
# --darkpurple        Prints message in  DARK PURPLE
#
# NOTE: this function uses the "tput" mechanisms to set colors, and gice a convenient
# and simple uman way to access them. The target system must have "tput" aavailable.
#
#
# End of documentation
	_option=$1

	case ${_option} in
		--yellow ) color="$(tput bold; tput setaf 3)" ;;
		--darkyellow ) color="$(tput dim; tput setaf 3)" ;;
		--red ) color="$(tput bold; tput setaf 1)" ;;
		--darkred ) color="$(tput setaf 3)" ;;
		--endcolor ) color="$(tput sgr0)" ;;
		--green ) color="$"$(tput bold; tput setaf 2)"" ;;
		--darkgreen ) color="$(tput dim; tput setaf 2)" ;;
		--blue ) color="$(tput bold; tput setaf 4)" ;;
		--darkblue ) color="$(tput dim; tput setaf 4)" ;;
		--cyan ) color="$(tput bold; tput setaf 6)" ;;
		--darkcyan ) color="$(tput dim; tput setaf 6)" ;;
		--gray ) color="$(tput dim; tput setaf 7)" ;;
		--purple ) color="$(tput bold; tput setaf 5)" ;;
		--darkpurple ) color="$(tput dim; tput setaf 5)" ;;
		*) local _text="$1" ;;
	esac
	[[ -z "${_text}" ]] && local _text="${color} $2 $(tput sgr0)"
	echo -e "${_text} "
}



write_error ()
{
# Description:
# is a simplified and consistent way to write output to the screen.
# write_error will print a message to the standard out in RED.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_error "[String]"
#
# End of documentation

	local text=$1
	if [[ -n "${text}" ]]; then
		echo -e "$(tput bold; tput setaf 1)${text}${endcolor}"
	fi
}


write_warning ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_warning will print a message to the standard out in Yellow.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_warning "[String]"
#
# End of documentation


	local text=$1
	[ -n "${text}" ] && echo -e "${yellow}${text}${endcolor}"

}


write_status ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_status will print a message to the standard out in GREEN.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_status "[String]"
#
# End of documentation


	local text=$1
	[ -n "${text}" ] && echo -e "${green}${text}${endcolor}"

}


write_information ()
{
# Description:
# This is a simplified and consistent way to write output to the screen.
# write_information will print a message to the standard out in BLUE.
# Globals:
# Arguments: "text to be printed to standard out"
# Outputs: standard out in color
# Returns:
# Usage: write_information "[String]"
#
# End of documentation


	local text=$1
	[ -n "${text}" ] && echo -e "${blue}${text}${endcolor}"

}





list_loaded_internal_functions ()
{
# Description: Function to list all internal library functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--zformat]
# Outputs: Standard out, list of functions either formatted for zenity or not. Output may be used to populate a zenity menu or dialog.
# Returns:
# Usage: list_loaded_software_functions [] [--zformat]
# End of documentation

	if [[ "$1" == "--zformat" ]]; then
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			Description=$( head -200 $0 |grep $index | head -1 |cut -f2 -d: )
			echo -e "$i \n $index \n ${Description} \n"
			((i=i+1))
		done
	else
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipe_" |grep -v "Single_Install" )
		do
			echo "$index #$i"
			((i=i+1))
		done

	fi
}


list_loaded_software_functions ()
{
# Description: Function to list all software (_rtd_recipes) functions loaded... for debugging/support purposes.
# Globals:
# Arguments: none or [--nonum]
# Outputs: Standard out, list of functions either numerated or not.
# Returns:
# Usage: list_loaded_software_functions [] [--nonum]
# End of documentation

	if [[ "$1" == "--nonum" ]]; then
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo ${index/recipe_/}
		done
	else
		i=1
		for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipe_")
		do
			echo "$i	${index/recipe_/}"
			((i=i+1))
		done
	fi
}






#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Executive                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# The following section launches the internal functions if given arguments
# request this. If no arguments are provided, then all the functions in this
# library will simply be loaded in to memory.




set_colors
export RTDFUNCTIONS=1

if [ -z $1 ]; then
	echo OK
else
	case $1 in
		--help | -? )
			echo -e "${0##*/} :: RunTime Data Library HELP ::

			Usage: ${0##*/} [OPTIONS]
			valid option are :
			--help		 : Show this help text
			--list		 : List library functions (requires options: software, or internal, or all)
				software : (list) software install bundles available
				internal : (list) internal functions loaded
				all	 : (list) all library functions including software
			--devhelp	 : diplay script developer's help
			EXAMPLE:
			${0##*/} --list --internal"
		;;
		--list )
			case $2 in
				software ) list_loaded_software_functions ;;
				internal ) list_loaded_internal_functions ;;
				all ) ( echo -e $YELLOW "Software Recipies: $ENDCOLOR" && list_loaded_software_functions && echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR" && list_loaded_internal_functions ) ;;
				* ) echo "USAGE: The --list option requires a (what option). Valid option are: software, internal, all." ;;
			esac
		;;
		--devhelp )
			while true; do
				exec 3>&1
				selection=$(dialog --clear --no-collapse --backtitle "${BRANDING:-" RunTime Data : Function library : Script Development Support"}" --title "RTD Library Loaded Functions:" --menu "\n Chose a function below to see more details about the function." "${HEIGHT:-0}" "${WIDTH:-90}" "${LIST_HEIGHT:-0}" $(list_loaded_internal_functions) 2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case $selection in
					$selection )
						result=$(while IFS= read -r 'line'; do
							[[ "$line" == "$selection ()" ]]		&& printline="yes"
							[[ "$line" == "# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
							[[ "$printline" == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
						done < $0 )
						dialog --clear --no-collapse --backtitle "${0##*/} :: RunTime Data Library HELP ::" --title "RTD Functon: $selection" --msgbox "$result" "${HEIGHT:-25}" "${WIDTH:-110}"
						return
					;;
					* ) exit ;;
				esac
			done
		;;
		--devhelp-gtk )
			while true; do
				exec 3>&1
				DisplayList=$(list_loaded_internal_functions --zformat)
				IFS_SAV=$IFS
				IFS=$(echo -en "\n\b")
				selection=$(zenity --list --text="Select a function below, to see the function's documentation \n and usage:" --height="${HEIGHT:-600}" --width="${WIDTH:-1000}" --print-column=2 --column="Number" --column="Function" --column="Description" ${DisplayList} )
				exit_status=$?
				IFS=$IFS_SAV
				exec 3>&-
				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case "$selection" in
					"$selection" )
						result=$(while IFS= read -r 'line'; do
							[[ "$line" == "${selection/ /}()" ]]		&& printline="yes"
							[[ "$line" == "# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *"# End of documentation"* ]]	&& printline="no"
							[[ "$line" == *End*of*Documentation* ]]		&& printline="no"
							[[ "$printline" == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
						done < $0 )
						zenity --info --title "RTD Functon: $selection" --text="$result" --height=600 --width=800
					;;
					* )
					# Trap unknown exit code...
					exit
					;;
				esac
			done
		;;
		* )
			echo "No RECOGNIZED arguments provided: loading ${0:BASENAME}" ; echo "Use ${0:BASENAME} --help to see supported arguments"
			echo "$0 launched with unknown parameters" >${LOGFILE:-"/var/log/$(basename $0)"}
		;;
	esac
fi
