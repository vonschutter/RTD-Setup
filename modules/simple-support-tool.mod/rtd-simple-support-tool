#!/bin/bash
RTD_Version=2.1.2
: <<'Script_Documentation'
										  -    RTD Power Toy Script      -

:::::::::::::::::::::::::::::::::::::::::: PREVENT RUNING IN WINDOWS	 ::::::::::::::::::::::::::::::::::::::::::::::::

cls & color 0C & echo Do not attempt to run this script in CMD.EXE & pause & color 0F & exit /b

::::::::::::::::::::::::::::::::::::::::::::: HEADER DO NOT REMOVE ::::::::::::::::::::::::::::::::::::::::::::::::::::::



                                             A D M I N   C O M M A N D 
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:::::::::::::::::::::::::::::::::::::::::::::// Simple Compression Toy //::::::::::::::::::::::::::::// Linux //::::::::
:: 	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
::
::
::	Purpose: To simplify support tasks
::		  - Display system information
::		  - Update system software
:: 		  - Bakup virtual machines
::                - Cleanup/Report on PPA's (Ubuntu only)
::                - Show systems physical location
::		  - Check if a password you intend to use is for sale on the Darknet
::
::     Usage: run the script "bash /path/to/rtd-simple-support-tool" or if installed in the $PATH; by rtd simply 
::	       type "rtd-sim + [TAB]" in a terminal.
::
::     This script is shared in the hopes that
::     someone will find it usefull.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
	these apps are seldom changed and when they are, it is usefull to be able to understand why and how
	things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
	learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
	patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
	for any organization after some years and people turnover.

	As a general rule, we prefer using functions extensively because this makes it easier to manage the script
	and facilitates several users working on the same scripts over time.


 This script is shared in the hopes that it will be useful.

 This script is part of the RTD Power Toy collection. The RTD Power Toy collection consists of scripts designed
 to be used together to accomplish a wide range of tasks. These scripts are simple, easy to use, and easy to
 understand, making them suitable for use in a Linux environment, though they may be adaptable to other environments.
 A special header is included to either prevent execution in Windows or to execute the proper section if run in Windows,
 thereby preventing accidental execution of the script in a Windows (CMD) environment and avoiding potential harm.

 For convenience and supportability, most actions (work) are stored in a common library used by multiple scripts.
 While using this library is optional, it may save time. Typically, if a function is useful in more than one script, 
 it is included in the library. This script demonstrates the ease of using these functions.
 To utilize these functions, simply load the library using the "source" bash built-in command. All
 functions will then be available for use.

 This script is intended to reside in the ~/bin/ or /bin/ directory, or alternatively, in the $PATH.
 By default, this script is placed in /opt/rtd/modules/{collection or name}.

 1 - To view options for using the RTD library, type: "bash _rtd_library --help"
 2 - To view detailed documentation for each function in this library, type: "bash _rtd_library --devhelp | --devhelp-gtk"

 Function: dependency::_library
 Description: This function ensures access to the RTD library functions by sourcing the appropriate script.
 It first sources the library from a relative path, then from ~/bin, and finally from the /opt directory. Using the 
 relative path is beneficial for development and testing, ~/bin is useful for user-specific scripts, and /opt 
 is suitable for system-wide scripts. Additionally, the function downloads the library from the GitHub repository 
 and sources it if it is not found in any of the  previous locations. If all attempts fail, it displays an error 
 message and returns 1.

Scripts may also be stand-alone if there is a reason for this. 

Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
to make the script more readable. Each function shall also be documented to the point of the obvious.
Suggested function structure per google guidelines:

function_descriptive_name () {
	# Documentation and comments...
	...code...
}


Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
Settings, contain configurable options for the script. Functions, contain all functions. Execute,
contains all the actual logic and control of the script.


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Script_Documentation

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
: ${_SCRIPTNAME=$(basename "${BASH_SOURCE[0]}")}
: ${_TLA:=${_SCRIPTNAME:0:3}}
: ${BRANDING_ORG:="RTD"}
: ${BRANDING:="Simple Support Tool"}
: ${DIALOG_CANCEL:="1"}
: ${DIALOG_ESC:="255"}
: ${HEIGHT:="20"}
: ${WIDTH:="90"}
: ${LIST_HEIGHT:="12"}
: ${_GIT_PROFILE:=vonschutter}

# load documentation for this script in a variable for later use.
: ${_SIMPLE_SUPPORT_TOOL_DOC="$(tail -n +6 "$0" | head -n 25)"}


# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
: ${YELLOW:="\033[1;33m"}
: ${RED:="\033[1;31m"}
: ${ENDCOLOR:="\033[0m"}
: ${GREEN:="\033[1;32m"}
: ${BLUE:="\033[1;34m"}

# Set the background color of the tool. The appearance of the menu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option. This will
# override what is detected and preferred!
# Valid choices are: "dialog", "whiptail".
# RTD_GUI=dialog
# export NEWT_COLORS='root=,gray '
: ${RTD_GUI:="dialog --clear"}



# Override default values here:
# SSH_PUBLIC_KEY_FILE=
# put_iso_file_here_when_done=
# put_qcow_file_here_when_done=
# VOLUME_TITLE=
# VOLUME_SIZE=
# _src_url=
# _LOG_DIR=
# _LOGFILE=

# Set the primary shell library to use for this script. This is the file that contains
# the primary functions for this script. If the file is not found, the script will exit.
# The file is searched for in the same directory as the script, and if not found, it
# will be searched for in the /opt/$_TLA/scripts directory.
: ${_dependency_lib:="_rtd_library"}

# Set location to where to log information:
# in the system log directory in a file named the same as this script.
if [[ $EUID -ne 0 ]]; then
	_LOG_DIR="${_LOG_DIR:="${HOME}/.config/rtd/logs"}" ; mkdir -p ${_LOG_DIR}
	_LOGFILE="${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}" ; touch ${_LOGFILE}

else
	_LOG_DIR="${_LOG_DIR:="/var/log/${_TLA,,}"}" ; mkdir -p ${_LOG_DIR}
	_LOGFILE="${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}" ; touch ${_LOGFILE}

fi



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.




dependency::file() {
    # Function: dependency::file
    # Description: Searches for and loads a dependency file locally, or downloads it if not found.
    # Parameters:
    #   - $1: The name of the dependency file.
    # Returns:
    #   - 0: If the file is found and loaded.
    #   - 1: If the file is not found or fails to load.

	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local script_dir

	script_dir=$( cd "$( dirname "$(readlink -f ${BASH_SOURCE[0]})" )" && pwd )

	if source "${script_dir}/../core/${1}" ; then
		system::log_item "${FUNCNAME[0]}: Using: ${script_dir}/../core/${1}"
	elif source "${script_dir}/../../core/${1}" ; then
		system::log_item "${FUNCNAME[0]}: Using: ${script_dir}/../../core/${1}"
	elif source $(find /opt -name ${1} | grep -v backup) ; then
		system::log_item "${FUNCNAME[0]}: Using: $(find /opt -name ${1} | grep -v backup)"
	elif curl -sL "${_src_url}" -o "./${1}" && source "./${1}" ; then
		system::log_item "${FUNCNAME[0]}: Using: ${_src_url}"
	else
		system::log_item "${1} NOT found!"
		return 1
	fi
	return 0
}










system::log_item ()
{
# Description:
# The purpose of this function is to consistently write script output to the right log file. 
# By default, the log file will be /var/log/$(basename $0).log. 
# 
# This function will be used until it is replaced by the more extensive logging function in the
# _rtd_library file when it is sourced.
# 
# End of documentation
	local _logfile="${_LOGFILE}"

	local _date="$(date '+%Y/%m/%d %H:%M')"

	case "${FUNCNAME[1]}" in
		"write_error")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_warning") 
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_information")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_host")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_status")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		*)
			echo "${_date}  --- : 🧩 ${FUNCNAME[1]}: $*" >> "${_logfile}"
		;;
	esac
}






rtd_oem_check_inet_access ()
{
# Function to verrify internet availabiltiy.
# The funciton will pause for 10 seconds by default, and will accept
# an integer to indicate a non-deault time to pause.

	_ARG=$1
	if [[ -z "$_ARG" ]]; then
		ping -c 1  8.8.8.8 &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
	else
		ping -c 1  8.8.8.8 &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
	fi
}









check_menu_availability ()
{
# Description: This function checks the availability of the menu system installed on the system.
# It first checks if "dialog" is installed, and if not, it checks if "whiptail" is installed.
# If neither is found, it displays an error message and exits.
# If "dialog" is found, it sets the RTD_GUI variable to "dialog --clear".
# If "whiptail" is found, it sets the RTD_GUI variable to "whiptail --fb".
# If the user chooses to install "dialog" instead of using "whiptail", it installs "dialog" and sets RTD_GUI to "dialog".
# If the user chooses not to install "dialog", it displays a message and exits.
# Parameters: None
# Returns: None
# End of documentation

	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" \
		--title "System Information Menu" \
		--no-button "NO: Use whiptail" \
		--yes-button "YES: Install dialog" \
		--yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: 
		DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal 
		menu system available... If you continue with the current WHIPTAIL some things might not work. 
		\n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			InstallSoftwareFromRepo dialog
			return
		else
			echo "User selected No, exit status was $?."
			return
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.

# Show Branding and version in UI
BRAND="💻 $BRANDING                        Managing:  $HOSTNAME                        Verson: $RTD_Version"
BRANDING="$BRAND"




display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About $( basename $0 ) " \
	--msgbox "
	This tool is part of the RTD System Support Tools.
	The purpose of this tool is to simplify management remote and local Linux systems.

	This script simplifies:
	- Basic Virtual Machine management
	- Auto Create and deploy VMs (Linux and Windows)
	- Change password, and encryption phrases of system disk
	- Perform distribution upgrades (supported distributions)
	- Remove unused PPA's (where relevant)
	- Display system information and resource usage

	To use this tool simply execute it: $( basename $0 )
	This tool is usefull for support staff that do not live on the command line daily, and
	can be used over ssh. If you do get disconnected the tool will remain active remotley
	and you can easily reconnect to it by re-establishing your ssh connection and typing
	the word: byobu in the terminal. "  $HEIGHT $WIDTH
	clear
}


show_notice_on_fist_run () {
	if [ -f ~/.config/rtd/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected; for example if you are
remotely connecting through SSH. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		mkdir -p ~/.config/rtd ; touch ~/.config/rtd/rtd-first-run-$RTD_Version
		clear
	fi
}


rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=( $RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
			2) InstallSoftwareFromRepo alpine ;;
			3) InstallSoftwareFromRepo vim ;;
			4) InstallSoftwareFromRepo finch ;;
			5) InstallSoftwareFromRepo wordgrinder ;;
			6) InstallSoftwareFromRepo sc ;;
			7) InstallSoftwareFromRepo tpp ;;
			8) InstallSoftwareFromRepo mc ;;
			9) InstallSoftwareFromRepo cmus ;;
			10) InstallSoftwareFromRepo byobu ;;
			11) InstallSoftwareFromRepo w3m ;;
			12) InstallSoftwareFromRepo lynx ;;
			13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb ;;
			14) InstallSoftwareFromRepo rtorrent ;;
			15) InstallSoftwareFromRepo openvpn ;;
			16) InstallSoftwareFromRepo freesweep ;;
			17) InstallSoftwareFromRepo bastet ;;
			esac
		done
}


show_make_media_gui_server ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install ISO for Ubuntu Server" \
		"2" "Automatic Install ISO for Ubuntu Graphical Server" \
		"3" "Automatic Install ISO for Debian KVM Server" \
		"4" "Automatic Install ISO for Debian Minimal Server" \
		"5" "Automatic Install ISO for Minecraft Server (Latest)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return 		;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder openssh-server server
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			cleanup_and_finish
		;;
		3 )
			system::download_and_manipulate_iso_debian  kvm-server 
			create_iso_image_debian
			cleanup_and_finish
		;;
		4 )
			system::download_and_manipulate_iso_debian  openssh-server 
			create_iso_image_debian
			cleanup_and_finish
		;;
		5 )
			system::download_and_manipulate_iso_debian  minecraft-server
			create_iso_image_debian
			cleanup_and_finish
                ;;
		esac
	done
}



show_make_media_gui_desktop () {
	# List Options to be available for choice in the RTD System Configuration...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install Media for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Automatic Install Media for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Automatic Install Media for Ubuntu Gnome (without Ubuntu customization)" \
		"4" "Automatic Install Media for Ubuntu Minimal Standard desktop" \
		"5" "Automatic Install Media for Debian Default Desktop" \
		"6" "Automatic Install Media for Debian Light Weight Desktop" \
		"7" "Automatic Install Media for Debian Plasma Desktop" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builde ubuntu-desktop desktop
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop desktop
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop desktop
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal desktop
			cleanup_and_finish
		;;
		5 )
			system::download_and_manipulate_iso_debian debian-desktop desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		6 )
			system::download_and_manipulate_iso_debian debian cinnamon-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		7 )
			system::download_and_manipulate_iso_debian debian kde-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		esac
	done
}



show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "VM Managment Menu"  \
		--menu "Please select what you would like to do below:"  "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "List all virtual machines on this system" \
		"2" "Backup all running virtual machines on this server" \
		"3" "Monitor VM's on this system "\
		"4" "Create a VM template on this server" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			if hash virsh ; then
				result=$(virsh list --all )
				display_result "Virtual Machinces on this system:"
			else
				echo KVM Virtualization is not installed on this machine.
			fi
		;;
		2 )
			backup_running_vm
		;;
		3)
			echo "VM Status on This HOST: Press [Q] to quit."
			check_dependencies virt-top
			virt-top
		;;
		4 )
			while true; do
				exec 3>&1
				subselection2=$($RTD_GUI --backtitle "$BRANDING" --title "Make Virtual Machine" --menu "    "  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make a SERVER VM (Minimal single purpose system)" \
				"2" "Make a VDI VM (chose desktop and distribution)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					"$DIALOG_CANCEL") return	;;
					"$DIALOG_ESC") return ;;
				esac

				case $subselection2 in
					0) echo "Program terminated."
					;;
					1) show_deploy_server_VM_now_menu
					;;
					2) show_deploy_VDI_VM_now_menu
					;;
				esac
			done
		;;
		esac
	done
}


show_deploy_server_VM_now_menu ()
{

		while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Template VM Server"  --menu "Please select which type of VM to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Ubuntu Server" \
		"2" "Ubuntu Minimal Server" \
		"3" "Debian Print Server" \
		"4" "Debian Minimal Server" \
		"5" "Minecraft Server" \
		"6" "Fedora Minimal Server" \
		"7" "Ansible Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			write_information "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_template_now_from_ubuntu_com --role server --flavor ubuntu-server
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_template_now_from_ubuntu_com --role server --flavor ssh-server
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_template_now_from_debian_org -r server -t print-server
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_template_now_from_debian_org -r server -t openssh-server
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_template_now_from_ubuntu_com -r server -t minecraft-server -m 4098 -c 4
			cleanup_and_finish nomessage
		;;
		6 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ssh-server
			make_kvm_virtual_machine_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		7 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ansible-server
			make_kvm_virtual_machine_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		esac

	done
}


show_deploy_VDI_VM_now_menu ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "Deploy Virtual Desktop (VDI)"  --menu "Please select which VDI to create on this server:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1"  "Ubuntu Standard Desktop (more MAC like)" \
		"2"  "Ubuntu KDE Desktop (more Windows like)" \
		"3"  "Debian Default Desktop" \
		"4"  "Debian Cinnamon Desktop" \
		"5"  "Debian Plasma Desktop" \
		"6"  "Debian Light Weight Desktop (LXDE)" \
		"7"  "Fedora Workstation VDI" \
		"8"  "SUSE Workstation VDI" \
		"9"  "Windows 10 VDI" \
		"10" "Windows 11 VDI" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_template_now_from_ubuntu_com --role desktop --flavor ubuntu-desktop --ram 4098 --cpus 4
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_template_now_from_ubuntu_com --role desktop --flavor  kubuntu-desktop --ram 4098 --cpus 4
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t gnome-desktop 
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t cinnamon-desktop 
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t kde-desktop 
			cleanup_and_finish nomessage
		;;
		6 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t lxde-desktop 
			cleanup_and_finish nomessage
		;;
		7 )
			make_kvm_virtual_machine_now_from_fedora_org
			cleanup_and_finish nomessage
		;;
		8 )
			PRESEED_FILE="$(mktemp).xml"
			generate_autoyast_file "${PRESEED_FILE}"
			make_kvm_virtual_machine_now_from_opensuse_org SUSE
			cleanup_and_finish nomessage
		;;
		9 )
			kvm::make_vm_template_now_from_microsoft --winver win10
		;;
		10 )
			kvm::make_vm_template_now_from_microsoft --winver win11
		;;
		esac

	done
}


show_view_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Show system summary" \
		"2" "Display OS Informaton" \
		"3" "View Windows Product KEY in system BIOS (if present)" \
		"4" "Show storage device space utilization" \
		"5" "Show users HOME folder storage use" \
		"6" "Show complete storage utilization by directory" \
		"7" "Show system temperature information" \
		"8" "Show detailed system CPU information" \
		"9" "List PCI Devices" \
		"10" "List USB devices" \
		"11" "Show systems physical location (city, county etc.)" \
		"12" "Show the weather forcast at the location of this system" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear ; unset result

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			check_dependencies neofetch || (rtd_oem_pause 1 ; return ) && clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			result=$(hostnamectl)
			: ${result:="No system information found..."}
			display_result "OS Information:"
		;;
		3 )
			result=$(system::get_Windows_Product_Key)
			: ${result:="No Windows product key found..."}
			display_result "Windows Product Key:"
		;;
		4 )
			result=$(df -h -x squashfs -x tmpfs)
			$RTD_GUI --backtitle "$BRANDING" --title "System Storage Space" --msgbox "$result" 20 100
		;;
		5 )
			generate_report_disk_space_used_by_directory /home
			display_result "Home Space Utilization (All Users)"
		;;
		6 )
			generate_report_disk_space_used_by_directory /
			display_result "Total Space Utilization root directory:"
		;;
		7 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			result="$( sensors )"
			display_result "System Temperature Information"
		;;
		8 )
			result="$( lscpu )"
			display_result "System CPU Information on $HOSTNAME:"
		;;
		9 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local PCI devices on $HOSTNAME:" --msgbox "$(lspci)" ${HEIGHT:-"20"} 0
			clear
		;;
		10 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local USB devices on $HOSTNAME:" --msgbox "$(lsusb)" ${HEIGHT:-"20"} 0
			clear
		;;
		11 )
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/$(dig +short myip.opendns.com @resolver1.opendns.com))
			display_result "This systems location on the Internet"
		;;
		12 )
			check_dependencies curl
			write-host "Your local weather is"
			curl http://wttr.in
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}










show_monitor_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Overview of system activities and load" \
		"2" "Monitor network usage by app" \
		"3" "Monitor System Load" \
		"4" "Monitor network traffic" \
		"5" "Monitor Kernel messages" \
		"6" "Monitor system log" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-
		clear ; unset result ; unset _RUN

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			_RUN="bashtop"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		2 )
			_RUN="nethogs"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		3 )
			_RUN="glances"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		4 )
			_RUN="bmon"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		5 )
			trap "return" SIGINT
			dmesg --human --follow
			read -p "Press [Enter] key to return to the main menu: "
		;;
		6 )
			trap "return" SIGINT
			if [[ -e /var/log/syslog ]]; then
				tail -f /var/log/syslog
			elif  [[ -e /var/log/messages ]]; then
				tail -f /var/log/messages
			else
				write_warning "no relevant log file found"
			fi
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}











show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Management Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		"6" "Remove all known non-western fonts" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			exit_status=$?
		;;
		1 )
			rtd_update_system ; rtd_oem_pause 1
		;;
		2 )
			dist_info="$(hostnamectl)"
			if echo "$dist_info" |grep ".*buntu" &>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			elif echo "$dist_info" |grep "Pop!_OS" 2>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		3 )
			dist_info="$(hostnamectl)"
			if echo "$dist_info" |grep ".*buntu" &>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			elif echo "$dist_info" |grep "Pop!_OS" 2>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		4 )
			rtd_oem_release_upgrade interactive
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		6 )
			rtd_oem_remove_non_western_latin_fonts
		;;
		esac
	done
}


show_main_menu () {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --keep-tite --backtitle "$BRANDING" --cancel-button "EXIT" --title "RTD Tool Main Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "📈 Monitor performance and statistics" \
			"2" "📋 View information about this system" \
			"3" "🖱️ Manage Software on this system" \
			"4" "🖥️ Manage KVM on this system" \
			"5" "🔐 Manage encryption phrases and passwords" \
			"6" "💽 Make media to automatically install OS (for VM's and CD burning)" \
			"7" "🆙 Shortcut: Update this system now" \
			"8" "🔨 Quick Fixes" \
			"9" "💡 About this tool" 2>&1 1>&3 )
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL")
				clear
				write_status "Program terminated."
				exit 0
			;;
			"$DIALOG_ESC")
				clear
				write_status "Program aborted."
				exit 0
			;;
		esac

		case $selection in
			0 )
				write_status "Program terminated."
			;;
			1 ) show_monitor_informaion_about_this_system
			;;
			2 )	show_view_informaion_about_this_system
			;;
			3 )	show_manage_software_gui
			;;
			4 )	show_manage_vm_gui
			;;
			5 )	show_manage_crypt_sec
			;;
			6 )
			while true; do
				exec 3>&1
					subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
					"1" "Make media to build a server (ISO or USB Disk)" \
					"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
					2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					"$DIALOG_CANCEL") show_main_menu ;;
					"$DIALOG_ESC") return ;;
				esac

				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
			;;
			7 )
				software::update_all_ui
				#read -p "Press [Enter] key to return to the main menu: "
			;;
			8 )
				show_menu_quick_fixes
			;;
			9 )
			display_notice
			;;
		esac
	done
}


show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
			--backtitle "$BRANDING" \
			--title "Manage encryption phrases and passwords" \
			--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "Check if a password is stolen" \
			"2" "Change systems disk encrytion pass phrase" \
			"3" "Change $SUDO_USER password" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
			0 )
				echo "Program terminated."
			;;
			1 )
				check_if_password_pOwned
			;;
			2 )
				system::change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}



show_menu_quick_fixes () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Quick Fixes" \
				--menu "Please select a quick fix to run:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Fix VirtualBox USB issues" \
				"2" "Fix GNOME Shell Apps Dashboard sort app in categories" \
				"3" "Restart sound system" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-
			clear

		# Cases for how program exited...
		case $exit_status in
			"$DIALOG_CANCEL")
				clear ; write_status "Cancel pressed." ; return 0
			;;
			"$DIALOG_ESC")
				clear ; write_status "Program aborted." ; return 0
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				local vbox_usbnode_path=$(find / -name VBoxCreateUSBNode.sh 2> /dev/null | head -n 1)
				if [[ -z ${vbox_usbnode_path} ]]; then
					write_warning "Warning: VBoxCreateUSBNode.sh file has not been found."
					return 1
				fi

				if [[ ! -w ${vbox_usbnode_path} ]]; then
					write_warning "Warning: VBoxCreateUSBNode.sh file is not writable."
					return 1
				fi

				chmod 755 ${vbox_usbnode_path}
				chown root:root ${vbox_usbnode_path}

				local vboxusers_gid=$(getent group vboxusers | awk -F: '{printf "%d\n", $3}')
				local vbox_rules="SUBSYSTEM==\"usb_device\", ACTION==\"add\", RUN+=\"${vbox_usbnode_path} \$major \$minor \$attr{bDeviceClass} ${vboxusers_gid}\"
				SUBSYSTEM==\"usb\", ACTION==\"add\", ENV{DEVTYPE}==\"usb_device\", RUN+=\"${vbox_usbnode_path} \$major \$minor \$attr{bDeviceClass} ${vboxusers_gid}\"
				SUBSYSTEM==\"usb_device\", ACTION==\"remove\", RUN+=\"${vbox_usbnode_path} --remove \$major \$minor\"
				SUBSYSTEM==\"usb\", ACTION==\"remove\", ENV{DEVTYPE}==\"usb_device\", RUN+=\"${vbox_usbnode_path} --remove \$major \$minor\""

				echo "${vbox_rules}" > /etc/udev/rules.d/virtualbox.rules
				rm -f /etc/udev/rules.d/*-virtualbox.rules || { write_warning "Warning: Failed to remove old virtualbox rules."; return 1;}
				udevadm control --reload || { write_warning "Warning: Failed to reload udev rules."; return 1;}

				local logname=$(logname)
				if [[ -z ${logname} ]]; then
					write_warning "Warning: Failed to get current user."
					return 1
				fi
				adduser ${logname} vboxusers

				dialog::display_notice " All actions succeeded.
				Log out and log in to see if the issue go fixed."
				return 0

			;;
			2 )
			if command gsettings &>/dev/null; then
				tempfile=$( mktemp )
				chmod 777 ${tempfile}
				cat > ${tempfile} <<-EOF
				#!/bin/bash
				gsettings set org.gnome.desktop.app-folders folder-children "['accessories', 'chrome-apps', 'games', 'graphics', 'internet', 'office', 'programming', 'science', 'sound---video', 'system-tools', 'universal-access', 'wine', 'OEM', '3D-Printing', 'Cloud']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ name "Accessories"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/accessories/ categories "['Utility']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ name "Chrome Apps"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/chrome-apps/ categories "['chrome-apps']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ name "Games"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/games/ categories "['Game']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ name "Graphics"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/graphics/ categories "['Graphics']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ name "Internet"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/internet/ categories "['Network', 'WebBrowser', 'Email']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ name "Office"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/office/ categories "['Office']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ name "Programming"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/programming/ categories "['Development']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ name "Science"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/science/ categories "['Science']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ name "Sound & Video"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/sound---video/ categories "['AudioVideo', 'Audio', 'Video']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ name "System Tools"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/system-tools/ categories "['System', 'Settings']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ name "Universal Access"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/universal-access/ categories "['Accessibility']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ name "Wine"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/wine/ categories "['Wine', 'X-Wine', 'Wine-Programs-Accessories']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ name "OEM"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/OEM/ categories "['OEM']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ name "3D-Printing"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/3D-Printing/ categories "['3D-Printing', 'CAD', '3D', '3DGraphics']"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ name "Cloud"
				gsettings set org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/Cloud/ categories "['Cloud-Management', 'Cloud', 'aws', 'azure', 'gcp']"
				EOF
				system::run_command_in_gnome_user_session /bin/bash ${tempfile}
				return 0
			else
				write_warning "Warning: gsettings command not found."
				return 1
			fi
			;;
			3 )
				write_warning "Do you want to try and restart sound on this syystem?"
				read -p "Press [ENTER] to restart sound or [CTRL]+[C] to exit"
				system::restart_sound || write_error "Failed to restart sound!"
				read -p "Press [ENTER] key to return to the main menu: "
			;;
		esac
	done
}


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functionality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-
			clear

		# Cases for how program exited...
		case $exit_status in
			"$DIALOG_CANCEL")
				clear
				echo "Program terminated."
				exit
			;;
			"$DIALOG_ESC")
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi

case $1 in
	about | --about | --help | -h )
		display_notice
		exit
	;;
	* )
		if [[ "$TERM" == screen* ]]; then
			echo "$_SIMPLE_SUPPORT_TOOL_DOC" >> ${_LOGFILE}
			rtd_oem_check_inet_access  "$@"
			dependency::file ${_dependency_lib} &>/dev/null || ( read -p "There was a problem loading ${_dependency_lib}" exit 1 )
			if [[ $EUID -ne 0 ]]; then ensure_admin ; fi
			if [ "$UID" -eq 0 ]; then
				check_menu_availability
				show_notice_on_fist_run
				show_main_menu
			fi
			exit
		else
			if hash byobu 2>/dev/null; then
				byobu new-session -s "RTD Simple Server Support Tools" $0
			else
				rtd_oem_check_inet_access "$@"
				dependency::file ${_dependency_lib} &>/dev/null || ( read -p "There was a problem loading ${_dependency_lib}" exit 1 )
				if [[ $EUID -ne 0 ]]; then ensure_admin ; fi
				if [ "$UID" -eq 0 ]; then
					check_dependencies byobu && echo -e "$RED" "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again"
					su -c "$0 $*" "$SUDO_USER"
					clear
				fi
				exit
			fi
		fi
	;;
esac

# Clean up the environment just in case...
for var in $(compgen -v | grep '^_'); do
    unset "$var"
done
