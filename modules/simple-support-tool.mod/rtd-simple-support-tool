#!/bin/bash
if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi

#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::// Linux //::::::::
#:: 	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
	RTD_Version=2.1.2
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Display system information
#::		  - Update system software
#:: 		  - Bakup virtual machines
#::               - Cleanup/Report on PPA's (Ubuntu only)
#::               - Show systems physical location
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd-simple-support-tool" or if installed in the $PATH; by rtd simply 
#::	       type "rtd-sim + [TAB]" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
: ${_SCRIPTNAME=$(basename "${BASH_SOURCE[0]}")}
: ${_TLA=${_SCRIPTNAME:0:3}}
: ${BRANDING_ORG:="RTD"}
: ${BRANDING:="Simple Support Tool"}
: ${DIALOG_CANCEL:="1"}
: ${DIALOG_ESC:="255"}
: ${HEIGHT:="20"}
: ${WIDTH:="90"}
: ${LIST_HEIGHT:="12"}
: ${_GIT_PROFILE:=vonschutter}

# load documentation for this script in a variable for later use.
: ${_SIMPLE_SUPPORT_TOOL_DOC="$(tail -n +6 "$0" | head -n 25)"}


# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
: ${YELLOW:="\033[1;33m"}
: ${RED:="\033[1;31m"}
: ${ENDCOLOR:="\033[0m"}
: ${GREEN:="\033[1;32m"}
: ${BLUE:="\033[1;34m"}

# Set the background color of the tool. The appearance of the menu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option. This will
# override what is detected and preferred!
# Valid choices are: "dialog", "whiptail".
# RTD_GUI=dialog
# export NEWT_COLORS='root=,gray '
: ${RTD_GUI:="dialog --clear"}



# Override default values here:
# SSH_PUBLIC_KEY_FILE=
# PUT_ISO_FILE_HERE_WHEN_DONE=
# PUT_QCOW_FILE_HERE_WHEN_DONE=
# VOLUME_TITLE=
# VOLUME_SIZE=
# _src_url=
# _LOG_DIR=
# _LOGFILE=



# Set location to where to log information:
# in the system log directory in a file named the same as this script.
if [[ $EUID -ne 0 ]]; then
	_LOG_DIR="${_LOG_DIR:="${HOME}/.config/rtd/logs"}" ; mkdir -p ${_LOG_DIR}
	_LOGFILE="${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}" ; touch ${_LOGFILE}

else
	_LOG_DIR="${_LOG_DIR:="/var/log/${_TLA,,}"}" ; mkdir -p ${_LOG_DIR}
	_LOGFILE="${_LOGFILE:="${_LOG_DIR}/${_SCRIPTNAME}.log"}" ; touch ${_LOGFILE}

fi



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.




dependency::file () 
{
# Function: dependency::file
# Description: This function is used to search for and load a dependency file. It first searches for the 
# file locally in various paths, and if not found, it attempts to download it from a specified URL. 
# If both local and online search fails, it logs an error and exits.
# Parameters:
#   - $1: The name of the dependency file to search for and load.
# Returns:
#   - 0: If the dependency file is found and successfully loaded.
#   - 1: If the dependency file is not found or fails to load.
# End of documentation

	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"
	
	dependency::search_local () {
		system::log_item "Requested dependency file: ${1} ..."

		local paths=(
			"./${1}"
			"../core/${1}"
			"../../core/${1}"
			"${0%/*}/../core/${1}"
			"${0%/*}/../../core/${1}"
			"$(dirname $(find /opt -name ${1} 2>/dev/null | head -n 1 ))/${1}"
			"$(dirname $(find ${HOME}/GIT -name ${1} 2>/dev/null | head -n 1 ))/${1}"
			"$(dirname $(find ${HOME}/bin -name ${1} 2>/dev/null | head -n 1 ))/${1}"
			)

		for path in "${paths[@]}"; do 
			system::log_item "Searching for ${path} ..."
			if [[ -e "${path}" ]]; then
				system::log_item "Found ${path}"
				source "${path}" ""
				return 0
			fi
		done

		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		system::log_item "$(date) failure to find $1 on the local computer, now searching online..."
		local tmpdir=$(mktemp -d)
		if curl -sL "$_src_url" -o "${tmpdir}/${1}" ; then 
			system::log_item "Using: ${_src_url} directly from URL..."
			source "${tmpdir}/${1}"
		elif wget "${_src_url}" -O "${tmpdir}/${1}" &>/dev/null ; then
			source "${tmpdir}/${1}"
			system::log_item "Using: ${_src_url} downloaded..."
		else 
			system::log_item "Failed to find  ${1} "
			exit 1
		fi
		rm -rf "${tmpdir}"
	fi 
}







system::log_item ()
{
# Description:
# The purpose of this function is to consistently write script output to the right log file. 
# By default, the log file will be /var/log/$(basename $0).log. 
# 
# This function will be used until it is replaced by the more extensive logging function in the
# _rtd_library file when it is sourced.
# 
# End of documentation
	local _logfile="${_LOGFILE}"

	local _date="$(date '+%Y/%m/%d %H:%M')"

	case "${FUNCNAME[1]}" in
		"write_error")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_warning") 
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_information")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_host")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		"write_status")
			echo "${_date}  --- : $*" >> "${_logfile}"
		;;
		*)
			echo "${_date}  --- : ðŸ§© ${FUNCNAME[1]}: $*" >> "${_logfile}"
		;;
	esac
}






rtd_oem_check_inet_access ()
{
# Function to verrify internet availabiltiy.
# The funciton will pause for 10 seconds by default, and will accept
# an integer to indicate a non-deault time to pause.

	_ARG=$1
	if [[ -z "$_ARG" ]]; then
		ping -c 1  8.8.8.8 &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
	else
		ping -c 1  8.8.8.8 &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
	fi
}









check_menu_availability ()
{
# Description: This function checks the availability of the menu system installed on the system.
# It first checks if "dialog" is installed, and if not, it checks if "whiptail" is installed.
# If neither is found, it displays an error message and exits.
# If "dialog" is found, it sets the RTD_GUI variable to "dialog --clear".
# If "whiptail" is found, it sets the RTD_GUI variable to "whiptail --fb".
# If the user chooses to install "dialog" instead of using "whiptail", it installs "dialog" and sets RTD_GUI to "dialog".
# If the user chooses not to install "dialog", it displays a message and exits.
# Parameters: None
# Returns: None
# End of documentation

	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" \
		--title "System Information Menu" \
		--no-button "NO: Use whiptail" \
		--yes-button "YES: Install dialog" \
		--yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: 
		DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal 
		menu system available... If you continue with the current WHIPTAIL some things might not work. 
		\n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			InstallSoftwareFromRepo dialog
			return
		else
			echo "User selected No, exit status was $?."
			return
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.

# Show Branding and version in UI
BRAND="ðŸ’» $BRANDING                        Managing:  $HOSTNAME                        Verson: $RTD_Version"
BRANDING="$BRAND"




display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About $( basename $0 ) " \
	--msgbox "
	This tool is part of the RTD System Support Tools.
	The purpose of this tool is to simplify management remote and local Linux systems.

	This script simplifies:
	- Basic Virtual Machine management
	- Auto Create and deploy VMs (Linux and Windows)
	- Change password, and encryption phrases of system disk
	- Perform distribution upgrades (supported distributions)
	- Remove unused PPA's (where relevant)
	- Display system information and resource usage

	To use this tool simply execute it: $( basename $0 )
	This tool is usefull for support staff that do not live on the command line daily, and
	can be used over ssh. If you do get disconnected the tool will remain active remotley
	and you can easily reconnect to it by re-establishing your ssh connection and typing
	the word: byobu in the terminal. "  $HEIGHT $WIDTH
	clear
}


show_notice_on_fist_run () {
	if [ -f ~/.config/rtd/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected; for example if you are
remotely connecting through SSH. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		mkdir -p ~/.config/rtd ; touch ~/.config/rtd/rtd-first-run-$RTD_Version
		clear
	fi
}


rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=( $RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
			2) InstallSoftwareFromRepo alpine ;;
			3) InstallSoftwareFromRepo vim ;;
			4) InstallSoftwareFromRepo finch ;;
			5) InstallSoftwareFromRepo wordgrinder ;;
			6) InstallSoftwareFromRepo sc ;;
			7) InstallSoftwareFromRepo tpp ;;
			8) InstallSoftwareFromRepo mc ;;
			9) InstallSoftwareFromRepo cmus ;;
			10) InstallSoftwareFromRepo byobu ;;
			11) InstallSoftwareFromRepo w3m ;;
			12) InstallSoftwareFromRepo lynx ;;
			13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb ;;
			14) InstallSoftwareFromRepo rtorrent ;;
			15) InstallSoftwareFromRepo openvpn ;;
			16) InstallSoftwareFromRepo freesweep ;;
			17) InstallSoftwareFromRepo bastet ;;
			esac
		done
}


show_make_media_gui_server ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install ISO for Ubuntu Server" \
		"2" "Automatic Install ISO for Ubuntu Graphical Server" \
		"3" "Automatic Install ISO for Debian Graphical Server" \
		"4" "Automatic Install ISO for Debian Minimal Server" \
		"5" "Automatic Install ISO for Minecraft Server (Latest)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return 		;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder openssh-server server
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			cleanup_and_finish
		;;
		3 )
			download_and_manipulate_iso_debian debian lxde-desktop server
			create_iso_image_debian
			cleanup_and_finish
		;;
		4 )
			download_and_manipulate_iso_debian kvm-server openssh-server server
			create_iso_image_debian
			cleanup_and_finish
		;;
		5 )
			download_and_manipulate_iso_debian debian openssh-server MinecraftServer
			create_iso_image_debian
			cleanup_and_finish
                ;;
		esac
	done
}



show_make_media_gui_desktop () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install Media for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Automatic Install Media for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Automatic Install Media for Ubuntu Gnome (without Ubuntu customization)" \
		"4" "Automatic Install Media for Ubuntu Minimal Standard desktop" \
		"5" "Automatic Install Media for Debian Default Desktop" \
		"6" "Automatic Install Media for Debian Light Weight Desktop" \
		"7" "Automatic Install Media for Debian Plasma Desktop" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builde ubuntu-desktop desktop
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder kubuntu-desktop desktop
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-gnome-desktop desktop
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder ubuntu-desktop-minimal desktop
			cleanup_and_finish
		;;
		5 )
			download_and_manipulate_iso_debian debian-desktop desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		6 )
			download_and_manipulate_iso_debian debian cinnamon-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		7 )
			download_and_manipulate_iso_debian debian kde-desktop
			create_iso_image_debian
			cleanup_and_finish
		;;
		esac
	done
}



show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "VM Managment Menu"  \
		--menu "Please select what you would like to do below:"  "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "List all virtual machines on this system" \
		"2" "Backup all running virtual machines on this server" \
		"3" "Monitor VM's on this system "\
		"4" "Create a VM template on this server" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			if hash virsh ; then
				result=$(virsh list --all )
				display_result "Virtual Machinces on this system:"
			else
				echo KVM Virtualization is not installed on this machine.
			fi
		;;
		2 )
			backup_running_vm
		;;
		3)
			echo "VM Status on This HOST: Press [Q] to quit."
			check_dependencies virt-top
			virt-top
		;;
		4 )
			while true; do
				exec 3>&1
				subselection2=$($RTD_GUI --backtitle "$BRANDING" --title "Make Virtual Machine" --menu "    "  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make a SERVER VM (Minimal single purpose system)" \
				"2" "Make a VDI VM (chose desktop and distribution)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					"$DIALOG_CANCEL") return	;;
					"$DIALOG_ESC") return ;;
				esac

				case $subselection2 in
					0) echo "Program terminated."
					;;
					1) show_deploy_server_VM_now_menu
					;;
					2) show_deploy_VDI_VM_now_menu
					;;
				esac
			done
		;;
		esac
	done
}


show_deploy_server_VM_now_menu ()
{

		while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Template VM Server"  --menu "Please select which type of VM to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Ubuntu Server" \
		"2" "Ubuntu Minimal Server" \
		"3" "Debian Print Server" \
		"4" "Debian Minimal Server" \
		"5" "Minecraft Server" \
		"6" "Fedora Minimal Server" \
		"7" "Ansible Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			write_information "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_template_now_from_ubuntu_com -r server -t ubuntu-server
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_template_now_from_ubuntu_com -r server -t ubuntu-server-minimal
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_template_now_from_debian_org -r server -t print-server
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_template_now_from_debian_org -r server -t openssh-server
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_template_now_from_ubuntu_com -r server -t minecraft-server -m 4098 -c 4
			cleanup_and_finish nomessage
		;;
		6 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ssh-server
			make_kvm_virtual_machine_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		7 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ansible-server
			make_kvm_virtual_machine_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		esac

	done
}


show_deploy_VDI_VM_now_menu ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "Deploy Virtual Desktop (VDI)"  --menu "Please select which VDI to create on this server:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1"  "Ubuntu Standard Desktop (more MAC like)" \
		"2"  "Ubuntu KDE Desktop (more Windows like)" \
		"3"  "Debian Default Desktop" \
		"4"  "Debian Cinnamon Desktop" \
		"5"  "Debian Plasma Desktop" \
		"6"  "Debian Light Weight Desktop (LXDE)" \
		"7"  "Fedora Workstation VDI" \
		"8"  "SUSE Workstation VDI" \
		"9"  "Windows 10 VDI" \
		"10" "Windows 11 VDI" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_template_now_from_ubuntu_com -r desktop -t ubuntu-desktop -m 4098 -c 4
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_template_now_from_ubuntu_com -r desktop -t kubuntu-desktop -m 4098 -c 4
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t gnome-desktop 
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t cinnamon-desktop 
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t kde-desktop 
			cleanup_and_finish nomessage
		;;
		6 )
			kvm::make_vm_template_now_from_debian_org -r desktop -t lxde-desktop 
			cleanup_and_finish nomessage
		;;
		7 )
			make_kvm_virtual_machine_now_from_fedora_org
			cleanup_and_finish nomessage
		;;
		8 )
			PRESEED_FILE="$(mktemp).xml"
			generate_autoyast_file "${PRESEED_FILE}"
			make_kvm_virtual_machine_now_from_opensuse_com SUSE
			cleanup_and_finish nomessage
		;;
		9 )
			make_kvm_virtual_machine_now_from_microsoft win10
		;;
		10 )
			make_kvm_virtual_machine_now_from_microsoft win11
		;;
		esac

	done
}


show_view_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Show system summary" \
		"2" "Display OS Informaton" \
		"3" "View Windows Product KEY in system BIOS (if present)" \
		"4" "Show storage device space utilization" \
		"5" "Show users HOME folder storage use" \
		"6" "Show complete storage utilization by directory" \
		"7" "Show system temperature information" \
		"8" "Show detailed system CPU information" \
		"9" "List PCI Devices" \
		"10" "List USB devices" \
		"11" "Show systems physical location (city, county etc.)" \
		"12" "Show the weather forcast at the location of this system" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear ; unset result

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			check_dependencies neofetch || (rtd_oem_pause 1 ; return ) && clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			result=$(hostnamectl)
			: ${result:="No system information found..."}
			display_result "OS Information:"
		;;
		3 )
			result=$(system::get_Windows_Product_Key)
			: ${result:="No Windows product key found..."}
			display_result "Windows Product Key:"
		;;
		4 )
			result=$(df -h -x squashfs -x tmpfs)
			$RTD_GUI --backtitle "$BRANDING" --title "System Storage Space" --msgbox "$result" 20 100
		;;
		5 )
			generate_report_disk_space_used_by_directory /home
			display_result "Home Space Utilization (All Users)"
		;;
		6 )
			generate_report_disk_space_used_by_directory /
			display_result "Total Space Utilization root directory:"
		;;
		7 )
			check_dependencies lm-sensors
			sudo /etc/init.d/kmod start
			check_dependencies hddtemp
			sudo sensors-detect --auto
			result="$( sensors )"
			display_result "System Temperature Information"
		;;
		8 )
			result="$( lscpu )"
			display_result "System CPU Information on $HOSTNAME:"
		;;
		9 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local PCI devices on $HOSTNAME:" --msgbox "$(lspci)" ${HEIGHT:-"20"} 0
			clear
		;;
		10 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local USB devices on $HOSTNAME:" --msgbox "$(lsusb)" ${HEIGHT:-"20"} 0
			clear
		;;
		11 )
			check_dependencies curl &>/dev/null
			check_dependencies dnsutils &>/dev/null
			result=$(curl ipinfo.io/$(dig +short myip.opendns.com @resolver1.opendns.com))
			display_result "This systems location on the Internet"
		;;
		12 )
			check_dependencies curl
			write-host "Your local weather is"
			curl http://wttr.in
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}










show_monitor_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Overview of system activities and load" \
		"2" "Monitor network usage by app" \
		"3" "Monitor System Load" \
		"4" "Monitor network traffic" \
		"5" "Monitor Kernel messages" \
		"6" "Monitor system log" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear ; unset result ; unset _RUN

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			_RUN="bashtop"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		2 )
			_RUN="nethogs"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		3 )
			_RUN="glances"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		4 )
			_RUN="bmon"
			if ! hash "${_RUN}" ; then
				check_dependencies ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		5 )
			trap "return" SIGINT
			dmesg --human --follow
			read -p "Press [Enter] key to return to the main menu: "
		;;
		6 )
			trap "return" SIGINT
			if [[ -e /var/log/syslog ]]; then
				tail -f /var/log/syslog
			elif  [[ -e /var/log/messages ]]; then
				tail -f /var/log/messages
			else
				write_warning "no relevant log file found"
			fi
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}











show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		"6" "Remove all known non-western fonts" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
		0 )
			exit_status=$?
		;;
		1 )
			rtd_update_system ; rtd_oem_pause 1
		;;
		2 )
			dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				result="$(rtd_ppa_checker)"
				display_result "Packages Installed from Personal Package Archives"
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		3 )
			dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				display_result "Functionality Not Supported"
			fi
		;;
		4 )
			rtd_oem_release_upgrade
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		6 )
			rtd_oem_remove_non_western_latin_fonts
		;;
		esac
	done
}


show_main_menu () {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --keep-tite --backtitle "$BRANDING" --cancel-button "EXIT" --title "RTD Tool Main Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "ðŸ“ˆ Monitor performance and statistics" \
			"2" "ðŸ“‹ View information about this system" \
			"3" "ðŸ”§ Manage Software on this system" \
			"4" "ðŸ”§ Manage Virtual Machines (KVM) on this system" \
			"5" "ðŸ”§ Manage encryption phrases and passwords" \
			"6" "ðŸ’½ Make media to automatically install OS (for VM's and CD burning)" \
			"7" "ðŸ†™ Shortcut: Update this system now"\
			"8" "â„¹ï¸  About this tool" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit 0
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 0
			;;
		esac

		case $selection in
			0 )
				echo "Program terminated."
			;;
			1 ) show_monitor_informaion_about_this_system
			;;
			2 )	show_view_informaion_about_this_system
			;;
			3 )	show_manage_software_gui
			;;
			4 )	show_manage_vm_gui
			;;
			5 )	show_manage_crypt_sec
			;;
			6 )
			while true; do
				exec 3>&1
					subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
					"1" "Make media to build a server (ISO or USB Disk)" \
					"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
					2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					$DIALOG_CANCEL) show_main_menu ;;
					$DIALOG_ESC) return ;;
				esac

				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
			;;
			7 )
				software::update_all_ui
				#read -p "Press [Enter] key to return to the main menu: "
			;;
			8 )
			display_notice
			;;
		esac
	done
}


show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
			--backtitle "$BRANDING" \
			--title "Manage encryption phrases and passwords" \
			--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "Check if a password is stolen" \
			"2" "Change systems disk encrytion pass phrase" \
			"3" "Change "$SUDO_USER" password" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL) return ;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
			0 )
				echo "Program terminated."
			;;
			1 )
				check_if_password_p0wned
			;;
			2 )
				system::change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functoinality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-
			clear

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi

case $1 in
	about | --about | --help | -h )
		display_notice
		exit
	;;
	* )
		if [[ "$TERM" == screen* ]]; then
			echo "$_SIMPLE_SUPPORT_TOOL_DOC" >> ${_LOGFILE}
			rtd_oem_check_inet_access
			dependency::file _rtd_library &>/dev/null
			if [[ $EUID -ne 0 ]]; then ensure_admin ; fi
			if [ "$UID" -eq 0 ]; then
				check_menu_availability
				show_notice_on_fist_run
				show_main_menu
			fi
			exit
		else
			if hash byobu 2>/dev/null; then
				byobu new-session -s "RTD Simple Server Support Tools" $0
			else
				rtd_oem_check_inet_access
				dependency::file _rtd_library &>/dev/null
				if [[ $EUID -ne 0 ]]; then ensure_admin ; fi
				if [ "$UID" -eq 0 ]; then
					check_dependencies byobu && echo -e "$RED" "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again"
					su -c "$0 $*" "$SUDO_USER"
					clear
				fi
				exit
			fi
		fi
	;;
esac

# Clean up the environment just in case...
for var in $(compgen -v | grep '^_'); do
    unset $var
done
