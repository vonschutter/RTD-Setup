#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::// Linux //::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
	RTD_Version=2.1.3
:	${GIT_Profile:=vonschutter}
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Display system information
#::		  - Update system software
#:: 		  - Bakup virtual machines
#::               - Cleanup/Report on PPA's (Ubuntu only)
#::               - Show systems physical location
#::		  - Check if a password you intend to use is for sale on the Darknet
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
: ${_SCRIPTNAME=$(basename $0)}
: ${_TLA=${_SCRIPTNAME:0:3}}
: ${BRANDING_ORG:="RTD"}
: ${BRANDING:="Simple Support Tool"}
: ${DIALOG_CANCEL:="1"}
: ${DIALOG_ESC:="255"}
: ${HEIGHT:="20"}
: ${WIDTH:="90"}
: ${LIST_HEIGHT:="12"}




# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
: ${YELLOW:="\033[1;33m"}
: ${RED:="\033[1;31m"}
: ${ENDCOLOR:="\033[0m"}
: ${GREEN:="\033[1;32m"}
: ${BLUE:="\033[1;34m"}

# Set the background color of the tool. The appearance of the menu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option. This will
# override what is detected and preferred!
# Valid choices are: "dialog", "whiptail".
# RTD_GUI=dialog
# export NEWT_COLORS='root=,gray '
: ${RTD_GUI:="dialog --clear"}



# Override default values here:
# SSH_PUBLIC_KEY_FILE=
# PUT_ISO_FILE_HERE_WHEN_DONE=
# PUT_QCOW_FILE_HERE_WHEN_DONE=
# VOLUME_TITLE=


# Set location to where to log information:
# in the system log directory in a file named the same as this script.
: ${LOGDIR:="/var/log/rtd"}
LOGFILE="${LOGDIR}/$( basename $0 ).log"


# Seting entries to conform to internal naming standard for max compatability.
_ERRLOGFILE="${LOGFILE}"
_LOGFILE="${LOGFILE}"


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.

check_rtd_library ()
{
	_src_url=https://github.com/${_GIT_PROFILE}/RTD-Setup/raw/main/core/_rtd_library

	if source "$( cd "$( dirname "$(readlink -f ${BASH_SOURCE[0]})" )" && pwd )"/../../core/_rtd_library ; then
		# Library found in relative path...
		write_information "${FUNCNAME[0]} 1 Using:  $( cd "$( dirname "$(readlink -f ${BASH_SOURCE[0]})" )" && pwd )"/../../core/_rtd_library
	elif source $(find /opt -name _rtd_library |grep -v bakup ) ; then
		# Library not found in relative path: search the typical location...
		write_information "${FUNCNAME[0]} 2 Using: $(find /opt -name _rtd_library |grep -v bakup )"
	elif wget ${_src_url} ; then
		# Critical failure: downloaded copy from github.com
		source ./_rtd_library
	else
		# Abort condition: No mitigation steps worked.
		echo -e "RTD functions NOT loaded!"
		echo -e " "
		echo -e "Cannot ensure that the correct functionality is available"
		echo -e "Quiting rather than cause potential damage..."
		exit 1
	fi
}


dependency::file ()
{
	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"

	dependency::search_local ()
	{
		echo "${FUNCNAME[0]}: Requested dependency file: ${1} ..."

		for i in "./${1}" "../core/${1}" "../../core/${1}" "${0%/*}/../core/${1}" "${0%/*}/../../core/${1}" "$(find /opt -name ${1} |grep -v bakup )" ; do 
			echo "${FUNCNAME[0]}: Searching for ${i} ..."
			if [[ -e "${i}" ]] ; then 
				echo "${FUNCNAME[0]}: Found ${i}"
				source "${i}" ""
				return 0
			fi
		done
		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		echo "$(date) failure to find $1 on the local comuter, now searching online..."
		if curl -sL $_src_url | source /dev/stdin ; then 
			echo "${FUNCNAME[0]} Using: ${_src_url} directly from URL..."
		elif wget ${_src_url} &>/dev/null ; then
			source ./"${1}"
			echo "${FUNCNAME[0]} Using: ${_src_url} downloaded..."
		else 
			echo "${FUNCNAME[0]} Failed to find  ${1} "
			exit 1
		fi
	fi 
}





rtd_oem_check_inet_access ()
{
# Function to verrify internet availabiltiy.
# The funciton will pause for 10 seconds by default, and will accept
# an integer to indicate a non-deault time to pause.

	_ARG=$1
	if [[ -z "$_ARG" ]]; then
		ping -c 1  8.8.8.8 &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
	else
		ping -c 1  8.8.8.8 &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
	fi
}








check_menu_availability ()
{
# First discover what menu system is installed. Some systems use "dialog" and
# other systems use whiptail for the terminal to show menus and dialogs.
# If nothing is found, then make sure it is available before continuing.
# End of documentation
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --no-button "NO: Use whiptail" --yes-button "YES: Install dialog" --yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			InstallSoftwareFromRepo dialog
			return
		else
			echo "User selected No, exit status was $?."
			return
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}





#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.

# Show Branding and version in UI
BRAND="ðŸ’» $BRANDING                        Managing:  $HOSTNAME                        Verson: $RTD_Version"
BRANDING="$BRAND"




display_notice () {
	# Function to display a notice that the ISO creation is complete.
	# And describe what to de next.
	$RTD_GUI --backtitle "$BRANDING" \
	--title "About $( basename $0 ) " \
	--msgbox "
	This tool is part of the RTD System Support Tools.
	The purpose of this tool is to simplify management remote and local Linux systems.

	This script simplifies:
	- Basic Virtual Machine management
	- Auto Create and deploy VMs (Linux and Windows)
	- Change password, and encryption phrases of system disk
	- Perform distribution upgrades (supported distributions)
	- Remove unused PPA's (where relevant)
	- Display system information and resource usage

	To use this tool simply execute it: $( basename $0 )
	This tool is usefull for support staff that do not live on the command line daily, and
	can be used over ssh. If you do get disconnected the tool will remain active remotley
	and you can easily reconnect to it by re-establishing your ssh connection and typing
	the word: byobu in the terminal. "  $HEIGHT $WIDTH
	clear
}


show_notice_on_fist_run () {
	if [ -f ~/.config/rtd/rtd-first-run-$RTD_Version ]; then
		echo $RTD_Version has been used already and terms reviewed...
	else
		show_notice_on_fist_run_TEXT="
This looks like the first time you run this vesion of the RTD tools. Please note that these tools are provided as-is and for modification.

The RTD tools run in a separate terminal that you can re connect to if you should get disconnected; for example if you are
remotely connecting through SSH. This can be done by:
- re-connecting to the server with ssh
- then running command "byobu" if a session is already running on the server"

		$RTD_GUI --backtitle "$BRANDING" --title "DONE" --msgbox "$show_notice_on_fist_run_TEXT" 15 80
		mkdir -p ~/.config/rtd ; touch ~/.config/rtd/rtd-first-run-$RTD_Version
		clear
	fi
}


rtd_setup_choices_cli_workstation () {
	# Function to display legacy installation options. This will install software that is usefull
	# on a really old system, or a remote system only accessible via SSH. This may be a good
	# usecase if you happen to be in an opressed geographic locaiton where your only option is
	# to ssh to a remote server and access email and web that way. Perfomance in these cases
	# may be very poor over the internet (as for example with the great firewall of China). In
	# Such a case it would be usefull to have the good old CLI software! :)
	# List Options to be available for choice in the RTD System Configurator...
	cmd=( $RTD_GUI --backtitle "$BRANDING" --title "Terminal Software add on Options Menu" --separate-output --checklist "You can be productive in the cli environment. Please Select Software titles below that you want to add to this system:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "Base RTD OEM Software (basic admin tools usually needed)" on
		 2 "Alpine email client" off
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" off
		 5 "Word Grinder word precessor" off
		 6 "Spreadsheet Calculator" off
		 7 "TPP Presentation Program" off
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" off
		 10 "Byobu Terminal Window Manger" off
		 11 "W3M web Browser" off
		 12 "LYNX Web Browser (Browse the web directly in the terminal)" off
		 13 "Mega.nz command line tools (Mega-CMD)" off
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" off
		 16 "Games: Freesweep mine sweep game" off
		 17 "Games: Bastet Tetris Game" off
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
			2) InstallSoftwareFromRepo alpine ;;
			3) InstallSoftwareFromRepo vim ;;
			4) InstallSoftwareFromRepo finch ;;
			5) InstallSoftwareFromRepo wordgrinder ;;
			6) InstallSoftwareFromRepo sc ;;
			7) InstallSoftwareFromRepo tpp ;;
			8) InstallSoftwareFromRepo mc ;;
			9) InstallSoftwareFromRepo cmus ;;
			10) InstallSoftwareFromRepo byobu ;;
			11) InstallSoftwareFromRepo w3m ;;
			12) InstallSoftwareFromRepo lynx ;;
			13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb ;;
			14) InstallSoftwareFromRepo rtorrent ;;
			15) InstallSoftwareFromRepo openvpn ;;
			16) InstallSoftwareFromRepo freesweep ;;
			17) InstallSoftwareFromRepo bastet ;;
			esac
		done
}


show_make_media_gui_server ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create.  (to Burn to CD, or trafer to a USB, or use with a VM):" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install ISO for Ubuntu Server" \
		"2" "Automatic Install ISO for Ubuntu Graphical Server" \
		"3" "Automatic Install ISO for Debian Graphical Server" \
		"4" "Automatic Install ISO for Debian Minimal Server" \
		"5" "Automatic Install ISO for Minecraft Server (Latest)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			rtd_oem_ubuntu_auto_install_iso_builder openssh-server server
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder xubuntu-core server
			cleanup_and_finish
		;;
		3 )
			system::download_and_manipulate_iso_debian --role server --server_role openssh-server --DE lxde-desktop
			cleanup_and_finish
		;;
		4 )
			system::download_and_manipulate_iso_debian --role server --server_role openssh-server 
			cleanup_and_finish
		;;
		5 )
			system::download_and_manipulate_iso_debian --role server --server_role MinecraftServer 
			cleanup_and_finish
                ;;
		esac
	done
}



show_make_media_gui_desktop () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Automatic OS Install Media"  --menu "Please select which automatic operating system installation media to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT"  \
		"1" "Automatic Install Media for Ubuntu Standard Desktop (more MAC like)" \
		"2" "Automatic Install Media for Ubuntu with Plasma Desktop (more Windows like)" \
		"3" "Automatic Install Media for Ubuntu Gnome (without Ubuntu customization)" \
		"4" "Automatic Install Media for Ubuntu Minimal Standard desktop" \
		"5" "Automatic Install Media for Debian Default Desktop" \
		"6" "Automatic Install Media for Debian Light Weight Desktop" \
		"7" "Automatic Install Media for Debian Plasma Desktop" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			system::log_item "chosen: Automatic Install Media for Ubuntu Standard Desktop (more MAC like)"
			rtd_oem_ubuntu_auto_install_iso_builder --distro ubuntu --role workstation  --DE ubuntu-desktop --ask YES
			#ubuntu-desktop desktop
			cleanup_and_finish
		;;
		2 )
			rtd_oem_ubuntu_auto_install_iso_builder --distro ubuntu --role workstation  --DE kubuntu-desktop --ask YES
			#kubuntu-desktop desktop
			cleanup_and_finish
		;;
		3 )
			rtd_oem_ubuntu_auto_install_iso_builder --distro ubuntu --role workstation  --DE ubuntu-gnome-desktop --ask YES
			#ubuntu-gnome-desktop desktop
			cleanup_and_finish
		;;
                4 )
			rtd_oem_ubuntu_auto_install_iso_builder --distro ubuntu --role workstation  --DE ubuntu-desktop-minimal --ask YES
			cleanup_and_finish
		;;
		5 )
			system::download_and_manipulate_iso_debian --distro debian --role workstation  --DE gnome-desktop --ask YES
			cleanup_and_finish
		;;
		6 )
			system::download_and_manipulate_iso_debian --distro debian --role workstation --DE  cinnamon-desktop --ask YES
			cleanup_and_finish
		;;
		7 )
			system::download_and_manipulate_iso_debian --distro debian --role workstation --DE  kde-desktop --ask YES
			cleanup_and_finish
		;;
		esac
	done
}



show_manage_vm_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" \
		--title "VM Managment Menu"  \
		--menu "Please select what you would like to do below:"  "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "List all virtual machines on this system" \
		"2" "Backup all running virtual machines on this server" \
		"3" "Monitor VM's on this system "\
		"4" "Create a VM template on this server" \
		2>&1 1>&3 )
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			if hash virsh ; then
				result=$(virsh list --all )
				dialog::display_result "Virtual Machines on this system:"
			else
				echo KVM Virtualization is not installed on this machine.
			fi
		;;
		2 )
			kvm::backup_running_vm
		;;
		3)
			echo "VM Status on This HOST: Press [Q] to quit."
			software::check_native_package_dependency virt-top
			virt-top
		;;
		4 )
			while true; do
				exec 3>&1
				subselection2=$($RTD_GUI --backtitle "$BRANDING" --title "Make Virtual Machine" --menu "    "  $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Make a SERVER VM (Minimal single purpose system)" \
				"2" "Make a VDI VM (chose desktop and distribution)" \
				2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					"$DIALOG_CANCEL") return	;;
					"$DIALOG_ESC") return ;;
				esac

				case $subselection2 in
					0) echo "Program terminated."
					;;
					1) show_deploy_server_VM_now_menu
					;;
					2) show_deploy_VDI_VM_now_menu
					;;
				esac
			done
		;;
		esac
	done
}


show_deploy_server_VM_now_menu()
{

		while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Create Template VM Server"  --menu "Please select which type of VM to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "ðŸ§ Ubuntu Server" \
		"2" "ðŸ§ Ubuntu LAMP Server" \
		"3" "ðŸ§ Ubuntu Postfix Server" \
		"4" "ðŸ§ Ubuntu Bind9 Server" \
		"5" "ðŸ§ Ubuntu DHCP Server" \
		"6" "ðŸ§ Ubuntu Samba Server" \
		"7" "ðŸ§ Ubuntu Print Server" \
		"8" "ðŸ§ Ubuntu Graphical Server" \
		"9" "ðŸŒ€ Debian Print Server" \
		"10" "ðŸŒ€ Debian Minimal Server" \
		"11" "â›ï¸ Minecraft Server" \
		"12" "ðŸŽ© Fedora Minimal Server" \
		"13" "ðŸŽ© Fedora Ansible Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			clear
			write_information "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app ubuntu-server --ask YES
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app lamp-server --ask YES
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app postfix --ask YES
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app bind9 --ask YES
			cleanup_and_finish nomessage
		;;
		5 ) 
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app dhcp-server --ask YES
			cleanup_and_finish nomessage
		;;
		6 ) 
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app samba --ask YES
			cleanup_and_finish nomessage
		;;
		7 ) 
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app print-server --ask YES
			cleanup_and_finish nomessage
		;;
		8 )
			kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app server-desktop --DE xubuntu-desktop --ask YES
			cleanup_and_finish nomessage
		;;
		9 )
			kvm::make_vm_now_from_debian_org --role server --server_role print-server
			cleanup_and_finish nomessage
		;;
		10 )
			kvm::make_vm_now_from_debian_org --role server --server_role openssh-server
			cleanup_and_finish nomessage
		;;
		11 )
			kvm::make_vm_now_from_ubuntu_com --role server --pre-config minecraft --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		12 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ssh-server
			kvm::make_vm_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		13 )
			PRESEED_FILE="$(mktemp)"
			generate_fedora_ks_cfg_file "${PRESEED_FILE}" ansible-server
			kvm::make_vm_now_from_fedora_org fedora30
			cleanup_and_finish nomessage
		;;
		esac

	done
}


show_deploy_VDI_VM_now_menu ()
{
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BRANDING" --title "Create a Virtual Desktop (VDI) Template"  --menu "Please select which VDI Template to create on this server:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1"  "ðŸ§ Ubuntu Standard Desktop       (more MAC like)" \
		"2"  "ðŸ§ Ubuntu KDE Desktop            (more Windows like)" \
		"3"  "ðŸ§ Ubuntu Xubuntu Desktop        (light weight server VDI)" \
		"4"  "ðŸ§ Ubuntu Mate Desktop           (light weight Server VDI)" \
		"5"  "ðŸ§ Ubuntu Lubuntu Desktop        (light weight Server VDI)" \
		"6"  "ðŸ§ Ubuntu Cinnamon Desktop       (Convenient features)" \
		"7"  "ðŸŒ€ Debian Default Desktop        (reseal manually)" \
		"8"  "ðŸŒ€ Debian Cinnamon Desktop       (reseal manually)" \
		"9"  "ðŸŒ€ Debian Plasma Desktop         (reseal manually)" \
		"10"  "ðŸŒ€ Debian Light Weight Desktop   (reseal manually)" \
		"11"  "ðŸŽ© Fedora Workstation VDI        (reseal manually)" \
		"12"  "ðŸŽ© Fedora Plasma (KDE) VDI       (reseal manually)" \
		"13"  "ðŸŽ© Fedora Mate Desktop VDI       (reseal manually)" \
		"14"  "ðŸŽ© Fedora Cinnamon Desktop VDI   (reseal manually)" \
		"15"  "ðŸŽ© Fedora Budgie Desktop VDI     (reseal manually)" \
		"16"  "ðŸŽ© Fedora i3 Desktop VDI         (tiling wm)" \
		"17"  "ðŸŽ© Fedora Sway Desktop VDI       (tiling wm)" \
		"18"  "ðŸ¦Ž SUSE Default (KDE) VDI        (reseal manually)" \
		"19"  "ðŸ¦Ž SUSE Gnome VDI                (reseal manually)" \
		"20"  "ðŸ¦Ž SUSE XFCE VDI                 (light weight)" \
		"21"  "ðŸ¦Ž SUSE LXDE VDI                 (light weight)" \
		"22"  "ðŸ¦Ž SUSE Mate VDI                 (light weight)" \
		"23"  "ðŸ¦Ž SUSE Cinnamon VDI             (light weight)" \
		"24"  "ðŸªŸ Windows 10 VDI                (reseal manually)" \
		"25"  "ðŸªŸ Windows 11 VDI                (reseal manually)" \
		"26"  "ðŸ§ Zorin VDI                     (reseal manually)" \
		"27"  "ðŸ‰ Kali Security Suite VDI       (Penetration testing etc.)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app ubuntu-desktop --ask YES --tshirt-size medium 
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app kubuntu-desktop --ask YES --tshirt-size medium 
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app xubuntu-desktop --ask YES --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app ubuntu-mate-desktop --ask YES --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app lubuntu-desktop --ask YES
			cleanup_and_finish nomessage
		;;
		6 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app cinnamon-desktop-environment --ask YES
			cleanup_and_finish nomessage
		;;
		7 )
			kvm::make_vm_now_from_debian_org --role workstation --DE gnome-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		8 )
			kvm::make_vm_now_from_debian_org --role workstation --DE cinnamon-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		9 )
			kvm::make_vm_now_from_debian_org --role workstation --DE kde-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		10 )
			kvm::make_vm_now_from_debian_org --role workstation --DE lxde-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		11 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@workstation-product-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		12 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@kde-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		13 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@mate-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		14 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@cinnamon-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		15 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@budgie-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		16 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@i3-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		17 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@sway-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		18 )
			kvm::make_vm_now_from_opensuse_org --DE kde --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		19 )
			kvm::make_vm_now_from_opensuse_org --DE gnome --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		20 )
			kvm::make_vm_now_from_opensuse_org --DE xfce --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		21 )
			kvm::make_vm_now_from_opensuse_org --DE lxde --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		22 )
			kvm::make_vm_now_from_opensuse_org --DE mate --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		23 )
			kvm::make_vm_now_from_opensuse_org --DE cinnamon --product Leap --tshirt-size small
			cleanup_and_finish nomessage
		;;
		24 )
			kvm::make_vm_now_from_microsoft --winver win10 --tshirt-size medium
		;;
		25 )
			kvm::make_vm_now_from_microsoft --winver win11 --tshirt-size medium
		;;
		26 )
			kvm::make_vm_now_from_zorin --role desktop --flavor ubuntu --DE gnome-desktop --tshirt-size small
		;;
		27 )
			kvm::make_vm_now_from_kali_org --role workstation --DE standard --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		esac 

	done
}


show_view_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Show system summary" \
		"2" "Display OS Informaton" \
		"3" "View Windows Product KEY in system BIOS (if present)" \
		"4" "Show storage device space utilization" \
		"5" "Show users HOME folder storage use" \
		"6" "Show complete storage utilization by directory" \
		"7" "Show system temperature information" \
		"8" "Show detailed system CPU information" \
		"9" "List PCI Devices" \
		"10" "List USB devices" \
		"11" "Show systems physical location (city, county etc.)" \
		"12" "Show the weather forcast at the location of this system" \
		"13" "Check file limits on this system" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear ; unset result

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			software::check_native_package_dependency neofetch || (pause::for_input 1 ; return ) && clear
			neofetch --memory_display barinfo
			ip -br addr
			read -p "Press [Enter] key to return to the main menu: "
		;;
		2 )
			result=$(hostnamectl)
			: ${result:="No system information found..."}
			dialog::display_result "OS Information:"
		;;
		3 )
			result=$(system::get_Windows_Product_Key)
			: ${result:="No Windows product key found..."}
			dialog::display_result "Windows Product Key:"
		;;
		4 )
			result=$(df -h -x squashfs -x tmpfs)
			$RTD_GUI --backtitle "$BRANDING" --title "System Storage Space" --msgbox "$result" 20 100
		;;
		5 )
			system::generate_report_disk_space_used_by_directory /home
			dialog::display_result "Home Space Utilization (All Users)"
		;;
		6 )
			system::generate_report_disk_space_used_by_directory /
			dialog::display_result "Total Space Utilization root directory:"
		;;
		7 )
			software::check_native_package_dependency lm-sensors
			sudo /etc/init.d/kmod start
			software::check_native_package_dependency hddtemp
			sudo sensors-detect --auto
			result="$( sensors )"
			dialog::display_result "System Temperature Information"
		;;
		8 )
			result="$( lscpu )"
			dialog::display_result "System CPU Information on $HOSTNAME:"
		;;
		9 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local PCI devices on $HOSTNAME:" --msgbox "$(lspci)" ${HEIGHT:-"20"} 0
			clear
		;;
		10 )
			${RTD_GUI:-dialog} --backtitle "$BRANDING" --colors --no-collapse --title "\Z1 Local USB devices on $HOSTNAME:" --msgbox "$(lsusb)" ${HEIGHT:-"20"} 0
			clear
		;;
		11 )
			software::check_native_package_dependency curl &>/dev/null
			software::check_native_package_dependency dnsutils &>/dev/null
			result=$(network::whats_my_ipinfo)
			dialog::display_result "This systems location on the Internet"
		;;
		12 )
			software::check_native_package_dependency curl
			write_host "Your local weather is"
			curl http://wttr.in
			read -p "Press [Enter] key to return to the main menu: "
		;;
		13 )
			system::check_file_limits
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}










show_monitor_informaion_about_this_system () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI --keep-tite --backtitle "$BRANDING" --title "System Information Menu" --menu "" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "Overview of system activities and load" \
		"2" "Monitor network usage by app" \
		"3" "Monitor System Load" \
		"4" "Monitor network traffic" \
		"5" "Monitor Kernel messages" \
		"6" "Monitor system log" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear ; unset result ; unset _RUN

		case $exit_status in
			"$DIALOG_CANCEL") return	;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			_RUN="bashtop"
			if ! hash "${_RUN}" ; then
				software::check_native_package_dependency ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		2 )
			_RUN="nethogs"
			if ! hash "${_RUN}" ; then
				software::check_native_package_dependency ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		3 )
			_RUN="glances"
			if ! hash "${_RUN}" ; then
				software::check_native_package_dependency ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		4 )
			_RUN="bmon"
			if ! hash "${_RUN}" ; then
				software::check_native_package_dependency ${_RUN} || read -p "Press [Enter] key to return to the main menu: " && ${_RUN}
			else
				${_RUN}
			fi
		;;
		5 )
			trap "return" SIGINT
			dmesg --human --follow
			read -p "Press [Enter] key to return to the main menu: "
		;;
		6 )
			trap "return" SIGINT
			if [[ -e /var/log/syslog ]]; then
				tail -f /var/log/syslog
			elif  [[ -e /var/log/messages ]]; then
				tail -f /var/log/messages
			else
				write_warning "no relevant log file found"
			fi
			read -p "Press [Enter] key to return to the main menu: "
		;;
		esac
	done
}











show_manage_software_gui () {
	# List Options to be available for choice in the RTD System Configurator...
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BRANDING" --title "Software Managment Menu"  --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
		"1" "Update all software on this system" \
		"2" "Show what Personal Package Archives (PPA's) are defined on this system" \
		"3" "Remove all Personal Package Archives (PPA's) NOT in use on this system" \
		"4" "Attempt a full release upgrade " \
		"5" "Install Non-GUI productivity tools for a useful terminal based workstation" \
		"6" "Remove all known non-western fonts" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL) return	;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
		0 )
			exit_status=$?
		;;
		1 )
			software::update_system ; pause::for_input 1
		;;
		2 )
			dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				result="$(oftware::rtd_ppa_checker)"
				dialog::display_result "Packages Installed from Personal Package Archives"
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				result="$(oftware::rtd_ppa_checker)"
				dialog::display_result "Packages Installed from Personal Package Archives"
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				dialog::display_result "Functionality Not Supported"
			fi
		;;
		3 )
			dist_info="$(hostnamectl)"
			if echo $dist_info |grep ".*buntu" &>/dev/null ; then
				oftware::rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			elif echo $dist_info |grep "Pop!_OS" 2>/dev/null ; then
				oftware::rtd_ppa_checker --delete | $RTD_GUI --programbox "Personal Package Archive Check:" $HEIGHT $WIDTH
			else
				result="Non Ubuntu based distributions do not Support the use of Personal Package Archives \n Press [ OK ] to return to the prevous menu."
				dialog::display_result "Functionality Not Supported"
			fi
		;;
		4 )
			#rtd_oem_release_upgrade interactive
			oem::distro_release_upgrade --interactive
		;;
		5 )
			rtd_setup_choices_cli_workstation
		;;
		6 )
			rtd_oem_remove_non_western_latin_fonts
		;;
		esac
	done
}


show_main_menu () {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --keep-tite --backtitle "$BRANDING" --cancel-button "EXIT" --title "RTD Tool Main Menu" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "ðŸ“ˆ Monitor performance and statistics" \
			"2" "ðŸ“‹ View information about this system" \
			"3" "ðŸ”§ Manage Software on this system" \
			"4" "ðŸ”§ Manage Virtual Machines (KVM) on this system" \
			"5" "ðŸ”§ Manage encryption phrases and passwords" \
			"6" "ðŸ’½ Make media to automatically install OS (for VM's and CD burning)" \
			"7" "ðŸ†™ Shortcut: Update this system now"\
			"8" "â“ About this tool" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit 0
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 0
			;;
		esac

		case $selection in
			0 )
				echo "Program terminated."
			;;
			1 ) show_monitor_informaion_about_this_system
			;;
			2 )	show_view_informaion_about_this_system
			;;
			3 )	show_manage_software_gui
			;;
			4 )	show_manage_vm_gui
			;;
			5 )	show_manage_crypt_sec
			;;
			6 )
			while true; do
				exec 3>&1
					subselection1=$($RTD_GUI --backtitle "$BRANDING" --title "Create Automatic OS Install Media" --menu "Please select if you need to make media for a server or a desktop. You will be aksed if you you want to transfer the media to a DC/DVD/USB Stick or deploy directly as a VM"  $HEIGHT $WIDTH $LIST_HEIGHT \
					"1" "Make media to build a server (ISO or USB Disk)" \
					"2" "Make media to build a Desktop environment (ISO or USB Disk)" \
					2>&1 1>&3)
				exit_status=$?
				exec 3>&-
				clear

				case $exit_status in
					$DIALOG_CANCEL) show_main_menu ;;
					$DIALOG_ESC) return ;;
				esac

				case $subselection1 in
					0 ) echo "Program terminated."
					;;
					1 ) show_make_media_gui_server
					;;
					2 ) show_make_media_gui_desktop
					;;
				esac
			done
			;;
			7 )
				software::update_all_ui
				#read -p "Press [Enter] key to return to the main menu: "
			;;
			8 )
			display_notice
			;;
		esac
	done
}


show_manage_crypt_sec () {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
			--backtitle "$BRANDING" \
			--title "Manage encryption phrases and passwords" \
			--menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "Check if a password is stolen" \
			"2" "Change systems disk encrytion pass phrase" \
			"3" "Change "$SUDO_USER" password" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL) return ;;
			$DIALOG_ESC) return ;;
		esac

		case $selection in
			0 )
				echo "Program terminated."
			;;
			1 )
				security::check_if_password_pOwned
			;;
			2 )
				security::change_disk_pass
			;;
			3 )
				passwd $SUDO_USER
			;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script templates                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
# Useful code sniplet templates. Copy and paste these and the edit them
# as necessary to extend the functoinality of this tool.
#




menu_template () {
	while true; do
		exec 3>&1
		# Dialog Display Menu Items...
			selection=$($RTD_GUI \
				--backtitle "$BRANDING" \
				--title "Menu Title" \
				--menu "Please tell me what I can do for you:" $HEIGHT $WIDTH $LIST_HEIGHT \
				"1" "Description" \
				"2" "Description" \
				"3" "Description" \
				2>&1 1>&3)
			exit_status=$?
			exec 3>&-
			clear

		# Cases for how program exited...
		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 1
			;;
		esac

		# What to do depending on selection...
		case $selection in
			0 )
				clear
				echo "Program terminated."
			;;
			1 )
				# code
			;;
			2 )
				# code
			;;
			3 )
				# code
			;;
		esac
	done
}











#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.

if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi

case $1 in
	about | --about | --help | -h )
		display_notice
		exit
	;;
	* )
		if [[ "$TERM" == screen* ]]; then
			rtd_oem_check_inet_access
			if [ -z "${RTDFUNCTIONS}" ]; then
				dependency::file _rtd_library &>/dev/null|| { echo "ðŸ“š Failed to find _rtd_library"; exit 1; }
			else
				write_information "ðŸ“š _rtd_library is already loaded..."
			fi
			
			security::ensure_admin
			if [ "$UID" -eq 0 ]; then
				check_menu_availability
				show_notice_on_fist_run
				show_main_menu
			fi
			exit
		else
			if hash byobu 2>/dev/null; then
				byobu new-session -s "RTD Simple Server Support Tools" $0
			else
				rtd_oem_check_inet_access
				if [ -z "${RTDFUNCTIONS}" ]; then
					dependency::file _rtd_library &>/dev/null|| { echo "ðŸ“š Failed to find _rtd_library"; exit 1; }
				else
					write_information "ðŸ“š _rtd_library is already loaded..."
				fi
				
				security::ensure_admin
				if [ "$UID" -eq 0 ]; then
					software::check_native_package_dependency byobu && echo -e "$RED" "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again"
					su -c "$0 $*" "$SUDO_USER"
					clear
				fi
				exit
			fi
		fi
	;;
esac
