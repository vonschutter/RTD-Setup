#!/bin/bash
#::				S I M P L E     S Y S T E M   S U P P O R T    T O O L
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::// Linux //::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
:	${RTD_Version=0.2.0}
:	${GIT_Profile:=vonschutter}
#::
#::
#::	Purpose: To simplify support tasks
#::		  - Managing VM's
#::
#::     Usage: run the script "bash /path/to/rtd" or if installed in the $PATH; by rtd simply type "rtd" in a terminal.
#::
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#	NOTE:	This terminal program is written to be readable and documented to a very high degree. The reason is that
#		these apps are seldom changed and when they are, it is usefull to be able to understand why and how
#		things were built. Obviously, this becomes a useful learning tool as well; for all people that want to
#		learn how to write admin scripts. It is a good and necessary practice to document extensively and follow
#		patterns when building your own apps and config scripts. Failing to do so will result in a costly mess
#		for any organization after some years and people turnover.
#
#		As a general rule, we prefer using functions extensively because this makes it easier to manage the script
#		and facilitates several users working on the same scripts over time.
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies:
#
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#
#	Scripts may also be stand-alone if there is a reason for this. This script is written to function independently
#	so that it is easy to copy to many server systems, or just to use once on a remote system. This is accomplished by
#	including all functions and dependency checking in this script; as well as avoidnig relying on external files like
#	*.diff files. As a consequence of the portability benefit this script becomes rather large and time consuming to navigate.
#
#	Taxonomy of this script: we prioritize the use of functions over monolithic script writing, and proper indentation
#	to make the script more readable. Each function shall also be documented to the point of the obvious.
#	Suggested function structure per google guidelines:
#
#	function_descriptive_name () {
#		# Documentation and comments...
#		...code...
#	}
#
#
#	Our scripts are also structured in to three major sections: "settings", "functions", and "execute".
#	Settings, contain configurable options for the script. Functions, contain all functions. Execute,
#	contains all the actual logic and control of the script.
#
#
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Script Settings               ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# You may comment out or edit items as you deem necessary.
# Some formatting options for cli graphic display.
if [[ -z "$BASH_VERSINFO" ]]; then
	echo "ERROR: You must execute this script in a BASH Shell"
	exit 255
fi


: ${_SCRIPTNAME=$(basename $0)}
: ${_TLA=${_SCRIPTNAME:0:3}}
: ${BRANDING_ORG:="RunTime Data"}
: ${PRODUCT:="VM Tool"}
: ${BRANDING:=" ${BRANDING_ORG}: ${PRODUCT}"}
: ${DIALOG_CANCEL:="1"}
: ${DIALOG_ESC:="255"}
: ${HEIGHT:="20"}
: ${WIDTH:="90"}
: ${LIST_HEIGHT:="12"}
: ${_GIT_PROFILE:="vonschutter"}
: ${_GIT_REPO:="RTD-Setup"}

# Show backtitle and version in UI
: ${BACKTITLE:="üíª ${BRANDING}                       Managing VM's on:  ${HOSTNAME}                   Version: ${RTD_Version}"}


# Terminal Color Setup definitions. These settings allow the simlified use of
# text colors in the teminal. You may want to echo RED for error or GREEN for OK.
: ${YELLOW:="\033[1;33m"}
: ${RED:="\033[1;31m"}
: ${ENDCOLOR:="\033[0m"}
: ${GREEN:="\033[1;32m"}
: ${BLUE:="\033[1;34m"}

# Set the background color of the tool. The appearance of the menu system may
# look different on different systems depending on their default settings.
# Here we define the bacground color for consistency by seting the NEWT_COLORS= option. If "dialog"
# is the desired front end then you may set the DIALOG_COLORS= optoin for preferred colors.
# You may select a front end to the rtd tool below by seting the RTD_GUI= option. This will
# override what is detected and preferred!
# Valid choices are: "dialog", "whiptail".
# RTD_GUI=dialog
# export NEWT_COLORS='root=,gray '
: ${RTD_GUI:="dialog"}
declare -a RTD_VM_CLONE_ARGS=()



# Override default values here:
# SSH_PUBLIC_KEY_FILE=
# PUT_ISO_FILE_HERE_WHEN_DONE=
# PUT_QCOW_FILE_HERE_WHEN_DONE=
# VOLUME_TITLE=


# Set location to where to log information:
# in the system log directory in a file named the same as this script.
# The global variable _LOGFILE is used by _rtd_library to log information.
: ${_LOG_DIR:="/var/log/rtd"}
_LOGFILE="${_LOG_DIR}/$( basename $0 ).log"




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool Executive Functions      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the executive functions of this script. These are the functions
# that actually do the work requested.

main() {
	# This is the main function of this script. It is called when the script is executed

	local -a original_cli=("$@")
	local -a rerun_cmd=("$0")
	rerun_cmd+=("${original_cli[@]}")
	local rerun_cmd_string
	rerun_cmd_string=$(printf '%q ' "${rerun_cmd[@]}")
	rerun_cmd_string=${rerun_cmd_string% }

	dependency::file _rtd_library
	security::ensure_admin

	RTD_VM_CLONE_ARGS=()
	local -a positional_args=()

	while [[ $# -gt 0 ]]; do
		case "$1" in
			--sysprep)
				RTD_VM_CLONE_ARGS+=("--sysprep")
				shift
				;;
			--customize)
				if [[ -z "${2:-}" ]]; then
					write_error "--customize requires an argument specifying virt-customize options or a script path."
					return 1
				fi
				RTD_VM_CLONE_ARGS+=("--customize" "$2")
				shift 2
				;;
			*)
				positional_args+=("$1")
				shift
				;;
		esac
	done

	if ((${#positional_args[@]})); then
		set -- "${positional_args[@]}"
	else
		set --
	fi

	case ${1:-} in
		about | --about | --help | -h )
			display_notice
			exit
		;;
		--first-run | -f )
			show_notice_on_fist_run
			exit
		;;
		* )
			if [[ "$TERM" == screen* ]]; then

				if [ -z "${RTDFUNCTIONS}" ]; then
					dependency::file _rtd_library &>/dev/null|| { echo "üìö Failed to find _rtd_library"; exit 1; }
				else
					write_information "üìö _rtd_library is already loaded..."
				fi

				security::ensure_admin
				if [ "$UID" -eq 0 ]; then
					show_notice_on_fist_run
					vmtool::show_main_menu
				fi
				exit
			else
				if hash byobu &>/dev/null; then
					byobu new-session -s "RunTime Data VM Tool" "$rerun_cmd_string"
				else

					if [ -z "${RTDFUNCTIONS}" ]; then
						dependency::file _rtd_library &>/dev/null|| { echo "üìö Failed to find _rtd_library"; exit 1; }
					else
						write_information "üìö _rtd_library is already loaded..."
					fi
					
					security::ensure_admin
					if [ "$UID" -eq 0 ]; then
						software::check_native_package_dependency byobu && echo -e "$RED" "A critical component needed for this script to work properly was attempted to be added... Attempting to run the script again"
						su -c "$rerun_cmd_string" "$SUDO_USER"
						clear
					fi
					exit
				fi
			fi
		;;
	esac
}

dependency::file() {
	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"

	dependency::search_local ()
	{
		echo "${FUNCNAME[0]}: Requested dependency file: ${1} ..."

		for i in "./${1}" "../core/${1}" "../../core/${1}" "${0%/*}/../core/${1}" "${0%/*}/../../core/${1}" "$(find /opt -name ${1} |grep -v bakup )" ; do 
			echo "${FUNCNAME[0]}: Searching for ${i} ..."
			if [[ -e "${i}" ]] ; then 
				echo "${FUNCNAME[0]}: Found ${i}"
				source "${i}" ""
				return 0
			fi
		done
		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		echo "$(date) failure to find $1 on the local comuter, now searching online..."
		if curl -sL $_src_url | source /dev/stdin ; then 
			echo "${FUNCNAME[0]} Using: ${_src_url} directly from URL..."
		elif wget ${_src_url} &>/dev/null ; then
			source ./"${1}"
			echo "${FUNCNAME[0]} Using: ${_src_url} downloaded..."
		else 
			echo "${FUNCNAME[0]} Failed to find  ${1} "
			exit 1
		fi
	fi 
}









#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::            Tool GUI Functions            ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Functions that control how the the RTD menus are displayed are listed below
# in this section for better manageability. When scripts become rather large
# they become cumbersome to manage, then it is sometimes helpful to sections
# in some logical order.






display_notice() {
	system::log_item "INFO" "Displaying about information for $( basename $0 )"

	$RTD_GUI --backtitle "$BACKTITLE" \
	--title "About $( basename $0 ) " \
	--msgbox "
	This tool is part of the RunTime Data System Support Tools.
	The purpose of this tool is to simplify management of remote and local Linux systems.

	This script simplifies:
	- Basic Virtual Machine management
	- Auto Create and deploy VMs (Linux and Windows)
	- Auto download and install Linux and Windows in to VM templates
	- Change and create user preferences for the VM templates
	- Monitor running VM's

	To use this tool simply execute it: $( basename $0 )
	This tool is useful for support staff that do not live on the command line daily, and
	can be used over ssh. If you do get disconnected the tool will remain active remotely
	and you can easily reconnect to it by re-establishing your ssh connection and typing
	the word: byobu in the terminal. "  ${HEIGHT} ${WIDTH} 2>&1
	clear
}


show_notice_on_fist_run() {

	if [ -f ~/.config/rtd/rtd-first-run-${SCRIPTNAME}-${RTD_Version} ]; then
		write_status "$RTD_Version has been used already and terms reviewed..."
		return 0
	fi
	local tmpfile
	tmpfile=$(mktemp)

	cat >> "$tmpfile" <<-EOF

	 This looks like the first time you run this vesion of the VM Tool. Please note that this 
	 tool is provided as-is and for modification.

	 The RTD tools run in a separate terminal that you can re connect to if you should get 
	 disconnected; for example if you are remotely connecting through SSH. This can be done by:

	 - re-connecting to the server with ssh
	 - then running command byobu if a session is already running on the server

	 If you are not familiar with the byobu terminal program, please take a moment to read 
	 the documentation on how to use it.

	 The authors of this tool are not responsible for any damage or loss of data
	 that may occur as a result of using this tool. The authors of this tool are not 
	 responsible for any damage or loss of data. 

	 This tool is provided under the terms of the GNU General Public License (GPL) version 3.0. 
	 You may use this tool for any purpose, including commercial as outline in the licence below: 

	___________________________________________________________________________________________

	$(cat $_OEM_DIR/LICENSE || echo "License file not found, please lookup the licence online.")

	EOF

	$RTD_GUI --backtitle "$BACKTITLE" --no-collapse \
	--title "ABOUT $( basename $0 )" --textbox "$tmpfile" \
	${HEIGHT} ${WIDTH} 2>&1

	rm -f "$tmpfile" 
	
	mkdir -p ~/.config/rtd ; touch ~/.config/rtd/rtd-first-run-${SCRIPTNAME}-${RTD_Version}
	clear
}




manage_server_vm_templates() {
	while true; do
		exec 3>&1
		selection=$($RTD_GUI \
		--backtitle "$BACKTITLE" --cancel-button "Back" --title "Create Template VM Server"  --menu "Please select which type of VM to create:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "üêß Ubuntu Server" \
		"2" "üêß Ubuntu LAMP Server" \
		"3" "üêß Ubuntu Postfix Server" \
		"4" "üêß Ubuntu Bind9 Server" \
		"5" "üêß Ubuntu DHCP Server" \
		"6" "üêß Ubuntu Samba Server" \
		"7" "üêß Ubuntu Print Server" \
		"8" "üêß Ubuntu Graphical Server" \
		"9" "üêß Ubuntu Docker Server" \
		"10" "üåÄ Debian Print Server" \
		"11" "üåÄ Debian Minimal Server" \
		"12" "‚õèÔ∏è Minecraft Server" \
		"13" "üé© Fedora Minimal Server" \
		"14" "üé© Fedora Ansible Server" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
			0 )
				clear
				write_information "Program terminated by user..."
			;;
			1 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app ubuntu-server --ask YES
				cleanup_and_finish nomessage
			;;
			2 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app lamp-server --ask YES
				cleanup_and_finish nomessage
			;;
			3 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app postfix --ask YES
				cleanup_and_finish nomessage
			;;
			4 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app bind9 --ask YES
				cleanup_and_finish nomessage
			;;
			5 ) 
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app dhcp-server --ask YES
				cleanup_and_finish nomessage
			;;
			6 ) 
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app samba --ask YES
				cleanup_and_finish nomessage
			;;
			7 ) 
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app print-server --ask YES
				cleanup_and_finish nomessage
			;;
			8 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app server-desktop --DE xubuntu-desktop --ask YES
				cleanup_and_finish nomessage
			;;
			9 )
				kvm::make_vm_now_from_ubuntu_com --role server --flavor ubuntu --server-app docker.io --tshirt-size medium
				cleanup_and_finish nomessage
			;;
			10 )
				kvm::make_vm_now_from_debian_org --role server --server_role print-server
				cleanup_and_finish nomessage
			;;
			11 )
				kvm::make_vm_now_from_debian_org --role server --server_role openssh-server
				cleanup_and_finish nomessage
			;;
			12 )
				kvm::make_vm_now_from_ubuntu_com --role server --pre-config minecraft --tshirt-size medium
				cleanup_and_finish nomessage
			;;
			13 )
				kvm::make_vm_now_from_fedora_org --role server --server_role @minimal-server-environment --tshirt-size small
				cleanup_and_finish nomessage
			;;
			14 )
				kvm::make_vm_now_from_fedora_org --role server --server_role @network-server --tshirt-size small --tshirt-size small
				cleanup_and_finish nomessage
			;;
		esac
	done
}


manage_vdi_vm_templates() {
	# Description:

	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BACKTITLE" --cancel-button "Back" --title "Create a Virtual Desktop (VDI) Template"  --menu "Please select which VDI Template to create on this server:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1"  "üêß Ubuntu Standard Desktop       (more MAC like)" \
		"2"  "üêß Ubuntu KDE Desktop            (more Windows like)" \
		"3"  "üêß Ubuntu Xubuntu Desktop        (light weight server VDI)" \
		"4"  "üêß Ubuntu Mate Desktop           (light weight Server VDI)" \
		"5"  "üêß Ubuntu Lubuntu Desktop        (light weight Server VDI)" \
		"6"  "üêß Ubuntu Cinnamon Desktop       (Convenient features)" \
		"7"  "üåÄ Debian Default Desktop        (reseal manually)" \
		"8"  "üåÄ Debian Cinnamon Desktop       (reseal manually)" \
		"9"  "üåÄ Debian Plasma Desktop         (reseal manually)" \
		"10"  "üåÄ Debian Light Weight Desktop   (reseal manually)" \
		"11"  "üé© Fedora Workstation VDI        (reseal manually)" \
		"12"  "üé© Fedora Plasma (KDE) VDI       (reseal manually)" \
		"13"  "üé© Fedora Mate Desktop VDI       (reseal manually)" \
		"14"  "üé© Fedora Cinnamon Desktop VDI   (reseal manually)" \
		"15"  "üé© Fedora Budgie Desktop VDI     (reseal manually)" \
		"16"  "üé© Fedora i3 Desktop VDI         (tiling wm)" \
		"17"  "üé© Fedora Sway Desktop VDI       (tiling wm)" \
		"18"  "ü¶é SUSE Default (KDE) VDI        (reseal manually)" \
		"19"  "ü¶é SUSE Gnome VDI                (reseal manually)" \
		"20"  "ü¶é SUSE XFCE VDI                 (light weight)" \
		"21"  "ü¶é SUSE LXDE VDI                 (light weight)" \
		"22"  "ü¶é SUSE Mate VDI                 (light weight)" \
		"23"  "ü¶é SUSE Cinnamon VDI             (light weight)" \
		"24"  "ü™ü Windows 10 VDI                (reseal manually)" \
		"25"  "ü™ü Windows 11 VDI                (reseal manually)" \
		"26"  "üêß Zorin VDI                     (reseal manually)" \
		"27"  "üêâ Kali Security Suite VDI       (Penetration testing etc.)" \
		"28"  "üé© RedHat Enterprise Linux VDI   (reseal manually)" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
		0 )
			echo "Program terminated by user..."
		;;
		1 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app ubuntu-desktop --ask YES --tshirt-size medium 
			cleanup_and_finish nomessage
		;;
		2 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app kubuntu-desktop --ask YES --tshirt-size medium 
			cleanup_and_finish nomessage
		;;
		3 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app xubuntu-desktop --ask YES --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		4 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app ubuntu-mate-desktop --ask YES --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		5 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app lubuntu-desktop --ask YES
			cleanup_and_finish nomessage
		;;
		6 )
			kvm::make_vm_now_from_ubuntu_com --role VDI --server-app cinnamon-desktop-environment --ask YES
			cleanup_and_finish nomessage
		;;
		7 )
			kvm::make_vm_now_from_debian_org --role workstation --DE gnome-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		8 )
			kvm::make_vm_now_from_debian_org --role workstation --DE cinnamon-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		9 )
			kvm::make_vm_now_from_debian_org --role workstation --DE kde-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		10 )
			kvm::make_vm_now_from_debian_org --role workstation --DE lxde-desktop --tshirt-size small
			cleanup_and_finish nomessage
		;;
		11 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@workstation-product-environment" --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		12 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@kde-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		13 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@mate-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		14 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@cinnamon-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		15 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@budgie-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		16 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@i3-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		17 )
			kvm::make_vm_now_from_fedora_org --role workstation --DE "@sway-desktop-environment" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		18 )
			kvm::make_vm_now_from_opensuse_org --DE kde --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		19 )
			kvm::make_vm_now_from_opensuse_org --DE gnome --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		20 )
			kvm::make_vm_now_from_opensuse_org --DE xfce --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		21 )
			kvm::make_vm_now_from_opensuse_org --DE lxde --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		22 )
			kvm::make_vm_now_from_opensuse_org --DE mate --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		23 )
			kvm::make_vm_now_from_opensuse_org --DE cinnamon --product Tumbleweed --tshirt-size small
			cleanup_and_finish nomessage
		;;
		24 )
			kvm::make_vm_now_from_microsoft --winver win10 --tshirt-size medium
		;;
		25 )
			kvm::make_vm_now_from_microsoft --winver win11 --tshirt-size medium
		;;
		26 )
			kvm::make_vm_now_from_zorin --edition Core --version latest --tshirt-size small
		;;
		27 )
			kvm::make_vm_now_from_kali_org --role workstation --DE standard --tshirt-size medium
			cleanup_and_finish nomessage
		;;
		28 )
			kvm::make_vm_now_from_redhat_com --role workstation --DE "@workstation-product" --tshirt-size small
			cleanup_and_finish nomessage
		;;
		esac 

	done
}

show_settings_menu() {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BACKTITLE" --cancel-button "Back" --title "Manage VM Preferences"  --menu "Please select which Preference to manage:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "üîß Manage VM T-Shirt sizes and defaults" \
		"2" "ü¶æ Manage VM Unattended install preferences" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
			0 )
				clear
				write_information "Program terminated by user..."
			;;
			1 )
				kvm::get_vm_size_preferences --ask
			;;
			2 )
				kvm::get_vm_config_preferences --ask
			;;
		esac
	done
	

}


show_maintenance_menu() {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BACKTITLE" --cancel-button "Back" --title "Maintenance Tasks" --menu "Select a maintenance task to run:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
			"1" "üîç Dry run: list unused QCOW images" \
			"2" "üßπ Remove unused QCOW images" \
			"3" "üîç Dry run: list virtual floppy images" \
			"4" "üßπ Remove virtual floppy images" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL"|"$DIALOG_ESC") return ;;
		esac

		write_status "Maintenance menu selection: $selection"
		case $selection in
			1 ) vmtool::run_qcow_cleanup --dry-run ;;
			2 ) vmtool::run_qcow_cleanup ;;
			3 ) vmtool::run_floppy_cleanup --dry-run ;;
			4 ) vmtool::run_floppy_cleanup ;;
		esac
	done
}


vmtool::run_cleanup_task() {
	local task_title="$1"
	local func_name="$2"
	local match_regex="$3"
	local default_dir="$4"
	local summary_label="$5"
	local mode_flag="$6"

	local mode_label="execute"
	local -a args=()
	if [[ "$mode_flag" == "--dry-run" ]]; then
		mode_label="dry-run"
		args+=(--dry-run)
	fi

	local tmpfile display_file
	tmpfile=$(mktemp) || return 1

	write_status "Running ${task_title} (${mode_label})..."
	if ! ( TERMUITXT="nocolor" "$func_name" "${args[@]}" ) &>"$tmpfile"; then
		local cleanup_status=$?
		$RTD_GUI --backtitle "$BACKTITLE" --title "${task_title} (${mode_label}) failed" --textbox "$tmpfile" "$HEIGHT" "$WIDTH"
		rm -f "$tmpfile"
		write_warning "${task_title} (${mode_label}) failed with exit code ${cleanup_status}. See dialog for details."
		return 1
	fi

	display_file=$(mktemp) || { rm -f "$tmpfile"; return 1; }

	local summary_dir
	summary_dir=$(grep -o 'Directory=[^ ]*' "$tmpfile" | head -n1 | cut -d= -f2)
	[[ -z "$summary_dir" ]] && summary_dir="$default_dir"
	local title_suffix=""
	if [[ -n "$summary_dir" ]]; then
		title_suffix=" ‚Äî ${summary_dir}"
	fi

	local summary_line
	summary_line=$(grep -m1 "$summary_label" "$tmpfile" || true)

	printf "Directory: %s\nMode: %s\n\n" "${summary_dir}" "${mode_label}" >"$display_file"

	local listed=0
	local regex="$match_regex"
	while IFS= read -r line; do
		if [[ "$line" =~ $regex ]]; then
			local captured="${BASH_REMATCH[1]}"
			printf " - %s\n" "$(basename "$captured")" >>"$display_file"
			listed=1
		fi
	done <"$tmpfile"

	local summary_msg="${summary_line:-$(tail -n1 "$tmpfile")}"
	if (( listed == 0 )); then
		summary_msg=${summary_msg:-"No items found in ${summary_dir}."}
		write_status "${task_title} found nothing to remove; showing notice."
		$RTD_GUI --backtitle "$BACKTITLE" --title "${task_title}${title_suffix}" --msgbox "${summary_msg}" "$HEIGHT" "$WIDTH"
	else
		printf "\n%s\n" "${summary_msg}" >>"$display_file"
		write_status "Opening ${task_title} summary dialog (${task_title}${title_suffix})..."
		$RTD_GUI --backtitle "$BACKTITLE" --title "${task_title}${title_suffix}" --textbox "$display_file" "$HEIGHT" "$WIDTH"
	fi

	rm -f "$tmpfile" "$display_file"
	write_status "${task_title} (${mode_label}) finished; returning to maintenance menu."
}


vmtool::run_qcow_cleanup() {
	vmtool::run_cleanup_task \
		"QCOW Cleanup" \
		"kvm::cleanup_unused_qcow_images" \
		"remove unused disk: (.*)" \
		"/var/lib/libvirt/images" \
		"QCOW cleanup completed" \
		"$1"
}


vmtool::run_floppy_cleanup() {
	vmtool::run_cleanup_task \
		"Floppy Cleanup" \
		"kvm::cleanup_virtual_floppy_images" \
		"floppy image: (.*)" \
		"/var/lib/libvirt/boot" \
		"Floppy cleanup completed" \
		"$1"
}


show_manage_VM_template_menu() {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BACKTITLE" --cancel-button "Back" --title "Manage VM Templates"  --menu "Please select which VM Template to manage:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"1" "ü¶æ Create Server VM Templates" \
		"2" "ü¶æ Create Virtual Desktop VM Templates" \
		2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			"$DIALOG_CANCEL") return ;;
			"$DIALOG_ESC") return ;;
		esac

		case $selection in
			0 )
				clear
				write_information "Program terminated by user..."
			;;
			1 )
				manage_server_vm_templates
			;;
			2 )
				manage_vdi_vm_templates
			;;
		esac
	done
}

vmtool::map_role_to_server_task() {
	# Convert a server_meta_* role name to the server_task string used by ansible.
	local role="$1" short
	short="${role#server_meta_}"
	case "$short" in
		opennssh) echo "openssh-server" ;; # safety typo guard
		openssh) echo "openssh-server" ;;
		lamp) echo "lamp-server" ;;
		dns) echo "dns-server" ;;
		mail) echo "mail-server" ;;
		samba) echo "samba-server" ;;
		print) echo "print-server" ;;
		postgresql) echo "postgresql-server" ;;
		ubuntu) echo "ubuntu-server" ;;
		*) echo "$short" ;;
	esac
}

vmtool::ensure_ansible_repo() {
	# Ensure a local RTD-Ansible clone exists; clone if missing.
	: "${RTD_ANSIBLE_REPO:=https://github.com/vonschutter/RTD-Ansible.git}"
	: "${RTD_ANSIBLE_DIR:=${HOME}/GIT/RTD-Ansible}"

	if [[ -d "$RTD_ANSIBLE_DIR/.git" ]]; then
		system::log_item "RTD-Ansible found at ${RTD_ANSIBLE_DIR}"
		return 0
	fi

	if ! dependency::command_exists git; then
		write_error "git is required to clone RTD-Ansible."
		return 1
	fi

	mkdir -p "$(dirname "$RTD_ANSIBLE_DIR")"
	write_status "Cloning RTD-Ansible into ${RTD_ANSIBLE_DIR}..."
	if git clone --depth 1 "$RTD_ANSIBLE_REPO" "$RTD_ANSIBLE_DIR"; then
		write_information "RTD-Ansible cloned successfully."
		return 0
	fi

	write_warning "Failed to clone RTD-Ansible from ${RTD_ANSIBLE_REPO}"
	return 1
}

vmtool::build_server_role_menu() {
	# Build checklist entries dynamically from server_meta_* roles in RTD-Ansible.
	local repo="${RTD_ANSIBLE_DIR:-${HOME}/GIT/RTD-Ansible}"
	local roles_dir="${repo}/roles"
	local -n _out_ref="$1"
	_out_ref=()

	if [[ -d "$roles_dir" ]]; then
		while IFS= read -r role; do
			local label desc
			label="${role#server_meta_}"
			desc="${label//_/ }"
			# Default OFF for everything except openssh which we set ON.
			local state="OFF"
			[[ "$label" == "openssh" ]] && state="ON"
			_out_ref+=("$label" "$desc" "$state")
		done < <(find "$roles_dir" -maxdepth 1 -mindepth 1 -type d -name 'server_meta_*' -printf '%f\n' | sort)
	fi

	# Fallback if none found
	if (( ${#_out_ref[@]} == 0 )); then
		_out_ref=(
			"openssh" "SSH" ON
			"lamp" "LAMP stack" OFF
			"dns" "Bind9 DNS" OFF
			"mail" "Mail stack" OFF
			"samba" "Samba" OFF
			"print" "CUPS" OFF
			"postgresql" "PostgreSQL" OFF
			"ubuntu" "Base Ubuntu Server" OFF
		)
	fi
}

vmtool::prompt_cicd_options() {
	# Collect CI/CD options up front. Stores selections in globals:
	#   RTD_CICD_ENABLE, RTD_CICD_REPO, RTD_CICD_PLAYBOOK, RTD_CICD_TASKS, RTD_CICD_LLM_VARIANT, RTD_CICD_LLM_MODELS
	RTD_CICD_ENABLE=0
	RTD_CICD_REPO="${RTD_ANSIBLE_REPO:-https://github.com/vonschutter/RTD-Ansible.git}"
	RTD_CICD_PLAYBOOK="${RTD_ANSIBLE_PLAYBOOK:-playbooks/server-auto-config.yml}"
	RTD_CICD_TASKS="openssh-server"
	RTD_CICD_LLM_VARIANT="none"
	RTD_CICD_LLM_MODELS=""

	if ! dialog::prompt_yes_no --title "CI/CD" --message "Seed cloned VM with CI/CD ISO and auto-run ansible-pull?"; then
		write_information "CI/CD seeding disabled for this run."
		return 0
	fi

	RTD_CICD_ENABLE=1

	exec 3>&1
		RTD_CICD_REPO=$($RTD_GUI --backtitle "$BACKTITLE" --inputbox "Ansible repo URL" "$HEIGHT" "$WIDTH" "$RTD_CICD_REPO" 2>&1 1>&3)
		local exit_status=$?
	exec 3>&-
	[[ $exit_status -ne 0 ]] && { RTD_CICD_ENABLE=0; return 0; }

	exec 3>&1
		RTD_CICD_PLAYBOOK=$($RTD_GUI --backtitle "$BACKTITLE" --inputbox "Ansible playbook path" "$HEIGHT" "$WIDTH" "$RTD_CICD_PLAYBOOK" 2>&1 1>&3)
		exit_status=$?
	exec 3>&-
	[[ $exit_status -ne 0 ]] && { RTD_CICD_ENABLE=0; return 0; }

	local -a task_menu_entries=()
	vmtool::ensure_ansible_repo || write_warning "Using fallback menu (RTD-Ansible clone missing)."
	vmtool::build_server_role_menu task_menu_entries

	exec 3>&1
	local task_selection
	task_selection=$($RTD_GUI --backtitle "$BACKTITLE" --checklist "Select server meta-packages to apply" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
		"${task_menu_entries[@]}" 2>&1 1>&3)
		exit_status=$?
	exec 3>&-
	[[ $exit_status -ne 0 ]] && { RTD_CICD_ENABLE=0; return 0; }
	# Map selected role shorthands to server_task strings
	local -a mapped_tasks=()
	for item in $task_selection; do
		item=${item//\"/}
		local mapped
		mapped=$(vmtool::map_role_to_server_task "$item")
		[[ -n "$mapped" ]] && mapped_tasks+=("$mapped")
	done
	if (( ${#mapped_tasks[@]} == 0 )); then
		mapped_tasks=("openssh-server")
	fi
	RTD_CICD_TASKS=$(IFS=','; echo "${mapped_tasks[*]}")

	exec 3>&1
	RTD_CICD_LLM_VARIANT=$($RTD_GUI --backtitle "$BACKTITLE" --menu "LLM server option (optional)" "$HEIGHT" "$WIDTH" 6 \
		"none" "No LLM stack" \
		"ollama" "Ollama service (snap)" \
		"text-generation-webui" "text-generation-webui" \
		2>&1 1>&3)
		exit_status=$?
	exec 3>&-
	[[ $exit_status -ne 0 ]] && RTD_CICD_LLM_VARIANT="none"

	if [[ "$RTD_CICD_LLM_VARIANT" == "ollama" ]]; then
		exec 3>&1
			RTD_CICD_LLM_MODELS=$($RTD_GUI --backtitle "$BACKTITLE" --inputbox "Ollama models to pre-pull (comma-separated)" "$HEIGHT" "$WIDTH" "llama3" 2>&1 1>&3)
			exit_status=$?
		exec 3>&-
		[[ $exit_status -ne 0 ]] && RTD_CICD_LLM_MODELS=""
	else
		RTD_CICD_LLM_MODELS=""
	fi
}

vmtool::post_clone_ansible_pull() {
	# Use pre-collected CI/CD settings to attach a seed ISO and trigger ansible-pull on boot.
	local vm_name="$1"

	if [[ "${RTD_CICD_ENABLE:-0}" -ne 1 ]]; then
		write_information "CI/CD seeding skipped for $vm_name (not enabled)."
		return 0
	fi

	if kvm::cicd::configure_vm_with_ansible_pull \
		--vm "$vm_name" \
		--repo "${RTD_CICD_REPO}" \
		--playbook "${RTD_CICD_PLAYBOOK}" \
		--server-tasks "${RTD_CICD_TASKS}" \
		--llm-variant "${RTD_CICD_LLM_VARIANT}" \
		--llm-models "${RTD_CICD_LLM_MODELS}"; then
		write_information "CI/CD ISO attached to $vm_name; ansible-pull will run on boot."
	else
		write_warning "Failed to attach CI/CD ISO to $vm_name."
	fi
}


vmtool::wait_for_vm_stop() {
	# Poll until a VM reaches a stopped state or the timeout expires.
	local vm_name="$1"
	local timeout="${2:-30}"
	local waited=0
	local state

	while (( waited < timeout )); do
		state=$(virsh domstate "$vm_name" 2>/dev/null | tr '[:upper:]' '[:lower:]')
		if [[ "$state" == shut* || "$state" == "off" ]]; then
			return 0
		fi
		sleep 1
		(( waited++ ))
	done

	return 1
}

vmtool::start_stop_vm_menu() {
	if ! command -v virsh >/dev/null 2>&1; then
		dialog::display_error "‚ùå virsh not found. Please install libvirt-clients/libvirt-tools."
		return 1
	fi

	while true; do
		local -a menu_entries=()
		local vm state label action_hint selection exit_status

		while IFS= read -r vm; do
			[[ -z "$vm" ]] && continue
			state=$(virsh domstate "$vm" 2>/dev/null | tr '[:upper:]' '[:lower:]')
			case "$state" in
				running)
					label="üü¢ Running"
					action_hint="Stop"
				;;
				paused)
					label="‚è∏Ô∏è Paused"
					action_hint="Stop"
				;;
				shut*|off)
					label="‚ö™ Off"
					action_hint="Start"
				;;
				*)
					label="‚ùî ${state:-unknown}"
					action_hint="Toggle"
				;;
			esac
			menu_entries+=("$vm" "$label | ${action_hint} this VM")
		done < <(virsh list --all --name | grep -vi '^Template' | sed '/^$/d')

		if (( ${#menu_entries[@]} == 0 )); then
			dialog::display_error "No non-Template VMs found to manage."
			return 0
		fi

		exec 3>&1
		selection=$($RTD_GUI --backtitle "$BACKTITLE" --cancel-button "Back" --title "üöÄ Start / Stop VMs" --menu "Select a VM to start or stop.\nTemplate images are hidden automatically." "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" \
			"${menu_entries[@]}" 2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case "$exit_status" in
			"$DIALOG_CANCEL"|"${DIALOG_ESC:-255}") return ;;
		esac

		[[ -z "$selection" ]] && continue

		state=$(virsh domstate "$selection" 2>/dev/null | tr '[:upper:]' '[:lower:]')
		case "$state" in
			shut*|off|"")
				if ! dialog::prompt_yes_no --back-title "$BACKTITLE" --title "üöÄ Start VM" --message "Start \"$selection\"?\n\nCurrent state: ${state:-unknown}"; then
					continue
				fi
				if virsh start "$selection"; then
					kvm::wait_for_domain_start --domain "$selection" --timeout 90 || write_warning "Start signal sent but no start event observed for $selection."
					result="Launch requested for \"$selection\".\n\nLatest state: $(virsh domstate "$selection" 2>/dev/null || echo \"unknown\")"
					dialog::display_result "VM Starting"
				else
					dialog::display_error "Failed to start \"$selection\"."
				fi
			;;
			running|paused|pmsuspended*)
				if ! dialog::prompt_yes_no --back-title "$BACKTITLE" --title "üõë Stop VM" --message "Stop \"$selection\" gracefully?\n\nCurrent state: ${state}"; then
					continue
				fi
				if virsh shutdown "$selection"; then
					if vmtool::wait_for_vm_stop "$selection" 45; then
						result="\"$selection\" is now stopped."
						dialog::display_result "VM Stopped"
					else
						if dialog::prompt_yes_no --back-title "$BACKTITLE" --title "Force Stop?" --message "\"$selection\" did not stop within 45s.\nForce power off?"; then
							if virsh destroy "$selection"; then
								result="\"$selection\" was forcefully powered off."
								dialog::display_result "VM Powered Off"
							else
								dialog::display_error "Failed to force stop \"$selection\"."
							fi
						fi
					fi
				else
					dialog::display_error "Failed to send shutdown signal to \"$selection\"."
				fi
			;;
			*)
				dialog::display_error "Unknown state for \"$selection\"; cannot toggle automatically."
			;;
		esac
	done
}

vmtool::show_main_menu() {
	while true; do
		exec 3>&1
		selection=$( $RTD_GUI --backtitle "$BACKTITLE" --cancel-button "EXIT" --title "$_TLA VM Tool" --menu "" $HEIGHT $WIDTH $LIST_HEIGHT \
			"1" "‚ú® Deploy Server VM's" \
			"2" "‚ú® Deploy Virtual Desktop VM's" \
			"3" "üíø Create VM Templates" \
			"4" "‚ö° Start / Stop VM's" \
			"5" "üìê Tool Settings"\
			"6" "üßπ Maintenance" \
			"7" "‚ùì About this tool" \
			2>&1 1>&3)
		exit_status=$?
		exec 3>&-
		clear

		case $exit_status in
			$DIALOG_CANCEL)
				clear
				echo "Program terminated."
				exit 0
			;;
			$DIALOG_ESC)
				clear
				echo "Program aborted." >&2
				exit 0
			;;
		esac

			case $selection in
				0 ) echo "Program Quit."
				;;
				1 )
					vmtool::prompt_cicd_options
					write_status "Starting server template clone..."
					if ! kvm::clone_server_template_vm --post-clone-handler vmtool::post_clone_ansible_pull "${RTD_VM_CLONE_ARGS[@]}"; then
						write_warning "Clone cancelled or failed. No VM created."
					else
						if [[ -n "${RTD_LAST_CLONED_VM:-}" ]]; then
							write_information "Clone workflow finished. Last VM: ${RTD_LAST_CLONED_VM}"
							if virsh dominfo "${RTD_LAST_CLONED_VM}" &>/dev/null; then
								write_information "Verified VM exists: ${RTD_LAST_CLONED_VM}"
							else
								write_warning "VM ${RTD_LAST_CLONED_VM} not found after clone; please check libvirt logs."
							fi
						else
							write_warning "Clone reported success but RTD_LAST_CLONED_VM is empty."
						fi
					fi
				;;
				2 ) kvm::clone_vdi_template_vm "${RTD_VM_CLONE_ARGS[@]}"
				;;
				3 ) show_manage_VM_template_menu
				;;
				4 ) vmtool::start_stop_vm_menu
				;;
				5 ) show_settings_menu
				;;
				6 ) show_maintenance_menu
				;;
				7 ) display_notice
				;;
		esac
	done
}




#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Main Init                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below is the logic for starting this script. As this script pretty much exclusively uses
# functions and function calls for everything it is simple to control the flow of execution here.
# We must ensure that the script is run at the proper privileges and in a
# re-attachable session. This means that this script will not allow itself to be run in
# a root terminal or using the sudo command. The reason for this is that, in order to start in
# a detachable terminal session "byobu", it may not be launched by root. The script will
# need to be run as a normal administrative user with access to "sudo" a.k.a. a member of the
# "sudoers" security group. This helps adhere to the best practice of NOT using a root interactive
# terminal.


main "$@"
