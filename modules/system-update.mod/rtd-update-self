#!/bin/bash
RTD_UPDATE_SELF_VERSION=1.0
GIT_Profile=${GIT_Profile:-vonschutter}
#::
#::
#:: 					Update RTD admin tools Task Sequence
#::
#::                                     A D M I N   C O M M A N D
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::// Simple Admin Tool //::::::::::::::::::::::::::::::::::::::::// Linux //::::::::
#:: Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
#:: Version:	1.00
#::
#::
#:: Purpose: 	The purpose of the task sequence is to configure update the installed admin tools.
#::
#::
#::		This task sequence should be executed on a PC with the the RTD OEM installation or configuration
#::
#::
#::
#:: Background: This system configuration and installation script was created to facilitate geting the latest simple
#::             managment tools on to a computer already using the rtd tools.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
#
#
#	RTD admin scrips are placed in /opt/rtd/scripts. Optionally scripts may use the common
#	functions in _rtd_functions and _rtd_recipies.
#	  _rtd_functions -- contain usefull admin functions for scripts, such as "how to install software" on different systems.
#	  _rtd_recipies  -- contain software installation and configuration "recipies".
#	Scripts may also be stand-alone if there is a reason for this.



#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Settings                 ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Put a convenient link to the logs where logs are normally found...
# capture the 3 first letters as org TLA (Three Letter Acronym)
_SCRIPTNAME=$(basename $0)
_TLA=${_SCRIPTNAME:0:3}
_LOG_DIR=/var/log/${_TLA,,}
mkdir -p ${_LOG_DIR}
autoconfirm=${1}

# Set the GIT profile name to be used if not set elsewhere:
_GIT_PROFILE="${_GIT_PROFILE:-vonschutter}"

# Location of base administrative scripts and command-lets to get.
_git_src_url=https://github.com/${_GIT_PROFILE}/${_TLA^^}-Setup.git

# Determine log file names for this session
_LOGFILE=${_LOG_DIR}/$(date +%Y-%m-%d-%H-%M-%S-%s)-oem-setup.log

# List spciffic commands of software that are needed
_software_dependencies="zip dialog"


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Functions                ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

dependency::file ()
{
	local _src_url="https://github.com/${_GIT_PROFILE:-vonschutter}/RTD-Setup/raw/main/core/${1}"
	local _tgt="${1}"

	dependency::search_local ()
	{
		echo "${FUNCNAME[0]}: Requested dependency file: ${1} ..."

		for i in "./${1}" "../core/${1}" "../../core/${1}" "${0%/*}/../core/${1}" "${0%/*}/../../core/${1}" "$(find /opt -name ${1} |grep -v bakup )" ; do 
			echo "${FUNCNAME[0]}: Searching for ${i} ..."
			if [[ -e "${i}" ]] ; then 
				echo "${FUNCNAME[0]}: Found ${i}"
				source "${i}" ""
				return 0
			fi
		done
		return 1
	}

	if dependency::search_local "${1}" ; then
		return 0
	else
		echo "$(date) failure to find $1 on the local comuter, now searching online..."
		if curl -sL $_src_url | source /dev/stdin ; then 
			echo "${FUNCNAME[0]} Using: ${_src_url} directly from URL..."
		elif wget ${_src_url} &>/dev/null ; then
			source ./"${1}"
			echo "${FUNCNAME[0]} Using: ${_src_url} downloaded..."
		else 
			echo "${FUNCNAME[0]} Failed to find  ${1} "
			exit 1
		fi
	fi 
}



task_setup_rtd_basics() {
	write_information "Task: Attempting to get the latest RTD tools..."
	if [[ "${OSTYPE:0:5}" == "linux" ]]; then
		write_information "Linux OS Found: Attempting to get the latest RTD tools..."

		if ! hash git &>> ${_LOGFILE} ; then
			check_dependencies git
		fi

		[[ -d ${_THEME_DIR:-"/opt/${_TLA,,}/themes"} ]] && local _update_themes=yes

		if git clone --depth=1 ${_git_src_url} /opt/${_TLA,,}.tmp ; then
			write_information "Powertools successfully retrieved..."
			if [[ -d /opt/${_TLA,,}  ]] ; then
				mv /opt/${_TLA,,} ${_BackupFolderName:="/opt/${_TLA,,}.$(date +%Y-%m-%d-%H-%M-%S-%s).bakup"} 
				write_warning "Backing up old (${_TLA,,} ) to ${_BackupFolderName}.zip..." 
				zip -m -r -5 -q ${_BackupFolderName}.zip  ${_BackupFolderName} 
				rm -r ${_BackupFolderName} 
			fi

			mv /opt/${_TLA,,}.tmp /opt/${_TLA,,} ; rm -rf /opt/${_TLA,,}/.git 
			source /opt/${_TLA,,}/core/_rtd_library 
			oem::register_all_tools
			ln -s -f ${_LOG_DIR} -T ${_OEM_DIR}/log
			[[ -n $_update_themes ]] && oem::deploy_themes
			oem::rtd_tools_make_launchers
		else
			echo "Failed to retrieve powertools correctly! "
			echo "Suggestion: check write permission in "/opt" or internet connectivity."
			exit 1
		fi
		return $?
	elif [[ "$OSTYPE" == "darwin"* ]]; then
		echo "Mac OSX is currently not supported..."
	elif [[ "$OSTYPE" == "cygwin" ]]; then
		echo "CYGWIN is currently unsupported..."
	elif [[ "$OSTYPE" == "msys" ]]; then
		echo "Lightweight shell is currently unsupported... "
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
	else
		echo "This system is Unknown to this script"
	fi
}




rtd_wait_for_internet_availability () {
	echo "Waiting for internet access..."
	echo "NOTE: Free access to the internet is required to continue."
	while ! ping -c 1 -W 1 8.8.8.8 &>/dev/null ; do
		echo Waiting...
		sleep 5
	done
}



do_update ()
{
	rtd_wait_for_internet_availability
	if task_setup_rtd_basics ; then

		[[ --autoconfirm == ${autoconfirm} ]] || dialog --backtitle "$( basename $0 )" --title "${BRAND} tools updater: DONE!" --msgbox "\nUpdating the ${BRAND} tools done!. \n\n Press OK to confirm." 20 80 ; clear
		return 0
	else
		[[ --autoconfirm == ${autoconfirm} ]] || dialog --backtitle "$( basename $0 )" --title "${BRAND} tools updater: ERROR!" --msgbox "\nUpdating the ${BRAND} \Z1 FAILED!. \n\n Press OK to confirm." 20 80 ; clear
		return 1
	fi

}


#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Execute tasks                   ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# Using the common function library to elevate priviledges... This is only useful
# is the script is not run via sudo to begin with...
dependency::file _rtd_library


if [[ ${UID} -eq 0 ]] ; then
	# Execute only in the case of elevated privileges:
	oem_launch_me () {
		echo "$(date) executing $0"
		for i in $_software_dependencies ; do hash ${i} || check_dependencies ${i} ; done
		case ${autoconfirm} in
		--autoconfirm )
			clear && do_update
		;;
		* )
			if hash dialog ; then
				if ( dialog --backtitle "$( basename $0 )" --title "${BRAND} tools updater: NOTICE!" --yesno "\nMay I update the ${BRAND} OEM tools on your system now? Updating the ${BRAND} tools will ensure that the latest functionality and bug fixes are applied. \n\n Press OK to continue or NO to skip doing this." 20 80 ) ; then
					clear && do_update
				else
					clear && exit
				fi
			else
				echo -e $YELLOW
				echo "RTD Tools Updater Version $RTD_UPDATE_SELF_VERSION"
				echo "Hello $SUDO_USER ... I am going to update the rtd tools on this"
				echo " "
				echo "To cancel this, just close the terminal or press "CRTL C"."
				echo " "
				read -p "Press [ ENTER ] to continue with update"
				echo -e $ENDCOLOR
				do_update
			fi
		;;
		esac
	}
	oem_launch_me | tee ${_LOGFILE}
else
	# If privileges are not elevated; then request elevation using the appropriate method:
	_exec_local="$( cd "$( dirname "$(readlink -f ${BASH_SOURCE[0]})" )" && pwd )"/"$( basename ${0} )"
	if echo $(systemctl get-default ) |grep graphical &>/dev/null ; then pkexec env DISPLAY=$DISPLAY XAUTHORITY=$XAUTHORITY ${_exec_local} ${autoconfirm} ; else ensure_admin ; fi
	exit
fi
